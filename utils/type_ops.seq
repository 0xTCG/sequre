import param


class TypeOps:
#     def set_bit(x: int, p: int) -> int:
#         if p < 0:
#             raise ValueError(f'Invalid bit index: {p}')

#         return x | (1 << p)
    
#     def trunc_elem(elem: int, k: int) -> int:
#         return elem & ((1 << k) - 1)
    
#     def left_shift(elem: int, k: int) -> int:
#         if k < 0:
#             return elem >> k
        
#         return elem << k
    
#     def right_shift(elem: int, k: int) -> int:
#         if k < 0:
#             return elem << k
        
#         return elem >> k
    
#     def bit(elem: int, k: int) -> bool:
#         return (elem & (1 << k)) != 0
    
    def switch_pair[T1, T2](t: tuple[T1, T2]) -> tuple[T2, T1]:
        return t[1], t[0]
    
    def mod_pow[TP](value: TP, power, mod: TP) -> TP:
        # Performance warning: Not the most efficient implementation
        # See http://cacr.uwaterloo.ca/hac/about/chap14.pdf pg24-pg31 for better approach
        # Also see: https://stackoverflow.com/questions/354421/how-is-implemented-in-python
        if value == TP(0): return TP(0)
        number = TP(1)
        while power:
            if power & 1:
                number = number * value % mod
            power >>= 1
            value = value * value % mod
        
        return number

    def mod_inv[TP](value: TP, field: TP) -> TP:
        return TypeOps.mod_pow(value, field - 2, field)
    
    def double_to_fp[TP](x: float, k: int = param.NBIT_K, f: int = param.NBIT_F, field: TP = param.BASE_P) -> TP:
        sn: int = 1
        if x < 0:
            x = -x
            sn = -sn

        az = TP(int(x))

        az_shift: TP = az << f  # TypeOps.left_shift(az, f)
        az_trunc: TP = az_shift & ((1 << (k - 1)) - 1)  # TypeOps.trunc_elem(az_shift, k - 1)

        xf: float = x - int(x)  # remainder
        for fbit in range(f - 1, -1, -1):
            xf *= 2
            if (xf >= 1):
                xf -= int(xf)
                az_trunc = az_trunc | (1 << fbit)  # TypeOps.set_bit(az_trunc, fbit)
        
        return (az_trunc * sn) % field
    
    def fp_to_double(a, k = param.NBIT_K, f = param.NBIT_F, field = param.BASE_P):
        if isinstance(a, list[list[param.size_u]]):
            return TypeOps.__fp_to_double_mat(a, k, f, field)
        if isinstance(a, list[param.size_u]):
            return TypeOps.__fp_to_double_vec(a, k, f, field)
        if isinstance(a, param.size_u):
            return TypeOps.__fp_to_double_elem(a, k, f, field)
        
        raise TypeError(f"Invalid type of {a}.\n It shoudl be either, Int[N], list[Int[N]] ot list[list[Int[N]]]")
    
    def rand_bits_deprecated[TP](shape: list[int], num_bits: int, field: TP) -> list[list[TP]]:
        # TODO: Deprecate this method.
        # assert num_bits < param.SIZE_OF_U * 8, f'Invalid number of bits for random bits generator: {num_bits}'

        # if num_bits < 63:
        #     upper_limit = TP(1) << num_bits
        #     return rand_mat(shape, upper_limit) % field
        
        # print(
        #     f'Info: Number of bits offset: {num_bits}.'
        #     f' This will be deprecated once random support for i>64 is added')

        # a = TypeOps.rand_bits(shape, num_bits // 2, field)
        # b = TypeOps.rand_bits(shape, num_bits // 2, field)

        # return a * b
        raise NotImplementedError()
    
    def rand_bits_vec[TP](length: int, num_bits: int, field: TP) -> list[TP]:
        rand_mat_bits = TypeOps.rand_bits([1, length], num_bits, field)
        return rand_mat_bits[0]
    
    def num_to_bits[TP](a: list[TP], bitlen: int) -> list[list[TP]]:
        b = list[list[TP]](len(a))
    
        for i in range(len(a)):
            row = list[TP](bitlen)
            for j in range(bitlen):
                row.append(TP((a[i] & (1 << (bitlen - 1 - j))) != 0))
            b.append(row)
        
        return b
    
    def __fp_to_double_elem[TP](a: TP, k: int, f: int, field: TP = param.BASE_P) -> float:
        return TypeOps.__fp_to_double_mat[TP]([[a]], k, f, field)[0][0]

    def __fp_to_double_vec[TP](a: list[TP], k: int, f: int, field: TP = param.BASE_P) -> list[float]:
        return TypeOps.__fp_to_double_mat[TP]([a], k, f, field)[0]

    def __fp_to_double_mat[TP](a: list[list[TP]], k: int, f: int, field: TP = param.BASE_P) -> list[list[float]]:
        rows, cols = a.shape()
        twokm1: int = 1 << (k - 1)

        sn: list[list[float]] = [[(-1.0 if a[i][j] > twokm1 else 1.0) for j in range(cols)] for i in range(rows)]
        x: list[list[TP]] = [[(field - a[i][j] if a[i][j] > twokm1 else a[i][j]) for j in range(cols)] for i in range(rows)]
        x_trunc: list[list[TP]] = x & ((1 << (k - 1)) - 1)
        x_int: list[list[TP]] = x_trunc >> f
        x_float: list[list[float]] = [[float(int(e)) for e in row] for row in x_int]

        # TODO: consider better ways of doing this
        x_frac: list[list[float]] = [[0.0 for _ in range(cols)] for _ in range(rows)]
        for bi in range(f):
            x_frac = [[(x_frac[i][j] + 1 if (x_trunc[i][j] & (1 << bi)) != 0 else x_frac[i][j]) for j in range(cols)] for i in range(rows)]
            x_frac /= 2

        return (x_float + x_frac) * sn
