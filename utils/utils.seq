import random

import param


def get_address(port: int) -> str:
    return f"{param.AF_PREFIX}{port}"


def get_cache_path(pid: int, name: str) -> str:
    return f'{param.CACHE_FILE_PREFIX}_P{pid}_{name}.bin'


def get_output_path(pid: int, name: str) -> str:
    return f'{param.OUTPUT_FILE_PREFIX}_P{pid}_{name}.txt'


def get_temp_path(pid: int, name: str) -> str:
    return f'temp/temp_P{pid}_{name}.txt'

def read_vector[TP](f: File, n: int, primes_bytes: int) -> list[TP]:
    a = list[TP](n)
    for _ in range(n): a.append(TP(f.read(primes_bytes)))
    return a


def read_matrix[TP](f: File, nrows: int, ncols: int, primes_bytes: int) -> list[list[TP]]:
        a = list[list[TP]](nrows)
        for _ in range(nrows): a.append(read_vector[TP](f, ncols, primes_bytes))
        return a

def beaver_read_from_file[TP](f: File, m: int, n: int) -> tuple[list[list[TP]], list[list[TP]]]:
    raise NotImplementedError()
    return list[list[TP]](m), list[list[TP]](m)

def rand_int[TP](lower_limit: TP, upper_limit: TP) -> TP:
    return TP(random.randint(lower_limit, upper_limit))


def rand_vec[TP](length: int, base: TP) -> list[TP]:
    l = list[TP](length)
    for _ in range(length): l.append(rand_int(0, base - 1))
    return l


def rand_mat[TP](shape: list[int], base: TP) -> list[list[TP]]:
    m, n = shape
    l = list[list[TP]](m)
    for _ in range(m): l.append(rand_vec(n, base))
    return l
