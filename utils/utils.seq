import random

import param

from C import stat(cobj, cobj) -> int


def get_address(port: int) -> str:
    return f"{param.AF_PREFIX}{port}"


def get_cache_path(pid: int, name: str) -> str:
    return f'{param.CACHE_FILE_PREFIX}_P{pid}_{name}.bin'


def get_output_path(pid: int, name: str) -> str:
    return f'{param.OUTPUT_FILE_PREFIX}_P{pid}_{name}.txt'


def get_temp_path(pid: int, name: str) -> str:
    return f'temp/temp_P{pid}_{name}.txt'


# def rand_int[TP](lower_limit: TP, upper_limit: TP) -> TP:
#     # TODO: Adapt random to work with Int[*] return TP(random.randint(lower_limit, upper_limit))
#     return TP(random.randint(int(lower_limit), int(upper_limit)))


def rand_int(field) -> int:
    # return (random.randint(0, 1)) % int(field)
    # return random.randint(0, 1 << 30) % int(field)
    # return ((1 << 31) - 1) % int(field)
    # return 938395562 % int(field)
    # return random.randint(0, int(field - 1))

    # return random.randint(7, 13)
    assert int(field - 1) > 0, f'Invalid field for random generator {field}'
    return random.randint(1, int(field - 1))


def rand_vec[TP](length: int, base: TP) -> list[TP]:
    l = list[TP](length)
    for _ in range(length): l.append(TP(rand_int(base)))
    return l


def rand_mat[TP](shape: list[int], base: TP) -> list[list[TP]]:
    m, n = shape
    l = list[list[TP]](m)
    for _ in range(m): l.append(rand_vec(n, base))
    return l


def file_exists(path: str) -> bool:
    # buffer = ptr[byte]()
    # return stat(path.c_str(), buffer) == 0
    return False


def write_to_cache[TP](f: File, data: list[TP]):
    pass


def beaver_write_to_cache[TP](f: File, data: list[TP]):
    pass


def beaver_read_from_cache[TP](f: File, n: int):
    return [TP(1) for _ in range(n)], [TP(1) for _ in range(n)]


def read_vector_from_cache[TP](f: File, n: int, primes_bytes: int) -> list[TP]:
    # a = list[TP](n)
    # for _ in range(n):
    #     a.append(TP(f.read(primes_bytes)))
    # return a
    return [TP(1) for _ in range(n)]


def read_matrix_from_cache[TP](f: File, nrows: int, ncols: int, primes_bytes: int) -> list[list[TP]]:
    # a = list[list[TP]](nrows)
    # for _ in range(nrows): a.append(read_vector_from_cache[TP](f, ncols, primes_bytes))
    # return a
    return [[TP(1) for _ in range(ncols)] for _  in range(nrows)]


def cartesian(l_1: list[str], l_2: list[str]) -> list[str]:
    c = list(len(l_1) * len(l_2))
    for e_1 in l_1:
        for e_2 in l_2:
            c.append(f'{e_1} {e_2}')
            # c.append(e_1 + e_2)
    return c


def evalp[TP](x: list[TP], coefs: list[TP], exps: list[list[int]], field: TP) -> TP:
        result = TP(0)
        for coef, exp in zip(coefs, exps):
            result += x.powers(exp, field) * coef
        
        return result
