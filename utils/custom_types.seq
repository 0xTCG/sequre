# Warning: Compiler might not be able to optimize this level of abstraction.
# Consider getting rid of mul_mod and matmul_mod and using inline methods instead
from param import sockaddr_un, size_u, BASE_P
from type_ops import TypeOps


class SecureValue[TP]:
    share: TP
    x_r: TP
    r: TP
    pows: list[TP]

    def __init__(self: SecureValue[TP], other: int):
        self.share = TP(other)
        self.x_r = TP(0)
        self.r = TP(0)
        self.pows = []
    
    def __init__(self: SecureValue[TP], share: TP, x_r: TP, r: TP):
        self.share = share
        self.x_r = x_r
        self.r = r
        self.pows = []

    def __init__(self: SecureValue[TP], other: TP):
        self.share = other
        self.x_r = TP(0)
        self.r = TP(0)
        self.pows = []

    def __init__(self: SecureValue[TP], other: SecureValue[TP]):
        self.share = other.share
        self.x_r = other.x_r
        self.r = other.r
        self.pows = other.pows
    
    def __iadd__(self: SecureValue[TP], other: SecureValue[TP]) -> SecureValue[TP]:
        self.share += other.share
        if self.is_partitioned() and other.is_partitioned():
            self.x_r += other.x_r
            self.r += other.r
        else:
            self.x_r = TP(0)
            self.r = TP(0)
        self.pows = []
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P

        return self
    
    def __iadd__(self: SecureValue[TP], other: TP) -> SecureValue[TP]:
        self.share += other
        if self.is_partitioned():
            self.x_r += other
            self.r += other
        self.pows = []
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __iadd__(self: SecureValue[TP], other:int) -> SecureValue[TP]:
        self.share += other
        if self.is_partitioned():
            self.x_r += other
            self.r += other
        self.pows = []
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __add__(self: SecureValue[TP], other) -> SecureValue[TP]:
        new_number = SecureValue[TP](self)
        new_number += other
        return new_number
    
    def __imul__(self: SecureValue[TP], other: SecureValue[TP]) -> SecureValue[TP]:
        raise NotImplementedError("SecureValue[TP]s cannot be multiplied without IR pass enabled.")
    
    def __imul__(self: SecureValue[TP], other: TP) -> SecureValue[TP]:
        self.share *= other
        if self.is_partitioned():
            self.x_r *= other
            self.r *= other
        
        for i in range(1, len(self.pows)):
            self.pows[i] *= other ** i
            self.pows[i] %= BASE_P
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __imul__(self: SecureValue[TP], other:int) -> SecureValue[TP]:
        self.share *= other
        if self.is_partitioned():
            self.x_r *= other
            self.r *= other
        
        for i in range(1, len(self.pows)):
            self.pows[i] *= other ** i
            self.pows[i] %= BASE_P
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __mul__(self: SecureValue[TP], other) -> SecureValue[TP]:
        new_number = SecureValue[TP](self)
        new_number *= other
        return new_number
    
    def __ipow__(self: SecureValue[TP], other) -> SecureValue[TP]:
        raise NotImplementedError(
            "You tried to power a SecureValue[TP], which is impossible.\n"
            "If the IR pass is enabled though, SecureValue[TP] can be powered by an int. ")
    
    def __pow__(self: SecureValue[TP], other) -> SecureValue[TP]:
        new_number = SecureValue[TP](other)
        new_number **= other
        return new_number
    
    def is_partitioned(self: SecureValue[TP]) -> bool:
        return self.x_r or self.r
    
    def set_partitions(self: SecureValue[TP], partitions):
        self.x_r, self.r = partitions
    
    def get_partitions(self: SecureValue[TP]):
        return self.x_r, self.r

@extend
class sockaddr_un:
    def __str__(self: sockaddr_un, str_len: int) -> str:
        return str(self.sun_path, str_len)

@extend
class str:
    def __init__(self: str, sockaddr: sockaddr_un, str_len: int) -> str:
        return str(sockaddr.sun_path, str_len)

@extend
class float:
    def __init__(self: float, other: size_u):
        self = float(int(other))

@extend
class Int[N]:
#     def __init__(self: Int[N], other: float):
#         return Int[N](int(other))
#     def __init__(self: size_u, other: str):
#         self = size_u(int(other))
    def __new__(other: bool) -> Int[N]:
        return Int[N](int(other))
    def __eq__(self: Int[N], other: int) -> bool:
        return self == Int[N](other)
    def __ne__(self: Int[N], other: int) -> bool:
        return self != Int[N](other)
    def __gt__(self: Int[N], other: int) -> bool:
        return self > Int[N](other)
    def __add__(self: Int[N], other: int) -> Int[N]:
        return self + Int[N](other)
    def __mul__(self: Int[N], other: int) -> Int[N]:
        return self * Int[N](other)
    def __sub__(self: Int[N], other: int) -> Int[N]:
        return self - Int[N](other)
    def __truediv__(self: Int[N], other: int) -> Int[N]:
        return self / Int[N](other)
    def __floordiv__(self: Int[N], other: int) -> Int[N]:
        return self // Int[N](other)
    @llvm
    def __mod__(self: Int[N], other: Int[N]) -> Int[N]:
        #TODO: Temp and inefficient solution. Fix it.
        %0 = srem i{=N} %self, %other
        %1 = icmp slt i{=N} %0, 0
        %2 = add i{=N} %0, %other
        %3 = select i1 %1, i{=N} %2, i{=N} %0
        ret i{=N} %3
    def __or__(self: Int[N], other: int) -> Int[N]:
        return self | Int[N](other)
    def __pow__(self: Int[N], other: Int[N]) -> Int[N]:
        number = Int[N](1)
        value = self
        while other:
            if other & 1:
                number = number * value
            other >>= 1
            value = value * value
        return number
    def __pow__(self: Int[N], other: int) -> Int[N]:
        return self ** Int[N](other)
    def __and__(self: Int[N], other: int) -> Int[N]:
        return self & Int[N](other)
    def __lshift__(self: Int[N], other: int) -> Int[N]:
        return self << Int[N](other)
    def __rshift__(self: Int[N], other: int) -> Int[N]:
        return self >> Int[N](other)
    def to_bytes(self: Int[N]):
        for _ in range(1): yield self

@extend
class list[T]:
    def __getitem__(self: list[T], s: tuple[slice, slice]) -> list[T]:
        rs, cs = s
        sliced_arr = self[rs]
        new_arr = list[T](len(sliced_arr))
        for i in range(len(sliced_arr)): new_arr.append(sliced_arr[i][cs])
        return new_arr

    # def __getitem__(self: list[T], s: tuple[lslice, int]) -> list[T]:
    #     rs, cs = s
    #     sliced_arr = self[rs]
    #     new_arr = list[T](len(sliced_arr))
    #     for i in range(len(sliced_arr)): new_arr.append([sliced_arr[i][cs]])
    #     return new_arr

    def __setitem__(self: list[T], s: tuple[slice, slice], other: generator[T]):
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(len(self))
        for i in range(start, stop):
            self[i][cs] = next(other)

    def __setitem__(self: list[T], s: tuple[slice, slice], other: size_u):
        rs, cs = s
        start_row, stop_row, _, _ = rs.adjust_indices(len(self))
        start_col, stop_col, _, _ = cs.adjust_indices(len(self[0]))
        for i in range(start_row, stop_row):
            for j in range(start_col, stop_col):
                self[i][j] = other

    def __neg__(self: list[T]) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(-s)
        return l

    def __iadd__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] += o
        return self

    def __add__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s + o)
        return l
    
    def __iadd__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l
    
    def __iadd__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __iadd__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __isub__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] -= o
        return self

    def __sub__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s - o)
        return l

    def __isub__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __imul__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l

    def __imul__(self: list[T], other: list[int]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[int]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __imul__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __itruediv__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l
    
    def __itruediv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l
    
    def __ifloordiv__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l
    
    def __ifloordiv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l

    def __imod__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] %= scalar
        return self

    def __mod__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s % scalar)
        return l

    def __ipow__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __ipow__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __iand__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l
    
    def __iand__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l

    def __ilshift__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l

    def __irshift__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __ilshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l
    
    def __irshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __lt__(self: list[T], other: list[T]) -> bool:
        for s, o in zip(self, other):
            if s < o: continue
            else: return False

        return True

    def __gt__(self: list[T], other: list[T]) -> bool:
        for s, o in zip(self, other):
            if s > o: continue
            else: return False

        return True

    def __ge__(self: list[T], other: list[T]) -> bool:
        for s, o in zip(self, other):
            if s >= o: continue
            else: return False

        return True

    def __le__(self: list[T], other: list[T]) -> bool:
        for s, o in zip(self, other):
            if s <= o: continue
            else: return False

        return True

    def powers(self: list[T], other, field: size_u) -> size_u:
        result = size_u(1)
        for s, o in zip(self, other):
            result *= TypeOps.mod_pow(s, size_u(o), field)
            result %= field
        return result

    def mult(self: list[T], other: list[T], field: size_u) -> list[T]:
        # Performance warning: Modular overhead. Inefficient method.
        self_shape = self.shape()
        other_shape = other.shape()

        # TODO: Remove this assertion
        assert self_shape[1] == other_shape[0]

        new_mat = list[T](self_shape[0])

        for i in range(self_shape[0]):
            new_row = list[size_u](other_shape[1])
            for j in range(other_shape[1]):
                cell_value: size_u = size_u(0)
                for k in range(self_shape[1]):
                    cell_value += (self[i][k] * other[k][j]) % field
                    cell_value %= field
                new_row.append(cell_value)
            new_mat.append(new_row)

        return new_mat

    def shape(self: list[T]) -> list[int]:
        return [len(self), len(self[0])]

    def transpose(self: list[T]) -> list[T]:
        rows, cols = self.shape()
        new_mat = list[T](cols)

        for i in range(cols):
            row = list[size_u](rows)
            for j in range(rows):
                row.append(self[j][i])
            new_mat.append(row)

        return new_mat

    def reshape(self: list[T], shape: tuple[int, int]) -> list[T]:
        rows, cols = shape
        _, old_cols = self.shape()
        new_mat = list[T](rows)
        position: int = 0

        for i in range(rows):
            row = list[size_u](cols)
            for j in range(cols):
                old_i = position // old_cols
                old_j = position % old_cols
                row.append(self[old_i][old_j])
                position += 1
            new_mat.append(row)

        return new_mat

    def to_bytes(self: list[T]):
        for v in self:
            for b in v.to_bytes():
                yield b

    def pad_vec(self: list[T], length: int) -> list[T]:
        new_vec = list[T](length)
        for _ in range(length): new_vec.append(size_u(0))
        for i in range(min(len(self), length)): new_vec[i] = self[i]

        return new_vec


    def pad(self: list[T], rows: int, cols: int) -> list[T]:
        new_mat = list[T](rows)

        for _ in range(rows):
            row = list[size_u](cols)
            for _ in range(cols): row.append(size_u(0))
            new_mat.append(row)

        m, n = self.shape()

        for i in range(min(m, rows)):
            for j in range(min(n, cols)):
                new_mat[i][j] = self[i][j]

        return new_mat
