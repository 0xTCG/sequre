# Warning: Compiler might not be able to optimize this level of abstraction.
# Consider getting rid of mul_mod and matmul_mod and using inline methods instead
from param import sockaddr_un, size_u, BASE_LEN


extend sockaddr_un:
    def __str__(self: sockaddr_un, str_len: int) -> str:
        return str(self.sun_path, str_len)

extend str:
    def __init__(self: str, sockaddr: sockaddr_un, str_len: int) -> str:
        return str(sockaddr.sun_path, str_len)

extend size_u:
    def ndim(self: size_u) -> int:
        return 0
    
    def to_bytes(self: size_u) -> str:
        base = '0' * BASE_LEN
        str_val: str = str(self)
        for _ in range(1): yield (base + str_val)[len(str_val):]    

extend list[T]:
    def __getitem__(self: list[T], s: tuple[slice, slice]):
        rs, cs = s
        sliced_arr = self[rs]
        for i in range(len(sliced_arr)): sliced_arr[i] = sliced_arr[i][cs]
        return sliced_arr
    
    def __setitem__(self: list[T], s: tuple[slice, slice], other: generator[T]):
        rs, cs = s
        start, stop, _, _ = slice.adjust_indices(len(self), start=rs.start, stop=rs.end)
        for i in range(start, stop):
            self[i][cs] = next(other)
    
    def __setitem__(self: list[T], s: tuple[slice, slice], other: size_u):
        rs, cs = s
        start_row, stop_row, _, _ = slice.adjust_indices(len(self), start=rs.start, stop=rs.end)
        start_col, stop_col, _, _ = slice.adjust_indices(len(self[0]), start=cs.start, stop=cs.end)
        for i in range(start_row, stop_row):
            for j in range(start_col, stop_col):
                self[i][j] = other
    
    def __iadd__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] += o
        return self

    def __add__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s + o)
        return l
    
    def __isub__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] -= o
        return self

    def __sub__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s - o)
        return l
    
    def __imul__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __imod__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] %= scalar
        return self

    def __mod__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s % scalar)
        return l
    
    def __ipow__(self: list[T], scalar: size_u) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: size_u) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def mult(self: list[T], other: list[T]) -> list[T]:
        self_shape = self.shape()
        other_shape = other.shape()
        assert self_shape[1] == other_shape[0]

        new_mat = list[T](self_shape[0])

        for i in range(self_shape[0]):
            new_row = list[size_u](other_shape[1])
            for j in range(other_shape[1]):
                cell_value: size_u = size_u(0)
                for k in range(self_shape[1]):
                    cell_value += self[i][k] * other[k][j]
                new_row.append(cell_value)
            new_mat.append(new_row)
        
        return new_mat    
    
    def shape(self: list[T]) -> list[int]:
        return [len(self), len(self[0])]

    def to_bytes(self: list[T]) -> str:
        for v in self: 
            for b in v.to_bytes():
                yield b


# import random

# from functools import partial, reduce
# from copy import deepcopy

# import numpy as np

# from utils.param import BASE_P, BASE_LEN


# # Numpy overrides
# zeros = partial(np.zeros, dtype=np.int64)
# ones = partial(np.ones, dtype=np.int64)


# # Temp modular arithmetic wrappers (add_mod, mul_mod and matmul_mod)
# def add_mod(x: np.ndarray, y: np.ndarray, field: int) -> np.ndarray:
#     return np.mod(x - (-y + field), field)


# def mul_mod(x: np.ndarray, y: np.ndarray, field: int) -> np.ndarray: 
#     res: np.ndarray = zeros(shape=x.shape)
#     broadcast_y: np.ndarray = zeros(shape=x.shape)
#     broadcast_y[:] = np.broadcast_to(y, x.shape)
    
#     x = np.mod(x, field)
#     while np.any(broadcast_y > 0): 
#         indices = np.where((broadcast_y & 1) == 1)
#         res[indices] = add_mod(res[indices], x[indices], field)
  
#         x = add_mod(x, x, field)
#         broadcast_y >>= 1
  
#     return np.mod(res, field)


# def matmul_mod(x: np.ndarray, y: np.ndarray, field: int) -> np.ndarray:
#     assert x.shape[1] == y.shape[0]

#     new_mat = zeros((x.shape[0], y.shape[1]))

#     for i in range(x.shape[0]):
#         for j in range(y.shape[1]):
#             new_mat[i][j] = reduce(
#                 partial(add_mod, field=field), mul_mod(x[i], y.T[j], field), np.array(0, dtype=np.int64))
    
#     return new_mat
