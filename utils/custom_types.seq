# Warning: Compiler might not be able to optimize this level of abstraction.
# Consider getting rid of mul_mod and matmul_mod and using inline methods instead
import math

from param import sockaddr_un, int_t, BASE_P
from type_ops import TypeOps
from utils import zeros, __rand_int, __rand_vec, __rand_mat


class SecureValue[TP]:
    share: TP
    x_r: TP
    r: TP
    sqrt: TP
    sqrt_inv: TP
    pows: list[TP]
    fp: bool
    public: bool
    diagonal: bool

    def __init__(self: SecureValue[TP], other: int):
        self.share = TP(other)
        self.x_r = TP(0)
        self.r = TP(0)
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        self.pows = []
        self.fp = False
        self.public = False
        self.diagonal = False
    
    def __init__(self: SecureValue[TP], share: TP, x_r: TP, r: TP):
        self.share = share
        self.x_r = x_r
        self.r = r
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        self.pows = []
        self.fp = False
        self.public = False
        self.diagonal = False
    
    def __init__(self: SecureValue[TP],
                 share: TP, x_r: TP, r: TP,
                 sqrt: TP, sqrt_inv: TP,
                 pows: list[TP], fp: bool,
                 public: bool, diagonal: bool):
        self.share = share
        self.x_r = x_r
        self.r = r
        self.sqrt = sqrt
        self.sqrt_inv = sqrt_inv
        self.pows = pows
        self.fp = fp
        self.public = public
        self.diagonal = diagonal

    def __init__(self: SecureValue[TP], other: TP):
        self.share = other
        self.x_r = TP(0)
        self.r = TP(0)
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        self.pows = []
        self.fp = False
        self.public = False
        self.diagonal = False

    def __init__(self: SecureValue[TP], other: SecureValue[TP]):
        self.share = other.share.copy()
        self.x_r = other.x_r.copy()
        self.r = other.r.copy()
        self.sqrt = other.sqrt.copy()
        self.sqrt_inv = other.sqrt_inv.copy()
        self.pows = other.pows.copy()
        self.fp = other.fp
        self.public = other.public
        self.diagonal = other.diagonal
    
    def __iter__(self: SecureValue[TP]):
        for i in range(len(self)): yield self[i]
    
    def __getitem__(self: SecureValue[TP], index):
        item_share = self.share[index]
        return SecureValue[typeof(item_share)](
            item_share,
            self.x_r[index] if self.x_r else typeof(item_share)(0),
            self.r[index] if self.r else typeof(item_share)(0),
            self.sqrt[index] if self.sqrt else typeof(item_share)(0),
            self.sqrt_inv[index] if self.sqrt_inv else typeof(item_share)(0),
            [p[index] for p in self.pows],
            self.fp,
            self.public,
            False)
    
    def __setitem__(self: SecureValue[TP], index, other):
        assert self.public == other.public
        if isinstance(index, tuple[int, int]):
            ri, ci = index
            self.diagonal = self.diagonal and (ri == ci)
        else:
            self.diagonal = False
        self.fp = other.fp
        
        self.share[index] = other.share
        if not other.x_r: self.x_r = TP(0)
        elif self.x_r: self.x_r[index] = other.x_r
        
        if not other.r: self.r = TP(0)
        elif self.r:self.r[index] = other.r

        if not other.sqrt: self.sqrt = TP(0)
        elif self.sqrt: self.sqrt[index] = other.sqrt
        
        if not other.sqrt_inv: self.sqrt_inv = TP(0)
        elif self.sqrt_inv: self.sqrt_inv[index] = other.sqrt_inv
        
        if not other.pows: self.pows = list[TP](0)
        elif self.pows:
            for i in range(min(len(self.pows), len(other.pows))):
                self.pows[i][index] = other.pows[i]
    
    def __bool__(self: SecureValue[TP]) -> bool:
        return bool(self.share)
    
    def __int__(self: SecureValue[TP]) -> int:
        return int(self.share)
    
    def __neg__(self: SecureValue[TP]) -> SecureValue[TP]:
        return SecureValue[TP](
            share = -self.share,
            x_r = -self.x_r,
            r = -self.r,
            sqrt = -self.sqrt,
            sqrt_inv = -self.sqrt_inv,
            pows = -self.pows,
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)

    def __iadd__(self: SecureValue[TP], other: SecureValue[TP]) -> SecureValue[TP]:
        if isinstance(TP, list[list[int_t]]):
            if other.diagonal:
                for i in range(len(self)):
                    self.share[i][i] += other.share[i][i]
            else: self.share += other.share
        else: self.share += other.share
        
        if self.x_r and other.x_r:
            if isinstance(TP, list[list[int_t]]):
                if other.diagonal:
                    for i in range(len(self)):
                        self.x_r[i][i] += other.x_r[i][i]
                else: self.x_r += other.x_r
            else: self.x_r += other.x_r
        else: self.x_r = TP(0)
        
        if self.r and other.r:
            if isinstance(TP, list[list[int_t]]):
                if other.diagonal:
                    for i in range(len(self)):
                        self.r[i][i] += other.r[i][i]
                else: self.r += other.r
            else: self.r += other.r
        else: self.r = TP(0)
        
        self.pows = []
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P

        return self
    
    def __iadd__(self: SecureValue[TP], other: TP) -> SecureValue[TP]:
        self.share += other
        if self.is_partitioned():
            self.x_r += other
            self.r += other
        self.pows = []
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __iadd__(self: SecureValue[TP], other: int) -> SecureValue[TP]:
        raise NotImplementedError("SecureValue[TP]s cannot be publicly added to without IR pass enabled.")
    
    def __add__(self: SecureValue[TP], other) -> SecureValue[TP]:
        if isinstance(other, SecureValue[TP]):
            new_number = SecureValue[TP](self if not self.diagonal else other)
            new_number += (other if not self.diagonal else self)
            return new_number
        else:
            new_number = SecureValue[TP](self)
            new_number += other
            return new_number
    
    def __isub__(self: SecureValue[TP], other: SecureValue[TP]) -> SecureValue[TP]:
        if isinstance(self, list[list[int_t]]):
            if other.diagonal:
                for i in range(len(self)):
                    self.share[i][i] -= other.share[i][i]
            else: self.share -= other.share
        else: self.share -= other.share
        
        if self.x_r and other.x_r:
            if isinstance(self, list[list[int_t]]):
                if other.diagonal:
                    for i in range(len(self)):
                        self.x_r[i][i] -= other.x_r[i][i]
                else: self.x_r -= other.x_r
            else: self.x_r -= other.x_r
        else: self.x_r = TP(0)
        
        if self.r and other.r:
            if isinstance(self, list[list[int_t]]):
                if other.diagonal:
                    for i in range(len(self)):
                        self.r[i][i] -= other.r[i][i]
                else: self.r -= other.r    
            else: self.r -= other.r
        else: self.r = TP(0)
        
        self.pows = []
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P

        return self
    
    def __isub__(self: SecureValue[TP], other: TP) -> SecureValue[TP]:
        self.share -= other
        if self.is_partitioned():
            self.x_r -= other
            self.r -= other
        self.pows = []
        self.sqrt = TP(0)
        self.sqrt_inv = TP(0)
        
        self.share %= BASE_P
        self.x_r %= BASE_P
        self.r %= BASE_P
        
        return self
    
    def __isub__(self: SecureValue[TP], other: int) -> SecureValue[TP]:
        raise NotImplementedError("SecureValue[TP]s cannot be publicly subtracted to without IR pass enabled.")
    
    def __sub__(self: SecureValue[TP], other) -> SecureValue[TP]:
        if isinstance(other, SecureValue[TP]):
            new_number = SecureValue[TP](self if not self.diagonal else other)
            new_number -= other if not self.diagonal else self
            return new_number
        else:
            new_number = SecureValue[TP](self)
            new_number -= other
            return new_number        
    
    def __imul__(self: SecureValue[TP], other) -> SecureValue[TP]:        
        if isinstance(other, SecureValue):
            raise NotImplementedError("SecureValue[TP]s cannot be multiplied without IR pass enabled.")
        else:
            self.share *= other
            if self.is_partitioned():
                self.x_r *= other
                self.r *= other
            
            for i in range(1, len(self.pows)):
                self.pows[i] *= other ** i
                self.pows[i] %= BASE_P
            
            self.share %= BASE_P
            self.x_r %= BASE_P
            self.r %= BASE_P

            # TODO: Fix sqrt
            # other_sqrt = math.sqrt(other)
            # self.sqrt *= other_sqrt
            # self.sqrt_inv /= other_sqrt
            
            return self
    
    def __mul__(self: SecureValue[TP], other) -> SecureValue[TP]:
        new_number = SecureValue[TP](self)
        new_number *= other
        return new_number
    
    def __truediv__(self: SecureValue[TP], other) -> SecureValue[TP]:
        raise NotImplementedError("SecureValue[TP]s cannot be divided without IR pass enabled.")
    
    def __ipow__(self: SecureValue[TP], other) -> SecureValue[TP]:
        raise NotImplementedError(
            "You tried to power a SecureValue[TP], which is impossible.\n"
            "If the IR pass is enabled though, SecureValue[TP] can be powered by an int.")
    
    def __pow__(self: SecureValue[TP], other) -> SecureValue[TP]:
        new_number = SecureValue[TP](other)
        new_number **= other
        return new_number
    
    def __gt__(self: SecureValue[TP], other) -> SecureValue[TP]:
        raise NotImplementedError(
            "SecureValue[TP]s cannot be compared without IR pass enabled")
    
    def __lt__(self: SecureValue[TP], other) -> SecureValue[TP]:
        raise NotImplementedError(
            "SecureValue[TP]s cannot be compared without IR pass enabled")
    
    def __len__(self: SecureValue[TP]) -> int:
        return len(self.share)
    
    def diag(self: SecureValue[TP], other: SecureValue[int_t]) -> SecureValue[TP]:
        diagonal_sv = self.zeros()

        for i in range(len(diagonal_sv)):
            diagonal_sv[i, i] = other
        
        diagonal_sv.fp = other.fp
        diagonal_sv.public = other.public
        diagonal_sv.diagonal = True

        return diagonal_sv

    @property
    def I(self: SecureValue[TP]) -> SecureValue[TP]:
        identity = self.share.get_identity()
        if self.fp:
            one = TypeOps.double_to_fp(1.0)
            for i in range(len(identity)):
                identity[i][i] = one
        
        sv = SecureValue[TP](identity)
        sv.fp = self.fp
        sv.public = True
        sv.diagonal = True

        return sv
    
    @property
    def T(self: SecureValue[TP]) -> SecureValue[TP]:
        # TODO: Consider storing T within self after fist calculation.
        pows = [p.transpose() for p in self.pows]
        
        return SecureValue[TP](
            share = self.share.transpose(),
            x_r = self.x_r.transpose() if self.x_r else self.x_r,
            r = self.r.transpose() if self.r else self.r,
            sqrt = self.sqrt.transpose() if self.sqrt else self.sqrt,
            sqrt_inv = self.sqrt_inv.transpose() if self.sqrt_inv else self.sqrt_inv,
            pows = pows,
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)

    def is_partitioned(self: SecureValue[TP]) -> bool:
        return bool(self.r)
    
    def set_partitions(self: SecureValue[TP], partitions):
        self.x_r, self.r = partitions
    
    def get_partitions(self: SecureValue[TP]):
        return self.x_r, self.r
    
    def is_fp(self):
        return self.fp
    
    def is_public(self):
        return self.public
    
    def copy(self):
        share = self.share.copy()
        x_r = self.x_r.copy()
        r = self.r.copy()
        sqrt = self.sqrt.copy()
        sqrt_inv = self.sqrt_inv.copy()
        pows = self.pows.copy()
        fp = self.fp
        public = self.public
        diagonal = self.diagonal
        
        return SecureValue[TP](
            share, x_r, r, sqrt, sqrt_inv,
            pows, fp, public, diagonal)
    
    def expand_dims(self):
        pows = [[p] for p in self.pows]
        
        return SecureValue[list[TP]](
            share = [self.share],
            x_r = [self.x_r] if self.x_r else list[TP](),
            r = [self.r] if self.r else list[TP](),
            sqrt = [self.sqrt] if self.sqrt else list[TP](),
            sqrt_inv = [self.sqrt_inv] if self.sqrt_inv else list[TP](),
            pows = pows,
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)
    
    def zeros(self):
        return SecureValue[TP](
            share = self.share.zeros(),
            x_r = self.share.zeros(),
            r = self.share.zeros(),
            sqrt = self.share.zeros(),
            sqrt_inv = self.share.zeros(),
            pows = list[TP](),
            fp = self.fp,
            public = self.public,
            diagonal = True)

    def zeros(rows: int, cols: int) -> SecureValue[list[list[int_t]]]:
        return SecureValue[list[list[int_t]]](
            share = zeros[int_t](rows, cols),
            x_r = zeros[int_t](rows, cols),
            r = zeros[int_t](rows, cols),
            sqrt = zeros[int_t](rows, cols),
            sqrt_inv = zeros[int_t](rows, cols),
            pows = list[list[list[int_t]]](),
            fp = False,
            public = False,
            diagonal = True)

    def ones(self):
        return SecureValue[TP](
            share = self.share.ones(),
            x_r = self.share.ones(),
            r = self.share.ones(),
            sqrt = self.share.ones(),
            sqrt_inv = self.share.ones(),
            pows = list[TP](),
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)
    
    def raw_zeros(self):
        return self.share.zeros()

    def raw_ones(self):
        return self.share.ones()
    
    def shape(self) -> list[int]:
        return self.share.shape()
    
    def extend(self, other):
        share = self.share.__copy__()
        x_r = self.x_r.__copy__()
        r = self.r.__copy__()
        sqrt = self.sqrt.__copy__()
        sqrt_inv = self.sqrt_inv.__copy__()
        pows = [p.__copy__() for p in self.pows]
        fp = self.fp
        public = self.public
        diagonal = False

        share.extend(other.share)
        if x_r: x_r.extend(other.x_r)
        if r: r.extend(other.r)
        for i in range(len(pows)): pows[i].extend(other.pows[i])
        if sqrt: sqrt.extend(other.sqrt)
        if sqrt_inv: sqrt_inv.extend(other.sqrt_inv)

        return SecureValue[TP](
            share, x_r, r, sqrt, sqrt_inv,
            pows, fp, public, diagonal)
    
    def pad(self, rows: int, cols: int):
        pows = [p.pad(rows, cols) for p in self.pows]
        
        return SecureValue[TP](
            self.share.pad(rows, cols),
            self.x_r.pad(rows, cols),
            self.r.pad(rows, cols),
            self.sqrt.pad(rows, cols),
            self.sqrt_inv.pad(rows, cols),
            pows, self.fp, self.public,
            self.diagonal and rows == cols)

    def pad_right(self, size: int):
        assert isinstance(TP, list[int_t]), 'Cannot pad anything other than vector'
        extension = [int_t(0) for _ in range(size)]
        
        share = self.share.__copy__()
        x_r = self.x_r.__copy__()
        r = self.r.__copy__()
        sqrt = self.sqrt.__copy__()
        sqrt_inv = self.sqrt_inv.__copy__()
        pows = [p.__copy__() for p in self.pows]
        fp = self.fp
        public = self.public
        diagonal = False

        share.extend(extension)
        if x_r: x_r.extend(extension)
        if r: r.extend(extension)
        for i in range(len(pows)): pows[i].extend(extension)
        if sqrt: sqrt.extend(extension)
        if sqrt_inv: sqrt_inv.extend(extension)

        return SecureValue[TP](
            share, x_r, r, sqrt, sqrt_inv,
            pows, fp, public, diagonal)
    
    def pad_left(self, size: int):
        assert isinstance(TP, list[int_t]), 'Cannot pad anything other than vector'
        extension = [int_t(0) for _ in range(size)]
        
        share = extension.__copy__()
        x_r = extension.__copy__() if self.x_r else self.x_r
        r = extension.__copy__() if self.r else self.r
        sqrt = extension.__copy__() if self.sqrt else self.sqrt
        sqrt_inv = extension.__copy__() if self.sqrt_inv else self.sqrt_inv
        pows = [extension.__copy__() for _ in range(len(self.pows))]
        fp = self.fp
        public = self.public
        diagonal = False

        share.extend(self.share)
        if self.x_r: x_r.extend(self.x_r)
        if self.r: r.extend(self.r)
        for i in range(len(self.pows)): pows[i].extend(self.pows[i])
        if self.sqrt: sqrt.extend(self.sqrt)
        if self.sqrt_inv: sqrt_inv.extend(self.sqrt_inv)
        
        return SecureValue[TP](
            share, x_r, r, sqrt, sqrt_inv,
            pows, fp, public, diagonal)
    
    def filter(self, mask):
        mask_len = len(mask)
        pows = [[p[i] for i in range(mask_len) if mask[i]] for p in self.pows]

        return SecureValue[TP](
            share = [self.share[i] for i in range(mask_len) if mask[i]],
            x_r = [self.x_r[i] for i in range(mask_len) if mask[i]] if self.x_r else TP(),
            r = [self.r[i] for i in range(mask_len) if mask[i]] if self.r else TP(),
            sqrt = [self.sqrt[i] for i in range(mask_len) if mask[i]] if self.sqrt else TP(),
            sqrt_inv = [self.sqrt_inv[i] for i in range(mask_len) if mask[i]] if self.sqrt_inv else TP(),
            pows = pows,
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)
    
    def sum(self):
        cumsum = self[0].zeros()
        for e in self: cumsum += e
        return cumsum
    
    def to_fp(self):
        if self.fp: return self
        
        fp_one = TypeOps.double_to_fp(1.0)
        pows = [p * fp_one for p in self.pows]
        
        return SecureValue[TP](
            share = self.share * fp_one,
            x_r = self.x_r * fp_one,
            r = self.r * fp_one,
            sqrt = self.sqrt,
            sqrt_inv = self.sqrt_inv,
            pows = pows,
            fp = True,
            public = self.public,
            diagonal = self.diagonal)
    
    def trunc(self, fp):
        pows = [fp.trunc(p) for p in self.pows]
        return SecureValue[TP](
            share = fp.trunc(self.share),
            x_r = TP(0),  # TODO: #61 Resolve #61 and calculate x_r here
            r = TP(0),  # TODO: #61 Resolve #61 and calculate x_r here
            sqrt = fp.trunc(self.sqrt) if self.sqrt else self.sqrt,
            sqrt_inv = fp.trunc(self.sqrt_inv) if self.sqrt_inv else self.sqrt_inv,
            pows = pows,
            fp = self.fp,
            public = self.public,
            diagonal = self.diagonal)
    
    def beaver_reveal(self, mpc):
        revealed_float = self.share.zeros_float()
        if mpc.pid:
            revealed_float = mpc.comms.print_fp((self.x_r if mpc.pid == 1 else self.x_r.zeros()) + self.r)
        
        return revealed_float
    
    def validate_partitions(self, mpc, message = ""):
        if mpc.pid:
            partition_share = (self.x_r if mpc.pid == 1 else self.x_r.zeros()) + self.r
            partition_reveal = mpc.comms.reveal(partition_share)
            share_reveal = mpc.comms.reveal(self.share)
            assert partition_reveal == share_reveal, f"{message}:\n\tPartition reveal: {partition_reveal}\n\tShare reveal: {share_reveal}"

@extend
class sockaddr_un:
    def __str__(self: sockaddr_un, str_len: int) -> str:
        return str(self.sun_path, str_len)


@extend
class str:
    def __init__(self: str, sockaddr: sockaddr_un, str_len: int) -> str:
        return str(sockaddr.sun_path, str_len)


@extend
class float:
    def __init__(self: float, other: int_t):
        self = float(int(other))
    
    def __add__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return other + self
    
    def __sub__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return -other + self
    
    def __mul__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return other * self
    
    def to_fp(self) -> int_t:
        return TypeOps.double_to_fp(self)


@extend
class int:
    def __add__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return other + self
    
    def __sub__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return -other + self
    
    def __mul__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        return other * self
    
    def __truediv__[TP](self, other: SecureValue[TP]) -> SecureValue[TP]:
        raise NotImplementedError("Cannot divide by secure value without IR passes enabled.")
    
    def to_fp(self) -> int_t:
        return TypeOps.int_to_fp(self)


@extend
class Int[N]:
    def __new__(other: bool) -> Int[N]:
        return Int[N](int(other))
    def __eq__(self: Int[N], other: int) -> bool:
        return self == Int[N](other)
    def __ne__(self: Int[N], other: int) -> bool:
        return self != Int[N](other)
    def __gt__(self: Int[N], other: int) -> bool:
        return self > Int[N](other)
    def __add__(self: Int[N], other: int) -> Int[N]:
        return self + Int[N](other)
    def __mul__(self: Int[N], other: int) -> Int[N]:
        return self * Int[N](other)
    def __sub__(self: Int[N], other: int) -> Int[N]:
        return self - Int[N](other)
    def __truediv__(self: Int[N], other: int) -> Int[N]:
        return self / Int[N](other)
    def __floordiv__(self: Int[N], other: int) -> Int[N]:
        return self // Int[N](other)
    @llvm
    def __mod__(self: Int[N], other: Int[N]) -> Int[N]:
        #TODO: Temp and inefficient solution. Fix it.
        %0 = srem i{=N} %self, %other
        %1 = icmp slt i{=N} %0, 0
        %2 = add i{=N} %0, %other
        %3 = select i1 %1, i{=N} %2, i{=N} %0
        ret i{=N} %3
    def __or__(self: Int[N], other: int) -> Int[N]:
        return self | Int[N](other)
    def __pow__(self: Int[N], other: Int[N]) -> Int[N]:
        number = Int[N](1)
        value = self
        while other:
            if other & 1:
                number = number * value
            other >>= 1
            value = value * value
        return number
    def __pow__(self: Int[N], other: int) -> Int[N]:
        return self ** Int[N](other)
    def __and__(self: Int[N], other: int) -> Int[N]:
        return self & Int[N](other)
    def __lshift__(self: Int[N], other: int) -> Int[N]:
        return self << Int[N](other)
    def __rshift__(self: Int[N], other: int) -> Int[N]:
        return self >> Int[N](other)
    def to_bytes(self: Int[N]):
        for _ in range(1): yield self
    def elem_count(self: Int[N]) -> int:
        return 1
    def rand(self: Int[N], base) -> Int[N]:
        # TODO: Adapt random to work with Int[*] return TP(random.randint(1, base - 1))
        return typeof(base)(__rand_int(base))
    def zeros(self: Int[N]) -> Int[N]:
        return Int[N](0)
    def zeros_float(self: Int[N]) -> float:
        return 0.0
    def ones(self: Int[N]) -> Int[N]:
        return Int[N](1)
    def copy(self: Int[N]) -> Int[N]:
        return Int[N](self)
    def shape(self: Int[N]) -> list[int]:
        return []
    def has_zero(self: Int[N]) -> bool:
        return self == Int[N](0)


@extend
class list[T]:
    def __getitem__(self: list[T], s: tuple[slice, slice]) -> list[T]:
        rs, cs = s
        sliced_arr = self[rs]
        new_arr = list[T](len(sliced_arr))
        for i in range(len(sliced_arr)): new_arr.append(sliced_arr[i][cs])
        return new_arr
    
    def __setitem__(self: list[T], s: tuple[slice, slice], other: generator[T]):
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(len(self))
        for i in range(start, stop):
            self[i][cs] = next(other)

    def __getitem__(self: list[list[int_t]], s: tuple[slice, int]) -> list[int_t]:
        rs, cs = s
        sliced_arr = self[rs]
        new_arr = list[int_t](len(sliced_arr))
        for i in range(len(sliced_arr)): new_arr.append(sliced_arr[i][cs])
        return new_arr

    def __setitem__(self: list[list[int_t]], s: tuple[slice, int], other: generator[int_t]):
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(len(self))
        for i in range(start, stop):
            self[i][cs] = next(other)
    
    def __getitem__(self: list[list[int_t]], s: tuple[int, slice]) -> list[int_t]:
        ri, cs = s
        return self[ri][cs]

    def __setitem__(self: list[list[int_t]], s: tuple[int, slice], other: generator[int_t]):
        ri, cs = s
        start, stop, _, _ = cs.adjust_indices(len(self))
        for j in range(start, stop):
            self[ri][j] = next(other)
    
    def __getitem__(self: list[list[int_t]], s: tuple[int, int]) -> int_t:
        i, j = s
        return self[i][j]

    def __setitem__(self: list[list[int_t]], s: tuple[int, int], other: int_t):
        i, j = s
        self[i][j] = other

    def __setitem__(self: list[T], s: tuple[slice, slice], other: int_t):
        rs, cs = s
        start_row, stop_row, _, _ = rs.adjust_indices(len(self))
        start_col, stop_col, _, _ = cs.adjust_indices(len(self[0]))
        for i in range(start_row, stop_row):
            for j in range(start_col, stop_col):
                self[i][j] = other

    def __neg__(self: list[T]) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(-s)
        return l

    def __iadd__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] += o
        return self

    def __add__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s + o)
        return l
    
    def __iadd__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l
    
    def __iadd__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __iadd__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __isub__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] -= o
        return self

    def __sub__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s - o)
        return l

    def __isub__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __imul__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], other: list[list[T]]) -> list[T]:
        self = [self].mult(other, BASE_P)[0]
        return self

    def __mul__(self: list[T], other: list[list[T]]) -> list[T]:
        return [self].mult(other, BASE_P)[0]
    
    def __imul__(self: list[T], other: T) -> list[T]:
        for i in range(len(self)):
            self[i] *= other
        return self

    def __mul__(self: list[T], other: T) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * other)
        return l

    def __imul__(self: list[T], other: list[int]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[int]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __imul__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __itruediv__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l
    
    def __itruediv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l
    
    def __ifloordiv__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l
    
    def __ifloordiv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l

    def __imod__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] %= scalar
        return self

    def __mod__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s % scalar)
        return l

    def __ipow__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __ipow__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __iand__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l
    
    def __iand__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l

    def __ilshift__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l

    def __irshift__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __ilshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l
    
    def __irshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __lt__(self: list[T], other: list[T]) -> bool:
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s < o: continue
            else: return False

        return True

    def __gt__(self: list[T], other: list[T]) -> bool:
        assert len(self) == len(other), 'Comparing lists of different sizes'
        
        for s, o in zip(self, other):
            if s > o: continue
            else: return False

        return True

    def __ge__(self: list[T], other: list[T]) -> bool:
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s >= o: continue
            else: return False

        return True

    def __le__(self: list[T], other: list[T]) -> bool:
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s <= o: continue
            else: return False

        return True

    def powers(self: list[T], other, field: int_t) -> int_t:
        result = int_t(1)
        for s, o in zip(self, other):
            result *= TypeOps.mod_pow(s, int_t(o), field)
            result %= field
        return result

    def mult(self: list[T], other: list[T], field: int_t) -> list[T]:
        # Performance warning: Modular overhead. Inefficient method.
        self_shape = self.shape()
        other_shape = other.shape()

        # TODO: Remove this assertion
        assert self_shape[1] == other_shape[0], f"Not aligned shapes {self_shape} and {other_shape} for matmul"

        new_mat = list[T](self_shape[0])

        for i in range(self_shape[0]):
            new_row = list[int_t](other_shape[1])
            for j in range(other_shape[1]):
                cell_value: int_t = int_t(0)
                for k in range(self_shape[1]):
                    cell_value += (self[i][k] * other[k][j]) % field
                    cell_value %= field
                new_row.append(cell_value)
            new_mat.append(new_row)

        return new_mat

    def shape(self: list[T]):
        if isinstance(T, int) or isinstance(T, int_t):
            return [len(self)]
        
        return [len(self), len(self[0])]

    def transpose(self: list[T]) -> list[T]:
        if not self:
            return self
        
        rows, cols = self.shape()
        new_mat = list[T](cols)

        for i in range(cols):
            row = list[int_t](rows)
            for j in range(rows):
                row.append(self[j][i])
            new_mat.append(row)

        return new_mat

    def flatten(self: list[T]) -> list[int_t]:
        return [e for row in self for e in row]

    def reshape(self: list[T], shape) -> list[T]:
        rows, cols = shape
        _, old_cols = self.shape()
        new_mat = list[T](rows)
        position: int = 0

        for _ in range(rows):
            row = list[int_t](cols)
            for _ in range(cols):
                old_i = position // old_cols
                old_j = position % old_cols
                row.append(self[old_i][old_j])
                position += 1
            new_mat.append(row)

        return new_mat

    def to_bytes(self: list[T]):
        for v in self:
            for b in v.to_bytes():
                yield b
    
    def pad_vec(self: list[T], length: int) -> list[T]:
        new_vec = list[T](length)
        for _ in range(length): new_vec.append(int_t(0))
        for i in range(min(len(self), length)): new_vec[i] = self[i]

        return new_vec

    def pad(self: list[T], rows: int, cols: int) -> list[T]:
        new_mat = list[T](rows)

        for _ in range(rows):
            row = list[int_t](cols)
            for _ in range(cols): row.append(int_t(0))
            new_mat.append(row)

        m, n = self.shape()

        for i in range(min(m, rows)):
            for j in range(min(n, cols)):
                new_mat[i][j] = self[i][j]

        return new_mat
    
    def elem_count(self: list[T]) -> int:
        if isinstance(T, list[int_t]):
            return len(self) * len(self[0])
        
        return len(self)
    
    def rand(self: list[T], base):
        if isinstance(self, list[list]):
            return __rand_mat(self.shape(), base)
        else:
            return __rand_vec(len(self), base)
        
        
        raise TypeError(f'Invalid type for {self}')
    
    def get_identity(self: list[T]) -> list[T]:
        identity = self.zeros()
        for i in range(len(self)):
            identity[i][i] = int_t(1)
        return identity
    
    def zeros(self: list[T]) -> list[T]:
        if isinstance(self, list[int_t]):
            return [int_t(0) for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]):
            return [[int_t(0) for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type for {self}')
    
    def zeros_float(self: list[T]):
        if isinstance(self, list[int_t]):
            return [0.0 for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]):
            return [[0.0 for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type for {self}')
    
    def ones(self: list[T]) -> list[T]:
        if isinstance(self, list[int_t]):
            return [int_t(1) for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]):
            return [[int_t(1) for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type for {self}')
    
    def copy(self: list[T]):
        new_list = list[T](len(self))

        for e in self:
            new_list.append(e.copy())
        
        return new_list
    
    def has_zero(self: list[T]) -> bool:
        for e in self:
            if e.has_zero(): return True
        return False
