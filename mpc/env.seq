from ..utils.param import *
from ..utils.utils import cartesian, evalp
from ..utils.type_ops import TypeOps
from ..utils.custom_types import SecureValue

from comms import MPCComms
from prg import MPCPRG
from arithmetic import MPCArithmetic
from polynomial import MPCPolynomial
from boolean import MPCBoolean
from fp import MPCFP
from lin_alg import MPCLinAlg
from optimizations import MPCOptimizations


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.prg = MPCPRG(self.pid)
        self.comms = MPCComms[TP](self.pid, self.prg)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp,
            comms=self.comms)  # TODO: Remove comms from lin_alg
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_):
        field = self.primes[0]
        x_r = list[TP](len(x_))
        r = list[TP](len(x_))

        for sn in x_:
            if not sn.is_partitioned():
                sn.set_partitions(
                    self.arithmetic.__beaver_partition(sn.share, field))
            
            x_r_, r_ = sn.get_partitions()
            x_r.append(x_r_)
            r.append(r_)

        coefs = [size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        result = self.optimizations.secure_evalp(
            x_r, r, coefs, exps, field)
        sv = SecureValue[typeof(result)](result)
        sv.fp = x_[0].is_fp()
        
        # TODO: Handle sqrts

        return sv

    def secure_add(self, x, y):
        if isinstance(x, int) and isinstance(y, int):
            return x + y
        elif isinstance(x, int):
            return self.__add_public(x.to_fp() if y.fp else size_u(x), y, False)
        elif isinstance(y, int):
            return self.__add_public(y.to_fp() if x.fp else size_u(y), x, False)
        else:
            if not x.is_public() and not y.is_public():
                return x + y
            elif x.is_public():
                return self.__add_public(x.share, y, x.diagonal)
            elif y.is_public():
                return self.__add_public(y.share, x, y.diagonal)
            
            raise TypeError("Invalid type of addends")
        
    def secure_sub(self, x, y):
        return self.secure_add(x, -y)

    def secure_mult(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.__beaver_partition(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        # TODO: Important! Don't immediatelly reconstruct here. Probably move it to the top somehow. Issue #50.
        c = self.arithmetic.__beaver_reconstruct(c, field)

        if x.is_fp() and y.is_fp():
            c = self.fp.trunc(c)
        
        sv = SecureValue[typeof(c)](c)
        sv.fp = x.is_fp() or y.is_fp()

        # TODO: Efficiently calculate beaver partitions of c here
        # Bellow is temp dirty solution for beaver partitioning which should be both:
        # - Computed with less network overhead
        # - Computed only if compiler figures out that partitions will be needed downstream
        sv.set_partitions(self.arithmetic.__beaver_partition(sv.share, field))

        # TODO: Check if there is a better way to do this
        # if x.sqrt and y.sqrt:
        #     sv.sqrt = self.arithmetic.multiply(x.sqrt, y.sqrt)
        #     sv.sqrt = self.fp.trunc(sv.sqrt)
        #     sv.sqrt_inv = self.arithmetic.multiply(x.sqrt_inv, y.sqrt_inv)
        #     sv.sqrt_inv = self.fp.trunc(sv.sqrt_inv)
        return sv
    
    def secure_mult_no_cache(self, x_, y_):
        x = x_.share
        y = y_.share

        c = self.arithmetic.multiply(x, y)

        if x_.is_fp() and x_.is_fp():
            c = self.fp.trunc(c)

        sv = SecureValue[typeof(c)](c)
        sv.fp = x_.is_fp() or y_.is_fp()

        # TODO: Efficiently calculate beaver partitions of c here
        # TODO: Check if there is a better way to do this
        # if x_.sqrt and y_.sqrt:
        #     sv.sqrt = self.arithmetic.multiply(x.sqrt, y.sqrt)
        #     sv.sqrt = self.fp.trunc(sv.sqrt)
        #     sv.sqrt_inv = self.arithmetic.multiply(x.sqrt_inv, y.sqrt_inv)
        #     sv.sqrt_inv = self.fp.trunc(sv.sqrt_inv)
        return sv

    def secure_pow(self, x_, p):
        field = self.primes[0]

        if x_.is_fp():
            # TODO: Implement efficient pows calculation for FPs
            return self.secure_pow_no_cache(x_, p)

        if p >= len(x_.pows):
            if not x_.is_partitioned():
                x_.set_partitions(self.arithmetic.__beaver_partition(x_.share, field))

            pows = self.polynomial.powers_cached(
                x_.x_r, x_.r, p, field)
            for i in range(len(x_.pows), len(pows)):
                x_.pows.append(pows[i])
        
        c = x_.pows[p]
        sv = SecureValue[typeof(c)](c)
        sv.fp = x_.is_fp()

        # TODO: Efficiently calculate beaver partitions of c here
        # TODO: Check if there is a way to calculate cached sqrts efficiently
        return sv

    def secure_pow_no_cache(self, x_, p):
        x = x_.share

        for _ in range(p - 1):
            x = self.arithmetic.multiply(x, x_.share)
            if x_.is_fp(): x = self.fp.trunc(x)
        
        sv = SecureValue[typeof(x)](x)
        sv.fp = x_.is_fp()

        # TODO: Efficiently calculate beaver partitions of c here
        # TODO: Check if there is a way to calculate cached sqrts efficiently
        return sv
    
    def secure_div(self, x, y):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(y, float):
            return x * TypeOps.mod_inv(TypeOps.double_to_fp(y), BASE_P) 
        elif isinstance(y, int) or isinstance(y, TP):
            denom = TypeOps.double_to_fp(1.0 / y) if x.is_fp() else TypeOps.mod_inv(y, BASE_P)
            # TODO: Important! Fix this via issue #52.
            # sv = x * denom
            # if x.is_fp(): sv = sv.trunc(self.fp)
            # Temp solution below. Will be removed after #52 is resolved.
            res = x.share * denom
            if x.is_fp(): res = self.fp.trunc(res)
            sv = SecureValue[typeof(x.share)](res)
            sv.fp = True
            return sv
        else:
            sv = SecureValue[typeof(x.share)](self.fp.fp_div(x.share, y.share))
            sv.fp = True
            # TODO: Efficiently calculate beaver partitions of sv here
            return sv
    
    def secure_gt(self, x, y):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(y, int) or isinstance(y, TP):
            if y == 0:
                return SecureValue[typeof(x.share)](self.boolean.is_positive(x.share))

            return SecureValue[typeof(x.share)](self.boolean.not_less_than_public(x.share, TP(y)))
        elif isinstance(y, float):
            return SecureValue[typeof(x.share)](self.boolean.not_less_than_public(x.share, TypeOps.double_to_fp(y)))
        else:
            return SecureValue[typeof(x.share)](self.boolean.not_less_than(x.share, y.share))
        
        # TODO: Efficiently calculate beaver partitions of sv here

    def secure_lt(self, x, y):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(y, int) or isinstance(y, TP):
            if y == 0:
                return SecureValue[typeof(x.share)](self.boolean.is_not_positive(x.share))
            
            return SecureValue[typeof(x.share)](self.boolean.less_than_public(x.share, TP(y)))
        elif isinstance(y, float):
            return SecureValue[typeof(x.share)](self.boolean.less_than_public(x.share, TypeOps.double_to_fp(y)))
        else:
            return SecureValue[typeof(x.share)](self.boolean.less_than(x.share, y.share))
        
        # TODO: Efficiently calculate beaver partitions of sv here
    
    def secure_sqrt_inv(self, x, y):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        field = self.primes[0]

        if not y.sqrt_inv:
            y.sqrt, y.sqrt_inv = self.fp.fp_sqrt(y.share)
        
        if isinstance(x, int):
            sv = SecureValue[typeof(y.sqrt_inv)](y.sqrt_inv)
            sv.fp = True
            # TODO: Efficiently calculate beaver partitions of c here
            # Bellow is temp dirty solution for beaver partitioning which should be both:
            # - Computed with less network overhead
            # - Computed only if compiler figures out that partitions will be needed downstream
            sv.set_partitions(self.arithmetic.__beaver_partition(sv.share, field))
            return sv * x
        else:
            if not x.is_partitioned():
                x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))

            x_1_r, r_1 = x.get_partitions()
            x_2_r, r_2 = self.arithmetic.__beaver_partition(y.sqrt_inv, field)
            
            c = self.arithmetic.__beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
            c = self.arithmetic.__beaver_reconstruct(c, field)
            c = self.fp.trunc(c)
            
            sv = SecureValue[typeof(c)](c)
            sv.fp = True
            # TODO: Efficiently calculate beaver partitions of c here
            # Bellow is temp dirty solution for beaver partitioning which should be both:
            # - Computed with less network overhead
            # - Computed only if compiler figures out that partitions will be needed downstream
            sv.set_partitions(self.arithmetic.__beaver_partition(sv.share, field))
            
            return sv
    
    def secure_sqrt_inv_no_cache(self, x, y):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        _, sqrt_inv = self.fp.fp_sqrt(y.share)
        result = self.arithmetic.multiply(x.share, sqrt_inv)
        result = self.fp.trunc(result)

        # TODO: Efficiently calculate beaver partitions of result here
        return SecureValue[typeof(result)](result)
    
    def secure_reveal(self, e):
        revealed_e = self.comms.reveal(e.share)
        
        c = revealed_e // 2
        if self.pid == 1: c += (revealed_e % TP(2))

        sv = SecureValue[typeof(c)](c, e.x_r, e.r)
        sv.fp = e.is_fp()
            
        return sv
    
    def dot(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.__beaver_partition(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_dot_prod(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.__beaver_reconstruct(c, field)

        if x.is_fp() and y.is_fp():
            c = self.fp.trunc(c)
        
        sv = SecureValue[TP](c)
        sv.fp = x.is_fp() or y.is_fp()
        # TODO: Efficiently calculate beaver partitions of sv here
        # Bellow is temp dirty solution for beaver partitioning which should be both:
        # - Computed with less network overhead
        # - Computed only if compiler figures out that partitions will be needed downstream
        # sv.set_partitions(self.arithmetic.__beaver_partition(sv.share, field))
        
        return sv
    
    def matmul(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.__beaver_partition(y.share, field))

        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_matmul(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.__beaver_reconstruct(c, field)

        if x.is_fp() and y.is_fp():
            c = self.fp.trunc(c)
        
        sv = SecureValue[typeof(c)](c)
        sv.fp = x.is_fp() or y.is_fp()

        # TODO: Efficiently calculate beaver partitions of sv here
        # Bellow is temp dirty solution for beaver partitioning which should be both:
        # - Computed with less network overhead
        # - Computed only if compiler figures out that partitions will be needed downstream
        sv.set_partitions(self.arithmetic.__beaver_partition(sv.share, field))
        
        # TODO: Check if there is a better way to do this
        # if x.sqrt and y.sqrt:
        #     sv.sqrt = self.arithmetic.multiply(x.sqrt, y.sqrt)
        #     sv.sqrt = self.fp.trunc(sv.sqrt)
        #     sv.sqrt_inv = self.arithmetic.multiply(x.sqrt_inv, y.sqrt_inv)
        #     sv.sqrt_inv = self.fp.trunc(sv.sqrt_inv)
        
        return sv
    
    def matmul(self, x, y, z):
        return self.matmul(self.matmul(x, y), z)

    def sqrt(self, x):
        # TODO: Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if not x.sqrt:
            x.sqrt, x.sqrt_inv = self.fp.fp_sqrt(x.share)
        
        sv = SecureValue[typeof(x.sqrt)](x.sqrt)
        sv.fp = True
        # TODO: Efficiently calculate beaver partitions of sv here
        return sv
    
    def sqrt_no_cache(self, x):
        sv = SecureValue[typeof(x.share)](self.fp.fp_sqrt(x.share)[0])
        sv.fp = True
        # TODO: Efficiently calculate beaver partitions of sv here
        return sv
    
    def broadcast(self, value):
        value.share = self.comms.broadcast(value.share)
        value.public = True
        return value
    
    def __add_public(self, x_public, y, diagonal):
        share = y.share
        
        if isinstance(share, list[list[TP]]):
            if diagonal:
                for i in range(len(share)):
                    share[i][i] = self.arithmetic.add_public(share[i][i], x_public[i][i])
            else: share = self.arithmetic.add_public(share, x_public)
        else: share = self.arithmetic.add_public(share, x_public)
        
        sv = SecureValue[typeof(share)](share)
        sv.fp = y.fp

        if y.sqrt:
            sv.sqrt = typeof(share)(0)
            sv.sqrt_inv = typeof(share)(0)
        
        if not y.is_partitioned():
            return sv
        
        sv.x_r = y.x_r + x_public
        sv.r = y.r

        return sv
