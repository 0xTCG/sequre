from ..utils.param import *
from ..utils.utils import cartesian, evalp
from ..utils.type_ops import TypeOps
from ..utils.custom_types import SecureValue

from comms import MPCComms
from prg import MPCPRG
from arithmetic import MPCArithmetic
from polynomial import MPCPolynomial
from boolean import MPCBoolean
from fp import MPCFP
from lin_alg import MPCLinAlg
from optimizations import MPCOptimizations


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.prg = MPCPRG(self.pid)
        self.comms = MPCComms[TP](self.pid, self.prg)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp)
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_):
        field = self.primes[0]
        x_r = list[TP](len(x_))
        r = list[TP](len(x_))

        for sn in x_:
            if not sn.is_partitioned():
                sn.set_partitions(
                    self.arithmetic.__beaver_partition(sn.share, field))
            
            x_r_, r_ = sn.get_partitions()
            x_r.append(x_r_)
            r.append(r_)

        coefs = [size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        result = self.optimizations.secure_evalp(
            x_r, r, coefs, exps, field)
        sv = SecureValue[typeof(result)](result)
        sv.fp = x_[0].is_fp()
        
        # TODO: Handle sqrts

        return sv

    def secure_mult(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.__beaver_partition(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.__beaver_reconstruct(c, field)

        if x.is_fp() and y.is_fp():
            c = self.fp.trunc(c)
        
        sv = SecureValue[typeof(c)](c)
        sv.fp = x.is_fp() or y.is_fp()

        if x.sqrt and y.sqrt:
            sv.sqrt = x.sqrt * y.sqrt
            sv.sqrt_inv = x.sqrt_inv * y.sqrt_inv

        return sv
    
    def secure_mult_no_cache(self, x_, y_):
        x = x_.share
        y = y_.share

        c = self.arithmetic.multiply(x, y)

        if x_.is_fp() and x_.is_fp():
            c = self.fp.trunc(c)

        sv = SecureValue[typeof(c)](c)
        sv.fp = x_.is_fp() or y_.is_fp()

        if x_.sqrt and y_.sqrt:
            sv.sqrt = x_.sqrt * y_.sqrt
            sv.sqrt_inv = x_.sqrt_inv * y_.sqrt_inv

        return sv

    def secure_pow(self, x_, p):
        field = self.primes[0]

        if x_.is_fp():
            raise NotImplementedError('There is no support for FP powers yet')

        if p >= len(x_.pows):
            if not x_.is_partitioned():
                x_.set_partitions(self.arithmetic.__beaver_partition(x_.share, field))

            if isinstance(x_.share, list[list[TP]]):
                pows = self.polynomial.powers(
                    x_.share.flatten(), p, field,
                    x_.x_r.flatten(), x_.r.flatten())
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append([pows[i]].reshape(x_.share.shape()))
            elif isinstance(x_.share, list[TP]): 
                pows = self.polynomial.powers(
                    x_.share, p, field,
                    x_.x_r, x_.r)
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append(pows[i])
            else:
                pows = self.polynomial.powers(
                    [x_.share], p, field,
                    [x_.x_r], [x_.r])
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append(pows[i][0])
        
        c = x_.pows[p]
        sv = SecureValue[typeof(c)](c)
        sv.fp = x_.is_fp()

        if x_.sqrt:
            sv.sqrt = x_.sqrt ** p
            sv.sqrt_inv = x_.sqrt_inv ** p

        return sv

    def secure_pow_no_cache(self, x_, p):
        x = x_.share

        for _ in range(p - 1):
            x = self.arithmetic.multiply(x, x_.share)
            if x_.is_fp(): x = self.fp.trunc(x)
        
        sv = SecureValue[typeof(x)](x)
        sv.fp = x_.is_fp()

        if x_.sqrt:
            sv.sqrt = x_.sqrt ** p
            sv.sqrt_inv = x_.sqrt_inv ** p

        return sv
    
    def secure_reveal(self, e):
        revealed_e = self.comms.reveal(e.share)
        
        c = revealed_e // 2
        if self.pid == 1: c += (revealed_e % TP(2))

        sv = SecureValue[typeof(c)](c, e.x_r, e.r)
        sv.fp = e.is_fp()
            
        return sv
    
    def dot(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.__beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.__beaver_partition(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_dot_prod(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.__beaver_reconstruct(c, field)

        if x.is_fp() and y.is_fp():
            c = self.fp.trunc(c)
        
        sv = SecureValue[TP](c)
        sv.fp = x.is_fp() or y.is_fp()

        return sv
    
    def sqrt(self, x):
        if not x.sqrt:
            x.sqrt, x.sqrt_inv = self.fp.fp_sqrt(x.share)
        
        return SecureValue[typeof(x)](x.sqrt)
    
    def sqrt_inv(self, x):
        if not x.sqrt_inv:
            x.sqrt, x.sqrt_inv = self.fp.fp_sqrt(x.share)
        
        return SecureValue[typeof(x)](x.sqrt_inv)
    