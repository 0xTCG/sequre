from ..utils.param import *
from ..utils.utils import shapeof

from prg import MPCPRG
from ..network.socket import CSocket
from ..network.connect import open_channel, connect


class MPCComms[TP]:
    pid: int
    sockets: dict[int, CSocket]
    bytes_sent: int
    requests_sent: int
    prg: MPCPRG

    def __init__(self: MPCComms[TP], pid: int, prg: MPCPRG):
        self.pid = pid
        self.prg = prg
        self.sockets = dict[int, CSocket]()
        self.bytes_sent = 0
        self.requests_sent = 0

        self.__setup_channels()

    def send_bool(self: MPCComms[TP], flag: bool, to_pid: int):
        self.sockets[to_pid].send([TP(int(flag))], SIZE_OF_U)

    def receive_bool(self: MPCComms[TP], from_pid: int) -> bool:
        return bool(next(self.sockets[from_pid].receive(msg_len=SIZE_OF_U)))

    def send[CT](self: MPCComms[TP], data: CT, to_pid: int) -> int:
        bytes_sent = self.sockets[to_pid].send(data.to_bytes(), data.msg_len())
        self.bytes_sent += bytes_sent
        self.requests_sent += 1
        return bytes_sent
    
    def receive(self, from_pid: int, shape = False):
        if isinstance(shape, bool):
            return self.__receive_elem(from_pid)
        if isinstance(shape, int):
            return self.__receive_vector(from_pid, shape)
        if isinstance(shape, list[int]):
            return self.__receive_matrix(from_pid, shape)
        
        raise TypeError(f"Invalid type for {shape}")

    def share(self, value):
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = value.rand(BASE_P)
            self.prg.restore_seed(1)

            value -= r
            value %= BASE_P

            self.send(value, 2)
            return value
        elif self.pid == 2:
            return self.receive(0, shapeof(value))
        else:
            self.prg.switch_seed(0)
            r = value.rand(BASE_P)
            self.prg.restore_seed(0)
            return r

    def reveal(self, value, field = BASE_P):
        if self.pid == 0:
            return value
        
        if self.pid == 1:
            self.send(value, 3 - self.pid)
            received_value = self.receive(3 - self.pid, shapeof(value))
            
            return (value + received_value) % field
        
        received_value = self.receive(3 - self.pid, shapeof(value))
        self.send(value, 3 - self.pid)

        return (value + received_value) % field
    
    def sync_nodes(self: MPCComms[TP]):
        if (self.pid == 0):
            self.receive_bool(1)
            self.receive_bool(2)
        else: self.send_bool(True, 0)
    
    def clean_up(self: MPCComms[TP]):
        for socket in self.sockets.values():
            socket.close()
    
    def print_stats(self: MPCComms[TP]):
        print f'Total bytes sent from {self.pid}: {self.bytes_sent}.'
        print f'Total send requests at {self.pid}: {self.requests_sent}.'
    
    def reset_stats(self: MPCComms[TP]):
        self.bytes_sent = 0
        self.requests_sent = 0
    
    def __receive_elem(self: MPCComms[TP], from_pid: int) -> TP:
        return TP(next(self.sockets[from_pid].receive(msg_len=SIZE_OF_U)))

    def __receive_vector(self: MPCComms[TP], from_pid: int, length: int) -> list[TP]:
        received_vec = list[TP](length)

        for elem in self.sockets[from_pid].receive(msg_len=length * SIZE_OF_U):
            received_vec.append(TP(elem))

        return received_vec
    
    def __receive_matrix(self: MPCComms[TP], from_pid: int, shape: list[int]) -> list[list[TP]]:
        rows, cols = shape
        matrix = list[list[TP]](rows)
        row = list[TP](cols)
        j = 0

        for elem in self.sockets[from_pid].receive(msg_len=rows * cols * SIZE_OF_U):
            if j != cols:
                row.append(TP(elem))
                j += 1
            if j == cols:
                matrix.append(row)
                j = 0
                row = list[TP](cols)

        return matrix
    
    def __setup_channels(self):
        for p_1 in range(2):
            for p_2 in range(p_1 + 1, 3):
                if (p_1 != self.pid and p_2 != self.pid):
                    continue

                serveraddr = SERVERADDR_P0_P1
                serveraddr_len = ADDR_LEN_P0_P1
                if (p_1 == 0 and p_2 == 1):
                    serveraddr = SERVERADDR_P0_P1
                    serveraddr_len = ADDR_LEN_P0_P1
                elif (p_1 == 0 and p_2 == 2):
                    serveraddr = SERVERADDR_P0_P2
                    serveraddr_len = ADDR_LEN_P0_P2
                elif (p_1 == 1 and p_2 == 2):
                    serveraddr = SERVERADDR_P1_P2
                    serveraddr_len = ADDR_LEN_P1_P2
                else:
                    raise ValueError('Ivalid node pairs!')
                
                pother: int = p_1 + p_2 - self.pid
                self.sockets[pother] = CSocket()

                if (p_1 == self.pid):
                    open_channel(self.sockets[pother], serveraddr, serveraddr_len)
                elif (not connect(self.sockets[pother], serveraddr, serveraddr_len)):
                    raise ValueError(f"{self.pid} failed to connect with {pother}")
