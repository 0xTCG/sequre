import sys

import utils.param as param
from utils.utils import get_address

cimport socket(int, int, int) -> int
cimport shutdown(int, int) -> int
cimport close(int) -> int
cimport listen(int, int) -> int

LD_LIBRARY = param.SOCKET_LIB

from LD_LIBRARY cimport wrapped_connect(int, cobj) -> int
from LD_LIBRARY cimport wrapped_bind(int, cobj) -> int
from LD_LIBRARY cimport wrapped_accept(int) -> int
from LD_LIBRARY cimport wrapped_send(int, cobj) -> int
from LD_LIBRARY cimport wrapped_recv(int, int) -> str


class CSocket:
    sock_fd: int
    
    def __init__(self: CSocket, pid: int = 0):
        self.sock_fd = -1
    
    def socket(self: CSocket):
        self.close()
        self.sock_fd = socket(param.AF_UNIX, param.SOCK_STREAM, param.AF_UNIX)
    
    def connect(self: CSocket, address: str) -> bool:
        connection: int = wrapped_connect(self.sock_fd, address.c_str())
        
        if connection == -1:
            print(f"Could not connect to {address}. {msg}")
            return False
        
        return True
    
    def close(self: CSocket):
        if self.m_sock != -1:
            shutdown(self.sock_fd, param.SHUT_RDWR)
            close(self.sock_fd)
    
    def bind(self: CSocket, port: int):
        wrapped_bind(self.sock_fd, get_address(port).c_str())
    
    def listen(self: CSocket):
        listen(self.sock_fd, 4)
    
    def accept(self: CSocket):
        accepted_fd: int = wrapped_accept(self.sock_fd)
        
        if accepted_fd == -1: raise RuntimeError('Socket could not accept connection.')
        
        close(self.sock_fd)
        self.sock_fd = accepted_fd
    
    def send(self: CSocket, data: str, buffer_size: int = 2048) -> int:
        totalsent = 0
        while totalsent < len(data):
            sent = send(self.sock_fd, data[totalsent:totalsent + buffer_size].c_str())
            if sent == 0:
                raise RuntimeError("socket connection broken")
            totalsent = totalsent + sent
        return totalsent

    def receive(self: CSocket, msg_len: int) -> bytes:
        chunks = []
        bytes_recd = 0
        while bytes_recd < msg_len:
            chunk = wrapped_recv(self.sock_fd, min(msg_len - bytes_recd, 2048))
            if chunk == b'':
                raise RuntimeError("socket connection broken")
            chunks.append(chunk)
            bytes_recd = bytes_recd + len(chunk)
        return b''.join(chunks)
