import os
from utils.param import GWAS_DATA_PATH, SKIP_QC

from ..utils.param import *
from ..utils.type_ops import TypeOps
from ..utils.io import (
    get_cache_path,
    read_vector_from_cache,
    read_matrix_from_cache)

from ..mpc.env import MPCEnv


def gwas_protocol[TP](mpc: MPCEnv[TP], test_run: bool = False):
    n0 = NUM_INDS
    m0 = NUM_SNPS
    k = NUM_DIM_TO_REMOVE
    kp = k + NUM_OVERSAMPLE
    prime_bytes = mpc.boolean.primes_bytes[0]

    temp_vec = list[TP]()
    temp_mat = list[list[TP]]()

    # Read in SNP list
    snp_pos = [TP(0) for _ in range(m0)]  # Vector([0] * m0)

    with open(SNP_POS_FILE) as f:
        for i, line in zip(range(m0), f):
            chrom, pos = line.split()
            snp_pos[i] = TP(int(chrom)) * TP(int(1e9)) + TP(int(pos))

    # Useful constants
    two = TP(2)  # Zp(2, base=BASE_P)
    twoinv = TypeOps.mod_inv(two, BASE_P)
    fp_one = TypeOps.double_to_fp(1.0, NBIT_K, NBIT_F)

    with open(f"{GWAS_DATA_PATH}/pheno_shares.txt") as f_pheno:
        with open("{GWAS_DATA_PATH}/cov_shares.txt") as f_cov:
            pheno = read_vector[TP](f_pheno, n0, prime_bytes)
            cov = read_matrix[TP](f_cov, n0, NUM_COVS, prime_bytes)

    print("Phenotypes and covariates loaded")

    gkeep1 = [TP(1) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m0)])

    if not SKIP_QC:
        raise NotImplementedError()
        # history: bool = False
        # # TODO: Fix
        # # if mpc.pid == 2:
        # #     history = file_exists(get_output_path(mpc.pid, "gkeep1"))
        # #     mpc.comms.send_bool(history, 0)
        # #     mpc.comms.send_bool(history, 1)
        # # else:
        # #     # ask P2 if gkeep1 has been computed before
        # #     history = mpc.comms.receive_bool(2)

        # if history:
        #     print("Using locus missing rate filter from a previous run")

        #     if mpc.pid == 2:
        #         with open(get_output_path(mpc.pid, "gkeep1")) as f:
        #             for i, line in zip(range(m0), f):
        #                 gkeep1[i] = TP(line)  # Zp(TP(next(f)), base=BASE_P)

        #         mpc.comms.send_data(gkeep1, 0, SIZE_OF_U * m0)
        #         mpc.comms.send_data(gkeep1, 1, SIZE_OF_U * m0)
        #     else:
        #         gkeep1 = mpc.comms.receive_vector(2, m0)
        # else:
        #     gmiss = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m0)])

        #     if file_exists(get_cache_path(mpc.pid, "gmiss")):
        #         print("Locus missing rate cache found")

        #         with open(get_cache_path(mpc.pid, "gmiss")) as f:
        #             gmiss = read_vector_from_cache[TP](f, m0, prime_bytes)
        #     else:
        #         print("Taking a pass to calculate locus missing rates:")

        #         if mpc.pid > 0:
        #             with open(get_cache_path(mpc.pid, "input_geno")) as f:
        #                 # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
        #                 mpc.prg.import_seed(10, 1)

        #                 bsize: int = n0 // 10

        #                 for i in range(n0):
        #                     miss = [TP(0) for _ in range(m0)]
        #                     # Load stored Beaver partition
        #                     mpc.prg.switch_seed(10)
        #                     tmp_mat = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)  # g_mask
        #                     miss_mask = rand_vec(m0, BASE_P)
        #                     mpc.prg.restore_seed(10)

        #                     if mpc.pid == 2:
        #                         f.read(prime_bytes * 3 * m0)  # skip data
        #                         miss = read_vector_from_cache[TP](f, m0, prime_bytes)

        #                     # Recover secret shares from Beaver partition
        #                     if mpc.pid == 1:
        #                         miss = miss_mask
        #                     else:
        #                         miss += miss_mask

        #                     # Add to running sum
        #                     miss %= BASE_P
        #                     gmiss += miss
        #                     gmiss %= BASE_P

        #         # TODO: Fix.
        #         # with open(get_cache_path(mpc.pid, "gmiss"), 'wb') as f:
        #         #     write_to_cache(f, gmiss)

        #         print("Wrote results to cache")

        #     print("Locus missing rate filter ... ")

        #     gmiss_ub = TP(n0 * GMISS_UB) % BASE_P
        #     gkeep1 = mpc.boolean.less_than_public(gmiss, gmiss_ub)
        #     gkeep1 = mpc.comms.reveal_vector(gkeep1)

        #     if mpc.pid == 2:
        #         mpc.comms.send_data(gkeep1, 0, SIZE_OF_U * m0)
        #     elif mpc.pid == 0:
        #         gkeep1 = mpc.comms.receive_vector(2, m0)

        #     if mpc.pid == 2:
        #         with open(get_output_path(mpc.pid, "gkeep1"), 'w') as f:
        #             for i in range(len(gkeep1)):
        #                 f.write(f'{gkeep1[i]}\n')

    m1 = int(sum(gkeep1))
    print("n0:", n0, ",", "m1:", m1)

    print("Filtering SNP position vector")
    snp_pos = [snp_pos[i] for i in range(len(snp_pos)) if gkeep1[i]]

    ikeep = [TP(1) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(n0)])

    if not SKIP_QC:
        raise NotImplementedError()
        # history: bool = False
        # # TODO: Fix.
        # # if mpc.pid == 2:
        # #     history = file_exists(get_output_path(mpc.pid, "ikeep"))
        # #     mpc.comms.send_bool(history, 0)
        # #     mpc.comms.send_bool(history, 1)
        # # else:
        # #     # ask P2 if ikeep has been computed before
        # #     history = mpc.comms.receive_bool(2)

        # if history:
        #     print("Using individual missing rate/het rate filters from a previous run")

        #     if mpc.pid == 2:
        #         with open(get_output_path(mpc.pid, "ikeep")) as f:
        #             for i, line in zip(range(n0), f):
        #                 ikeep[i] = TP(line)  # Zp(TP(next(f)), base=BASE_P)

        #         mpc.comms.send_data(ikeep, 0, SIZE_OF_U * n0)
        #         mpc.comms.send_data(ikeep, 1, SIZE_OF_U * n0)
        #     else:
        #         ikeep = mpc.comms.receive_vector(2, n0)
        # else:
        #     imiss = [TP(0) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(n0)])
        #     ihet = [TP(0) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(n0)])

        #     if file_exists(get_cache_path(mpc.pid, "imiss_ihet")):
        #         print("Individual missing rate and het rate cache found")

        #         with open(get_cache_path(mpc.pid, "imiss_ihet")) as f:
        #             imiss = read_vector_from_cache[TP](f, n0, prime_bytes)
        #             ihet = read_vector_from_cache[TP](f, n0, prime_bytes)
        #     else:
        #         print("Taking a pass to calculate individual missing rates and het rates:")

        #         if mpc.pid > 0:
        #             with open(get_cache_path(mpc.pid, "input_geno")) as f:
        #                 # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
        #                 mpc.prg.import_seed(10, 1)
        #                 bsize: int = n0 // 10

        #                 for i in range(n0):
        #                     g = [[TP(0) for _ in range(m0)] for _ in range(3)]
        #                     miss = [TP(0) for _ in range(m0)]
        #                     # Load stored Beaver partition
        #                     mpc.prg.switch_seed(10)
        #                     g_mask = rand_mat([3, m0], BASE_P)
        #                     miss_mask = rand_vec(m0, BASE_P)
        #                     mpc.prg.restore_seed(10)

        #                     if mpc.pid == 2:
        #                         g = read_matrix_from_cache[TP](f, 3, m0, prime_bytes)
        #                         miss = read_vector_from_cache[TP](f, m0, prime_bytes)

        #                     # Recover secret shares from Beaver partition
        #                     if mpc.pid == 1:
        #                         g = g_mask
        #                         miss = miss_mask
        #                     else:
        #                         g += g_mask
        #                         miss += miss_mask

        #                     # Add to running sum
        #                     for j in range(m0):
        #                         if gkeep1[j] == 1:
        #                             imiss[i] += miss[j]
        #                             ihet[i] += g[1][j]

        #         # with open(get_cache_path(mpc.pid, "imiss_ihet"), 'wb') as f:
        #         #     write_to_cache(f, imiss)
        #         #     write_to_cache(f, ihet)

        #         print("Wrote results to cache")

        #     # Individual missingness filter
        #     print("Individual missing rate filter ... ")
        #     imiss_ub = TP(m1 * IMISS_UB)  # Zp(m1 * IMISS_UB, base=BASE_P)
        #     ikeep = mpc.boolean.less_than_public(imiss, imiss_ub)

        #     # Individual heterozygosity filter
        #     print("Individual heterozygosity rate filter ... ")
        #     ihet_ub_frac = TypeOps.double_to_fp(HET_UB, NBIT_K, NBIT_F)
        #     ihet_lb_frac = TypeOps.double_to_fp(HET_LB, NBIT_K, NBIT_F)

        #     # Number of observed SNPs per individual
        #     m1_obs = [TP(0) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(n0)])
        #     if mpc.pid > 0:
        #         for i in range(n0):
        #             m1_obs[i] = -imiss[i]
        #             if mpc.pid == 1:
        #                 m1_obs[i] += m1

        #     ihet_ub = [TP(0) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(n0)])
        #     ihet_lb = [TP(0) for _ in range(n0)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(n0)])

        #     if mpc.pid > 0:
        #         for i in range(n0):
        #             ihet_ub[i] = m1_obs[i] * ihet_ub_frac
        #             ihet_lb[i] = m1_obs[i] * ihet_lb_frac
        #             ihet[i] *= fp_one

        #     het_filt = mpc.boolean.less_than(ihet, ihet_ub)
        #     tmp_vec = mpc.boolean.not_less_than(ihet, ihet_lb)
        #     het_filt = mpc.arithmetic.multiply_vec(het_filt, tmp_vec)

        #     ikeep = mpc.arithmetic.multiply_vec(ikeep, het_filt)

        #     # Reveal samples to be filtered
        #     mpc.comms.reveal_vector(ikeep)

        #     if mpc.pid == 2:
        #         mpc.comms.send_data(ikeep, 0, n0 * SIZE_OF_U)
        #     elif mpc.pid == 0:
        #         ikeep = mpc.comms.receive_vector(2, n0)

        #     # if mpc.pid == 2:
        #     #     with open(get_output_path(mpc.pid, "ikeep"), 'w') as f:
        #     #         for i in range(len(ikeep)):
        #     #             f.write(f'{ikeep[i]}\n')

    n1 = int(sum(ikeep))
    print("n1:", n1, ",", "m1:", m1)

    print("Filtering phenotypes and covariates")
    pheno = [pheno[i] for i in range(len(pheno)) if ikeep[i]]
    cov = [cov[i] for i in range(len(cov)) if ikeep[i]]

    ctrl = mpc.boolean.flip_bit(pheno)
    ctrl, ctrl_mask = mpc.arithmetic.__beaver_partition(ctrl)

    dosage_sum = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])
    gmiss = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])
    gmiss_ctrl = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])
    dosage_sum_ctrl = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])
    g_count_ctrl = [[TP(0) for _ in range(m1)] for _ in range(3)]  # Matrix(3, m1)
    n1_ctrl = TP(0)  # Zp(0, BASE_P)

    if (file_exists(get_cache_path(mpc.pid, "geno_stats"))):
        raise NotImplementedError()
        # print("Genotype statistics cache found")

        # with open(get_cache_path(mpc.pid, "geno_stats")) as f:
        #     gmiss = read_vector_from_cache[TP](f, m1, prime_bytes)
        #     gmiss_ctrl = read_vector_from_cache[TP](f, m1, prime_bytes)
        #     dosage_sum = read_vector_from_cache[TP](f, m1, prime_bytes)
        #     dosage_sum_ctrl = read_vector_from_cache[TP](f, m1, prime_bytes)
        #     g_count_ctrl = read_matrix_from_cache[TP](f, 3, m1, prime_bytes)
        #     n1_ctrl = TP(next(f))  # Zp(TP(next(f)), BASE_P)
    else:
        print("Taking a pass to calculate genotype statistics:")

        with open(f"{GWAS_DATA_PATH}/geno_shares.txt") as f_geno:
            with open(f"{GWAS_DATA_PATH}/miss_shares.txt") as f_miss:
                if mpc.pid > 0:
                    mpc.prg.import_seed(10, hash("geno0"))
                else:
                    for p in range(1, 3):
                        mpc.prg.import_seed(10 + p, hash(f"geno{p}"))

                bsize = PITER_BATCH_SIZE

                # Containers for batching the computation
                g = list[list[list[TP]]]()
                g_mask = list[list[list[TP]]]()
                dosage = [[TP(0) for _ in range(m1)] for _ in range(bsize)]  # Matrix(bsize, m1)
                dosage_mask = [[TP(0) for _ in range(m1)] for _ in range(bsize)]  # Matrix(bsize, m1)
                miss = [[TP(0) for _ in range(m1)] for _ in range(bsize)]  # Matrix(bsize, m1)
                miss_mask = [[TP(0) for _ in range(m1)] for _ in range(bsize)]  # Matrix(bsize, m1)

                for k in range(3):
                    g.append([[TP(0) for _ in range(m1)] for _ in range(bsize)])  # Matrix(bsize, m1))
                    g_mask.append([[TP(0) for _ in range(m1)] for _ in range(bsize)])  # Matrix(bsize, m1))

                ctrl_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
                ctrl_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])

                ind = -1

                for i in range(n1):
                    ind += 1

                    g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
                    g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
                    miss0 = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])
                    miss0_mask = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])

                    while (ikeep[ind] != 1):
                        raise NotImplementedError()
                        # if mpc.pid > 0:
                        #     f.read(mpc.boolean.primes_bytes[0] * 3 * m0)  # skip_data(f, 3, m0)
                        #     f.read(mpc.boolean.primes_bytes[0] * m0)  # skip_data(f, m0)

                        #     mpc.prg.switch_seed(10)
                        #     g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
                        #     miss0_mask = rand_vec(m0, BASE_P)
                        #     mpc.prg.restore_seed(10)
                        # else:
                        #     for p in range(1, 3):
                        #         mpc.prg.switch_seed(10 + p)
                        #         g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
                        #         miss0_mask = rand_vec(m0, BASE_P)
                        #         mpc.prg.restore_seed(10 + p)

                        # ind += 1

                    if mpc.pid > 0:
                        g0 = read_matrix[TP](f_geno)
                        miss0 = read_vector_from_cache[TP](f_miss, m0, prime_bytes)

                        mpc.prg.switch_seed(10)
                        g0_mask = g0.rand()
                        miss0_mask = miss0.rand()
                        mpc.prg.restore_seed(10)
                    else:
                        for p in range(1, 3):
                            mpc.prg.switch_seed(10 + p)
                            tmp_mat = g0.rand()
                            tmp_vec = miss0.rand()
                            mpc.prg.restore_seed(10 + p)

                            g0_mask += tmp_mat
                            miss0_mask += tmp_vec

                    # Filter out loci that failed missing rate filter
                    ind2 = 0
                    for j in range(m0):
                        if gkeep1[j] == 1:
                            for k in range(3):
                                g[k][i % bsize][ind2] = g0[k][j]
                                g_mask[k][i % bsize][ind2] = g0_mask[k][j]
                            miss[i % bsize][ind2] = miss0[j]
                            miss_mask[i % bsize][ind2] = miss0_mask[j]
                            ind2 += 1

                    dosage[i % bsize] = g[1][i % bsize] + g[2][i % bsize] * 2
                    dosage_mask[i % bsize] = g_mask[1][i % bsize] + g_mask[2][i % bsize] * 2

                    ctrl_vec[i % bsize] = ctrl[i]
                    ctrl_mask_vec[i % bsize] = ctrl_mask[i]

                    # Update running sums
                    if mpc.pid > 0:
                        n1_ctrl += ctrl_mask[i]
                        gmiss += miss_mask[i % bsize]
                        dosage_sum += dosage_mask[i % bsize]

                        if mpc.pid == 1:
                            n1_ctrl += ctrl[i]
                            gmiss += miss[i % bsize]
                            dosage_sum += dosage[i % bsize]

                    if (i % bsize == bsize - 1 or i == n1 - 1):
                        if i % bsize < bsize - 1:
                            new_bsize = (i % bsize) + 1

                            for k in range(3):
                                g[k] = g[k].pad(new_bsize, m1)
                                g_mask[k] = g_mask[k].pad(new_bsize, m1)

                            dosage = dosage.pad(new_bsize, m1)
                            dosage_mask = dosage_mask.pad(new_bsize, m1)
                            miss = miss.pad(new_bsize, m1)
                            miss_mask = miss_mask.pad(new_bsize, m1)
                            ctrl_vec = ctrl_vec.pad_vec(new_bsize)  # set_length(new_bsize)
                            ctrl_mask_vec = ctrl_mask_vec.pad_vec(new_bsize)

                        gmiss_ctrl = mpc.arithmetic.__beaver_mult(
                            ctrl_vec, ctrl_mask_vec, miss, miss_mask)
                        dosage_sum_ctrl = mpc.arithmetic.__beaver_mult(
                            ctrl_vec, ctrl_mask_vec, dosage, dosage_mask)
                        for k in range(3):
                            g_count_ctrl[k] = mpc.arithmetic.__beaver_mult(
                                ctrl_vec, ctrl_mask_vec, g[k], g_mask[k])

            gmiss_ctrl = mpc.arithmetic.__beaver_reconstruct(gmiss_ctrl)
            dosage_sum_ctrl = mpc.arithmetic.__beaver_reconstruct(dosage_sum_ctrl)
            g_count_ctrl = mpc.arithmetic.__beaver_reconstruct(g_count_ctrl)

            # Write to cache
            # with open(get_cache_path(mpc.pid, "geno_stats"), 'wb') as f:
            #     write_to_cache(f, gmiss)
            #     write_to_cache(f, gmiss_ctrl)
            #     write_to_cache(f, dosage_sum)
            #     write_to_cache(f, dosage_sum_ctrl)
            #     write_to_cache(f, g_count_ctrl)
            #     write_to_cache(f, [n1_ctrl])

            #     print("Wrote results to cache")

    # # SNP MAF filter
    # print("Locus minor allele frequency (MAF) filter ... ")
    # maf_lb = TypeOps.double_to_fp(MAF_LB, NBIT_K, NBIT_F)
    # maf_ub = TypeOps.double_to_fp(MAF_UB, NBIT_K, NBIT_F)

    # dosage_tot = [TP(0) for _ in range(len(gmiss))]  # Vector()
    # dosage_tot_ctrl = [TP(0) for _ in range(len(gmiss_ctrl))]  # Vector()
    # if mpc.pid > 0:
    #     dosage_tot = -gmiss
    #     dosage_tot_ctrl = -gmiss_ctrl
    #     dosage_tot += n1
    #     dosage_tot %= BASE_P
    #     dosage_tot_ctrl += n1_ctrl
    #     dosage_tot *= 2
    #     dosage_tot_ctrl *= 2

    # print("Calculating MAFs ... ")
    # dosage_tot_len = len(dosage_tot)
    # dosage_tot_ctrl_len = len(dosage_tot_ctrl)
    # maf = [TP(0) for _ in range(dosage_tot_len)]  # Vector()
    # maf_ctrl = [TP(0) for _ in range(dosage_tot_ctrl_len)]  # Vector()
    # if (file_exists(get_cache_path(mpc.pid, "maf"))):
    #     print("maf cache found")
    #     with open(get_cache_path(mpc.pid, "maf")) as f:
    #         maf = read_vector_from_cache[TP](f, dosage_tot_len, prime_bytes)
    #         maf_ctrl = read_vector_from_cache[TP](f, dosage_tot_ctrl_len, prime_bytes)
    # else:
    #     maf = mpc.fp.fp_div(dosage_sum, dosage_tot)
    #     maf_ctrl = mpc.fp.fp_div(dosage_sum_ctrl, dosage_tot_ctrl)
        
    #     # with open(get_cache_path(mpc.pid, "maf"), 'wb') as f:
    #     #     write_to_cache(f, maf)
    #     #     write_to_cache(f, maf_ctrl)
    # print("done. ")

    # Maf = [TP(0) for _ in range(m1)]  # Vector()  # MAJOR allele freq
    # maf_ctrl = [TP(0) for _ in range(m1)]  # Vector()
    # Maf_ctrl = [TP(0) for _ in range(m1)]  # Vector()
    # if mpc.pid > 0:
    #     Maf = -maf
    #     Maf_ctrl = -maf_ctrl
    #     Maf = mpc.arithmetic.add_public_scalar(Maf, fp_one)
    #     Maf_ctrl = mpc.arithmetic.add_public_scalar(Maf_ctrl, fp_one)

    # # Variance based on Bernoulli distribution over each allele
    # g_var_bern = mpc.arithmetic.multiply_vec(maf, Maf)
    # g_var_bern = mpc.fp.trunc_vec(g_var_bern)

    # gkeep2 = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])

    # if SKIP_QC:
    #     for i in range(m1):
    #         gkeep2[i] = 1
    #     print("SNP MAF/HWE filters skipped")
    # else:
    #     history: bool = False
    #     if mpc.pid == 2:
    #         history = file_exists(get_output_path(mpc.pid, "gkeep2"))
    #         mpc.comms.send_bool(history, 0)
    #         mpc.comms.send_bool(history, 1)
    #     else:
    #         # ask P2 if gkeep2 has been computed before
    #         history = mpc.comms.receive_bool(2)

    #     if history:
    #         print("Using MAF/HWE filters from a previous run")

    #         if mpc.pid == 2:
    #             with open(get_output_path(mpc.pid, "gkeep2")) as f:
    #                 for i in range(m1):
    #                     gkeep2[i] = TP(next(f))  # Zp(TP(next(f)), BASE_P)

    #             mpc.comms.send_data(gkeep2, 0, m1 * SIZE_OF_U)
    #             mpc.comms.send_data(gkeep2, 1, m1 * SIZE_OF_U)
    #         else:
    #             gkeep2 = mpc.comms.receive_vector(2, m1)
    #     else:
    #         gkeep2 = mpc.boolean.less_than_public(maf, maf_ub)
    #         tmp_vec = mpc.boolean.not_less_than_public(maf, maf_lb)
    #         gkeep2 = mpc.arithmetic.multiply_vec(gkeep2, tmp_vec)

    #         print("Locus Hardy-Weinberg equilibrium (HWE) filter ... ")
    #         hwe_ub = TypeOps.double_to_fp(HWE_UB, NBIT_K, NBIT_F)  # p < 1e-7

    #         # Calculate expected genotype distribution in control group
    #         g_exp_ctrl = [[TP(0) for _ in range(m1)] for _ in range(3)]  # Matrix(3, m1)

    #         g_exp_ctrl[0] = mpc.arithmetic.multiply_vec(Maf_ctrl, Maf_ctrl)
    #         g_exp_ctrl[1] = mpc.arithmetic.multiply_vec(Maf_ctrl, maf_ctrl)
    #         if mpc.pid > 0:
    #             g_exp_ctrl[1] *= 2
    #         g_exp_ctrl[2] = mpc.arithmetic.multiply_vec(maf_ctrl, maf_ctrl)

    #         for i in range(3):
    #             g_exp_ctrl[i] = mpc.arithmetic.multiply_vec(g_exp_ctrl[i], dosage_tot_ctrl)

    #         g_exp_ctrl *= twoinv  # dosage_tot_ctrl is twice the # individuals we actually want
    #         g_exp_ctrl = mpc.fp.trunc(g_exp_ctrl, k=NBIT_K + NBIT_F, m=NBIT_F)

    #         print("\tCalculated expected genotype counts, ")

    #         hwe_chisq = [TP(0) for _ in range(m1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m1)])

    #         if (file_exists(get_cache_path(mpc.pid, "hwe"))):
    #             print("HWE cache found")
    #             with open(get_cache_path(mpc.pid, "hwe")) as f:
    #                 hwe_chisq = read_vector_from_cache[TP](f, m1, prime_bytes)
    #         else:
    #             for i in range(3):
    #                 diff = [TP(0) for _ in range(m1)]
    #                 if mpc.pid > 0:
    #                     diff = g_count_ctrl[i] * fp_one - g_exp_ctrl[i]

    #                 diff = mpc.arithmetic.multiply_vec(diff, diff)
    #                 diff = mpc.fp.trunc_vec(diff)

    #                 tmp_vec = mpc.fp.fp_div(diff, g_exp_ctrl[i])
    #                 hwe_chisq += tmp_vec

    #             # with open(get_cache_path(mpc.pid, "hwe"), 'wb') as f:
    #             #     write_to_cache(f, hwe_chisq)

    #         hwe_filt = mpc.boolean.less_than_public(hwe_chisq, hwe_ub)
    #         gkeep2 = mpc.arithmetic.multiply_vec(gkeep2, hwe_filt)

    #         # Reveal which SNPs to discard
    #         mpc.comms.reveal_vector(gkeep2)

    #         if mpc.pid == 2:
    #             mpc.comms.send_data(gkeep2, 0, m1 * SIZE_OF_U)
    #         elif mpc.pid == 0:
    #             gkeep2 = mpc.comms.receive_vector(2, m1)

    #         # if mpc.pid == 2:
    #         #     with open(get_output_path(mpc.pid, "gkeep2"), 'w') as f:
    #         #         for i in range(len(gkeep2)):
    #         #             f.write(f'{gkeep2[i]}\n')

    # m2: int = sum(gkeep2) % BASE_P
    # print("n1: ", n1, ", ", "m2: ", m2)

    # print("Filtering genotype statistics")
    # g_var_bern = [g_var_bern[i] for i in range(len(g_var_bern)) if gkeep2[i]]
    # maf = [maf[i] for i in range(len(maf)) if gkeep2[i]]
    # snp_pos = [snp_pos[i] for i in range(len(snp_pos)) if gkeep2[i]]

    # g_std_bern_inv = [TP(0) for _ in range(len(g_var_bern))]
    # if (file_exists(get_cache_path(mpc.pid, "stdinv_bern"))):
    #     print("Genotype standard deviation cache found")

    #     with open(get_cache_path(mpc.pid, "stdinv_bern")) as f:
    #         g_std_bern_inv = read_vector_from_cache[TP](f, len(g_var_bern), prime_bytes)

    # else:
    #     print("Calculating genotype standard deviations (inverse)")

    #     _, g_std_bern_inv = mpc.fp.fp_sqrt(g_var_bern)

    #     # with open(get_cache_path(mpc.pid, "stdinv_bern"), 'wb') as f:
    #     #     write_to_cache(f, g_std_bern_inv)

    # g_mean = [TP(0) for _ in range(m2)]
    # if mpc.pid > 0:
    #     g_mean = maf * 2

    # print(f"Starting population stratification analysis for {m2} elements")

    # selected: list[int] = [0 for _ in range(m2)]  # 1 selected, 0 unselected, -1 TBD

    # for i in range(m2):
    #     selected[i] = -1

    # dist_thres: int = LD_DIST_THRES

    # prev: int = -1
    # for i in range(m2):
    #     selected[i] = 0
    #     # TODO: Fix. if prev < 0 or snp_pos[i] - prev > dist_thres:
    #     if i % 4 == 0:
    #         selected[i] = 1
    #         prev = snp_pos[i]

    # # At this point "selected" contains the SNP filter for PCA, shared across all parties
    # m3: int = 0
    # for i in range(len(selected)):
    #     if selected[i] == 1:
    #         m3 += 1

    # print("SNP selection complete: ", m3, " / ", m2, " selected")

    # # Cache the reduced G for PCA
    # if (file_exists(get_cache_path(mpc.pid, "pca_input"))):
    #     print("pca_input cache found")
    # else:
    #     gkeep3: list[bool] = [False for _ in range(m0)]
    #     for j in range(m0):
    #         gkeep3[j] = (gkeep1[j] == 1)

    #     ind = 0
    #     for j in range(m0):
    #         if gkeep3[j]:
    #             gkeep3[j] = (gkeep2[ind] == 1)
    #             ind += 1

    #     ind = 0
    #     for j in range(m0):
    #         if gkeep3[j]:
    #             gkeep3[j] = (selected[ind] == 1)
    #             ind += 1

    #     with open(get_cache_path(mpc.pid, "input_geno")) as f_geno:
    #         if mpc.pid > 0:
    #             # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
    #             mpc.prg.import_seed(10, 1)
    #         else:
    #             for p in range(1, 3):
    #                 # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
    #                 mpc.prg.import_seed(10 + p, 1)

    #         bsize: int = n1 // 10

    #         print("Caching input data for PCA:")

    #         # with open(get_cache_path(mpc.pid, "pca_input"), 'wb') as f_pca:
    #         with open(get_cache_path(mpc.pid, "pca_input")) as f_pca:
    #             ind = -1
    #             for i in range(n1):
    #                 ind += 1

    #                 g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix()
    #                 g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix()
    #                 miss0 = [TP(0) for _ in range(m0)]  # Vector()
    #                 miss0_mask = [TP(0) for _ in range(m0)]  # Vector()

    #                 while ikeep[ind] != 1:
    #                     if mpc.pid > 0:
    #                         f_geno.read(mpc.boolean.primes_bytes[0] * 3 * m0)  # skip_data(f_geno, 3, m0)
    #                         f_geno.read(mpc.boolean.primes_bytes[0] * m0)  # skip_data(f_geno, m0)

    #                         mpc.prg.switch_seed(10)
    #                         g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                         miss0_mask = rand_vec(m0, BASE_P)
    #                         mpc.prg.restore_seed(10)
    #                     else:
    #                         for p in range(1, 3):
    #                             mpc.prg.switch_seed(10 + p)
    #                             g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                             miss0_mask = rand_vec(m0, BASE_P)
    #                             mpc.prg.restore_seed(10 + p)
    #                     ind += 1

    #                 if mpc.pid > 0:
    #                     g0 = read_matrix_from_cache[TP](f_geno, 3, m0, prime_bytes)
    #                     miss0 = read_vector_from_cache[TP](f_geno, m0, prime_bytes)

    #                     mpc.prg.switch_seed(10)
    #                     g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                     miss0_mask = rand_vec(m0, BASE_P)
    #                     mpc.prg.restore_seed(10)
    #                 else:
    #                     g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
    #                     g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
    #                     miss0 = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])
    #                     miss0_mask = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])

    #                     for p in range(1, 3):
    #                         mpc.prg.switch_seed(10 + p)
    #                         tmp_mat = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                         tmp_vec = rand_vec(m0, BASE_P)
    #                         mpc.prg.restore_seed(10 + p)

    #                         g0_mask += tmp_mat
    #                         miss0_mask += tmp_vec

    #                 # Filter out loci that failed missing rate filter
    #                 g = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m3)
    #                 g_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m3)
    #                 miss = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m3)])
    #                 miss_mask = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m3)])
    #                 ind2: int = 0
    #                 for j in range(m0):
    #                     if gkeep3[j]:
    #                         for k in range(3):
    #                             g[k][ind2] = g0[k][j]
    #                             g_mask[k][ind2] = g0_mask[k][j]
    #                         miss[ind2] = miss0[j]
    #                         miss_mask[ind2] = miss0_mask[j]
    #                         ind2 += 1

    #                 dosage = g[1] + g[2] * 2
    #                 dosage_mask = g_mask[1] + g_mask[2] * 2

    #                 # TODO: Fix.
    #                 # beaver_write_to_cache(dosage, dosage_mask, f_pca)
    #                 # beaver_write_to_cache(miss, miss_mask, f_pca)

    # g_mean_pca = [g_mean[i] for i in range(len(g_mean)) if selected[i]]
    # g_stdinv_pca = [g_std_bern_inv[i] for i in range(len(g_std_bern_inv)) if selected[i]]

    # g_mean_pca, g_mean_pca_mask = mpc.arithmetic.beaver_partition_vec(g_mean_pca)
    # g_stdinv_pca, g_stdinv_pca_mask = mpc.arithmetic.beaver_partition_vec(g_stdinv_pca)

    # # Pass 2: Random sketch
    # Y_cur = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    # if (file_exists(get_cache_path(mpc.pid, "sketch"))):
    #     print("sketch cache found")
    #     with open(get_cache_path(mpc.pid, "sketch")) as f:
    #         kp = TP(next(f))
    #         Y_cur = read_matrix_from_cache[TP](f, kp, m3, prime_bytes)
    # else:
    #     Y_cur_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #     bucket_count: list[int] = [0 for _ in range(kp)]

    #     with open(get_cache_path(mpc.pid, "pca_input")) as f:
    #         for cur in range(n1):
    #             # Count sketch (use global PRG)
    #             mpc.prg.switch_seed(-1)
    #             bucket_index = rand_int(0, kp - 1)
    #             rand_sign = rand_int(0, 1) * 2 - 1
    #             mpc.prg.restore_seed(-1)

    #             g, g_mask = beaver_read_from_cache[TP](f, m3)
    #             miss, miss_mask = beaver_read_from_cache[TP](f, m3)

    #             # Flip miss bits so it points to places where g_mean should be subtracted
    #             mpc.boolean.beaver_flip_bit(miss, miss_mask)

    #             # Update running sum
    #             if mpc.pid > 0:
    #                 Y_cur[bucket_index] += g_mask * rand_sign
    #                 if mpc.pid == 1:
    #                     Y_cur[bucket_index] += g * rand_sign

    #             # Update adjustment factor
    #             miss *= rand_sign
    #             miss_mask *= rand_sign
    #             Y_cur_adj[bucket_index] = mpc.arithmetic.beaver_mult[list[TP]](
    #                 miss, miss_mask, g_mean_pca, g_mean_pca_mask)

    #             bucket_count[bucket_index] += 1

    #     # Subtract the adjustment factor
    #     Y_cur_adj = mpc.arithmetic.beaver_reconstruct_mat(Y_cur_adj)
    #     if mpc.pid > 0:
    #         Y_cur = Y_cur * fp_one - Y_cur_adj

    #     # Get rid of empty buckets and normalize nonempty ones
    #     empty_slot: int = 0
    #     for i in range(kp):
    #         if bucket_count[i] > 0:
    #             fp_count_inv = TypeOps.double_to_fp(
    #                 1 / bucket_count[i], NBIT_K, NBIT_F)
    #             Y_cur[empty_slot] = Y_cur[i] * fp_count_inv
    #             empty_slot += 1
    #     kp = empty_slot
    #     Y_cur = Y_cur.pad(kp, m3)
    #     Y_cur = mpc.fp.trunc(Y_cur)

    #     # with open(get_cache_path(mpc.pid, "sketch"), 'wb') as f:
    #     #     write_to_cache(f, [kp])
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, Y_cur)

    # Y_cur, Y_cur_mask = mpc.arithmetic.beaver_partition_mat(Y_cur)

    # print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")

    # gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]

    # if (file_exists(get_cache_path(mpc.pid, "piter"))):
    #     print("piter cache found")
    #     with open(get_cache_path(mpc.pid, "piter")) as f:
    #         gQ = read_matrix_from_cache[TP](f, n1, kp, prime_bytes)
    # else:
    #     # Divide by standard deviation
    #     Y = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #     for i in range(kp):
    #         Y[i] = mpc.arithmetic.beaver_mult(Y_cur[i], Y_cur_mask[i], g_stdinv_pca, g_stdinv_pca_mask)

    #     Y = mpc.arithmetic.beaver_reconstruct_mat(Y)
    #     Y = mpc.fp.trunc(Y)

    #     # Calculate orthonormal bases of Y
    #     Q = mpc.lin_alg.orthonormal_basis(Y)

    #     # Power iteration
    #     for pit in range(NUM_POWER_ITER + 1):
    #         # This section is ran before each iteration AND once after all iterations
    #         Q, Q_mask = mpc.arithmetic.beaver_partition_mat(Q)

    #         # Normalize Q by standard deviations
    #         Q_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             Q_scaled[i] = mpc.arithmetic.beaver_mult(Q[i], Q_mask[i], g_stdinv_pca, g_stdinv_pca_mask)

    #         Q_scaled = mpc.arithmetic.beaver_reconstruct_mat(Q_scaled)
    #         Q_scaled = mpc.fp.trunc(Q_scaled)

    #         Q_scaled, Q_scaled_mask = mpc.arithmetic.beaver_partition_mat(Q_scaled)

    #         # Pre-multiply with g_mean to simplify calculation of centering matrix
    #         Q_scaled_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             Q_scaled_gmean[i] = mpc.arithmetic.beaver_mult(
    #                 Q_scaled[i], Q_scaled_mask[i], g_mean_pca, g_mean_pca_mask)
    #         Q_scaled_gmean = mpc.arithmetic.beaver_reconstruct_mat(Q_scaled_gmean)
    #         Q_scaled_gmean = mpc.fp.trunc(Q_scaled_gmean)

    #         Q_scaled = Q_scaled.transpose()  # m3-by-kp
    #         # transpose(, Q_scaled_mask); # m3-by-kp, unlike mpc.Transpose, P0 also transposes
    #         Q_scaled_mask = Q_scaled_mask.transpose()
    #         Q_scaled_gmean = Q_scaled_gmean.transpose()  # m3-by-kp
    #         Q_scaled_gmean, Q_scaled_gmean_mask = mpc.arithmetic.beaver_partition_mat(Q_scaled_gmean)

    #         bsize: int = PITER_BATCH_SIZE

    #         g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)

    #         # Pass 1
    #         gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]  # Matrix(n1, kp)
    #         gQ_adj = [[TP(0) for _ in range(kp)] for _ in range(n1)]  # Matrix(n1, kp)

    #         print 1, mpc.pid

    #         with open(get_cache_path(mpc.pid, "pca_input")) as f:
    #             for cur in range(n1):
    #                 g[cur % bsize], g_mask[cur % bsize] = beaver_read_from_cache[TP](f, m3)
    #                 miss[cur % bsize], miss_mask[cur % bsize] = beaver_read_from_cache[TP](f, m3)
    #                 mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize])

    #                 if cur % bsize == bsize - 1:
    #                     tmp_mat = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)
    #                     tmp_mat = mpc.arithmetic.beaver_mult(g, g_mask, Q_scaled, Q_scaled_mask)
    #                     for i in range(bsize):
    #                         gQ[cur-(bsize-1)+i] = tmp_mat[i]

    #                 tmp_mat = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)
    #                 tmp_mat = mpc.arithmetic.beaver_mult(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask)
    #                 for i in range(bsize):
    #                     gQ_adj[cur-(bsize-1)+i] = tmp_mat[i]

    #         print 2, mpc.pid

    #         remainder: int = n1 % bsize
    #         if remainder > 0:
    #             g = g.pad(remainder, m3)
    #             g_mask = g_mask.pad(remainder, m3)
    #             miss = miss.pad(remainder, m3)
    #             miss_mask = miss_mask.pad(remainder, m3)

    #             tmp_mat = mpc.arithmetic.beaver_mult(g, g_mask, Q_scaled, Q_scaled_mask)
    #             for i in range(remainder):
    #                 gQ[n1-remainder+i] = tmp_mat[i]

    #             tmp_mat = [[TP(0) for _ in range(kp)] for _ in range(remainder)]  # Matrix(remainder, kp)
    #             tmp_mat = mpc.arithmetic.beaver_mult(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask)
    #             for i in range(remainder):
    #                 gQ_adj[n1-remainder+i] = tmp_mat[i]
            
    #         print 3, mpc.pid, pit, NUM_POWER_ITER

    #         gQ = mpc.arithmetic.beaver_reconstruct_mat(gQ)
    #         gQ_adj = mpc.arithmetic.beaver_reconstruct_mat(gQ_adj)
    #         if mpc.pid > 0:
    #             gQ -= gQ_adj

    #         if pit == NUM_POWER_ITER:  # Quit if all iterations are performed
    #             break

    #         print 4, mpc.pid, pit, NUM_POWER_ITER

    #         gQ = gQ.transpose()  # kp-by-n1
    #         Q = mpc.lin_alg.orthonormal_basis(gQ, test=True)
    #         Q = Q.transpose()  # n1-by-kp

    #         Q, Q_mask = mpc.arithmetic.beaver_partition_mat(Q)

    #         gQ = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         gQ_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #         g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)

    #         Qsub = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)
    #         Qsub_mask = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)

    #         print 5, mpc.pid

    #         # Pass 2
    #         with open(get_cache_path(mpc.pid, "pca_input")) as f:
    #             for cur in range(n1):
    #                 g[cur % bsize], g_mask[cur % bsize] = beaver_read_from_cache[TP](f, m3)
    #                 miss[cur % bsize], miss_mask[cur % bsize] = beaver_read_from_cache[TP](f, m3)
    #                 mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize])

    #                 Qsub[cur % bsize] = Q[cur]
    #                 Qsub_mask[cur % bsize] = Q_mask[cur]

    #                 if cur % bsize == bsize - 1:
    #                     Qsub = Qsub.transpose()
    #                     Qsub_mask = Qsub_mask.transpose()

    #                     gQ = mpc.arithmetic.beaver_mult(Qsub, Qsub_mask, g, g_mask)
    #                     gQ_adj = mpc.arithmetic.beaver_mult(Qsub, Qsub_mask, miss, miss_mask)

    #                     Qsub = Qsub.pad(bsize, kp)
    #                     Qsub_mask = Qsub_mask.pad(bsize, kp)
            
    #         print 6, mpc.pid

    #         remainder: int = n1 % bsize
    #         if remainder > 0:
    #             g = g.pad(remainder, m3)
    #             g_mask = g_mask.pad(remainder, m3)
    #             miss = miss.pad(remainder, m3)
    #             miss_mask = miss_mask.pad(remainder, m3)
    #             Qsub = Qsub.pad(remainder, kp)
    #             Qsub_mask = Qsub_mask.pad(remainder, kp)

    #             Qsub = Qsub.transpose()
    #             Qsub_mask = Qsub_mask.transpose()

    #             gQ = mpc.arithmetic.beaver_mult(Qsub, Qsub_mask, g, g_mask)
    #             gQ_adj = mpc.arithmetic.beaver_mult(Qsub, Qsub_mask, miss, miss_mask)
            
    #         print 7, mpc.pid

    #         gQ = mpc.arithmetic.beaver_reconstruct_mat(gQ)
    #         gQ_adj = mpc.arithmetic.beaver_reconstruct_mat(gQ_adj)

    #         gQ_adj, gQ_adj_mask = mpc.arithmetic.beaver_partition_mat(gQ_adj)

    #         gQ_adj_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             gQ_adj_gmean[i] = mpc.arithmetic.beaver_mult(
    #                 gQ_adj[i], gQ_adj_mask[i], g_mean_pca, g_mean_pca_mask)
    #         gQ_adj_gmean = mpc.arithmetic.beaver_reconstruct_mat(gQ_adj_gmean)
    #         gQ_adj_gmean = mpc.fp.trunc(gQ_adj_gmean)

    #         print 8, mpc.pid

    #         if mpc.pid > 0:
    #             gQ -= gQ_adj_gmean
    #         gQ, gQ_mask = mpc.arithmetic.beaver_partition_mat(gQ)

    #         gQ_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #         for i in range(kp):
    #             gQ_scaled[i] = mpc.arithmetic.beaver_mult(gQ[i], gQ_mask[i], g_stdinv_pca, g_stdinv_pca_mask)
    #         gQ_scaled = mpc.arithmetic.beaver_reconstruct_mat(gQ_scaled)
    #         gQ_scaled = mpc.fp.trunc(gQ_scaled)

    #         print 9, mpc.pid

    #         Q = mpc.lin_alg.orthonormal_basis(gQ_scaled)

    #     # with open(get_cache_path(mpc.pid, "piter"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, gQ)

    # print("Power iteration complete")

    # Z = copy(gQ)

    # print("Data projected to subspace")
    # V = [[TP(0) for _ in range(n1)] for _ in range(k)]  # Matrix(k, n1)

    # # Eigendecomposition
    # if (file_exists(get_cache_path(mpc.pid, "eigen"))):
    #     print("eigen cache found")
    #     with open(get_cache_path(mpc.pid, "eigen")) as f:
    #         V = read_matrix_from_cache[TP](f, k, n1, prime_bytes)
    # else:
    #     fp_m2_inv = TypeOps.double_to_fp(1 / m2, NBIT_K, NBIT_F)
    #     Z *= fp_m2_inv
    #     Z = mpc.fp.trunc(Z)

    #     Z = Z.transpose() # kp-by-n1

    #     Z, Z_mask = mpc.arithmetic.beaver_partition_mat(Z)

    #     # Form covariance matrix
    #     Z_gram = [[TP(0) for _ in range(kp)] for _ in range(kp)]  # Matrix(kp, kp)
    #     for i in range(kp):
    #         # TODO: Fix. Change below to: Z_gram[i] = mpc.arithmetic.beaver_mult_rev(Z, Z_mask, Z[i], Z_mask[i])
    #         Z_gram[i] = mpc.arithmetic.beaver_mult(Z[i][0:kp], Z_mask[i][0:kp], Z[i][0:kp], Z_mask[i][0:kp])
    #     Z_gram = mpc.arithmetic.beaver_reconstruct_mat(Z_gram)
    #     Z_gram = mpc.fp.trunc(Z_gram)

    #     print(f"Constructed reduced eigenvalue problem for shape {Z_gram.shape()}")

    #     print 10, mpc.pid

    #     U, L = mpc.lin_alg.eigen_decomp(Z_gram, test=True)

    #     print 20, mpc.pid

    #     # Select top eigenvectors and eigenvalues
    #     U = U.pad(k, kp)
    #     L = L.pad_vec(k)

    #     print 30, mpc.pid

    #     print(f"Selected {k} eigenvectors")

    #     # Recover singular vectors
    #     U, U_mask = mpc.arithmetic.beaver_partition_mat(U)

    #     V = mpc.arithmetic.beaver_mult(U, U_mask, Z, Z_mask)
    #     V = mpc.arithmetic.beaver_reconstruct_mat(V)
    #     V = mpc.fp.trunc(V)

    #     print 40, mpc.pid

    #     # with open(get_cache_path(mpc.pid, "eigen"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, V)

    # # Concatenate covariate matrix and jointly orthogonalize
    # cov = cov.transpose()
    # V = V.pad(k + NUM_COVS, n1)
    # if mpc.pid > 0:
    #     for i in range(NUM_COVS):
    #         V[k + i] = cov[i] * fp_one
    
    # # TODO: Fix. V = mpc.lin_alg.orthonormal_basis(V)
    # V, V_mask = mpc.arithmetic.beaver_partition_mat(V)

    # print("Bases for top singular vectors and covariates calculated")
    # # Pass 4: Calculate GWAS statistics */

    # pheno, pheno_mask = mpc.arithmetic.beaver_partition_vec(pheno)

    # # TODO: Fix. Vp = mpc.arithmetic.beaver_mult(V, V_mask, pheno, pheno_mask)
    # Vp = mpc.arithmetic.beaver_mult(V[0], V_mask[0], pheno, pheno_mask)
    # Vp = mpc.arithmetic.beaver_reconstruct_vec(Vp)
    # Vp, Vp_mask = mpc.arithmetic.beaver_partition_vec(Vp)

    # VVp = mpc.arithmetic.beaver_mult_vec(Vp, Vp_mask, V, V_mask)
    # VVp = mpc.arithmetic.beaver_reconstruct_vec(VVp)
    # VVp = mpc.fp.trunc_vec(VVp)

    # VVp, VVp_mask = mpc.arithmetic.beaver_partition_vec(VVp)

    # p_hat = pheno * fp_one - VVp
    # p_hat_mask = pheno_mask * fp_one - VVp_mask

    # print("Phenotypes corrected")

    # V_sum = [TP(0) for _ in range(k + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(k + NUM_COVS)])
    # V_sum_mask = [TP(0) for _ in range(k + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(k + NUM_COVS)])
    # for i in range(k + NUM_COVS):
    #     for j in range(n1):
    #         V_sum[i] += V[i][j]
    #         V_sum_mask[i] += V_mask[i][j]

    # u = mpc.arithmetic.beaver_mult_vec(V_sum, V_sum_mask, V, V_mask)
    # u = mpc.arithmetic.beaver_reconstruct_vec(u)
    # u = mpc.fp.trunc_vec(u)
    # if mpc.pid > 0:
    #     u *= -1
    #     u = mpc.arithmetic.add_public_scalar(u, fp_one)
    # u, u_mask = mpc.arithmetic.beaver_partition_vec(u)

    # print("Allocating sx, sxx, sxp, B ... ")

    # sx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxp = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # B = [[TP(0) for _ in range(m2)] for _ in range(k + NUM_COVS)]  # Matrix(k + NUM_COVS, m2)

    # print("done.")

    # if (file_exists(get_cache_path(mpc.pid, "gwas_stats"))):
    #     print("GWAS statistics cache found")
    #     with open(get_cache_path(mpc.pid, "gwas_stats")) as f:
    #         sx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #         sxx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #         sxp = read_vector_from_cache[TP](f, m2, prime_bytes)
    #         B = read_matrix_from_cache[TP](f, k + NUM_COVS, m2, prime_bytes)
    # else:
    #     with open(get_cache_path(mpc.pid, "input_geno"), 'rb') as f:
    #         if mpc.pid > 0:
    #             # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
    #             mpc.prg.import_seed(10, 1)
    #         else:
    #             for p in range(1, 3):
    #                 # TODO: Fix. mpc.prg.import_seed(10, TP(next(f)))
    #                 mpc.prg.import_seed(10 + p, 1)

    #         bsize: int = PITER_BATCH_SIZE

    #         print("Allocating batch variables ... ")

    #         dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #         dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)

    #         u_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #         u_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #         p_hat_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #         p_hat_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])

    #         V = V.transpose()  # n1-by-(k + NUM_COVS)
    #         V_mask = V_mask.transpose()

    #         V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)
    #         V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)

    #         print("done.")

    #         gkeep3: list[bool] = [False for _ in range(m0)]
    #         for j in range(m0):
    #             gkeep3[j] = (gkeep1[j] == 1)

    #         ind = 0
    #         for j in range(m0):
    #             if gkeep3[j]:
    #                 gkeep3[j] = (gkeep2[ind] == 1)
    #                 ind += 1

    #         ind = -1
    #         for cur in range(n1):
    #             ind += 1
    #             print(f"GWAS pass {cur}:")

    #             g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]
    #             g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]
    #             miss0 = [TP(0) for _ in range(m0)]
    #             miss0_mask = [TP(0) for _ in range(m0)]

    #             while ikeep[ind] != 1:
    #                 if mpc.pid > 0:
    #                     f.read(mpc.boolean.primes_bytes[0] * 3 * m0)  # skip_data(f, 3, m0)  # g
    #                     f.read(mpc.boolean.primes_bytes[0] * m0)  # skip_data(f, m0)  # miss

    #                     mpc.prg.switch_seed(10)
    #                     g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                     miss0_mask = rand_vec(m0, BASE_P)
    #                     mpc.prg.restore_seed(10)
    #                 else:
    #                     for p in range(1, 3):
    #                         mpc.prg.switch_seed(10 + p)
    #                         g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                         miss0_mask = rand_vec(m0, BASE_P)
    #                         mpc.prg.restore_seed(10 + p)
    #                 ind += 1

    #             if mpc.pid > 0:
    #                 g0 = read_matrix_from_cache[TP](f, 3, m0, prime_bytes)  # g
    #                 miss0 = read_vector_from_cache[TP](f, m0, prime_bytes)  # miss

    #                 mpc.prg.switch_seed(10)
    #                 g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                 miss0_mask = rand_vec(m0, BASE_P)
    #                 mpc.prg.restore_seed(10)
    #             else:
    #                 g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
    #                 g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]  # Matrix(3, m0)
    #                 miss0 = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])
    #                 miss0_mask = [TP(0) for _ in range(m0)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m0)])

    #                 for p in range(1 ,3):
    #                     mpc.prg.switch_seed(10 + p)
    #                     tmp_mat = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #                     tmp_vec = rand_vec(m0, BASE_P)
    #                     mpc.prg.restore_seed(10 + p)

    #                     g0_mask += tmp_mat
    #                     miss0_mask += tmp_vec

    #             g = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #             miss = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #             g_mask = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #             miss_mask = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #             ind2: int = 0

    #             for j in range(m0):
    #                 if gkeep3[j]:
    #                     for k in range(3):
    #                         g[k][ind2] = g0[k][j]
    #                         g_mask[k][ind2] = g0_mask[k][j]

    #                     miss[ind2] = miss0[j]
    #                     miss_mask[ind2] = miss0_mask[j]
    #                     ind2 += 1

    #             # TODO: Fix. Remove break below.
    #             if cur == 15: break

    #             dosage[cur % bsize] = g[1] + g[2] * 2
    #             dosage_mask[cur % bsize] = g_mask[1] + g_mask[2] * 2

    #             u_vec[cur % bsize] = u[cur]
    #             u_mask_vec[cur % bsize] = u_mask[cur]
    #             p_hat_vec[cur % bsize] = p_hat[cur]
    #             p_hat_mask_vec[cur % bsize] = p_hat_mask[cur]

    #             V_sub[cur % bsize] = V[cur]
    #             V_mask_sub[cur % bsize] = V_mask[cur]

    #             if cur % bsize == bsize - 1:
    #                 sx = mpc.arithmetic.beaver_mult_vec(u_vec, u_mask_vec, dosage, dosage_mask)
    #                 sxp = mpc.arithmetic.beaver_mult_vec(p_hat_vec, p_hat_mask_vec, dosage, dosage_mask)

    #                 sxx_tmp = mpc.arithmetic.beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #                 for b in range(bsize):
    #                     sxx += sxx_tmp[b]

    #                 V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-bsize
    #                 V_mask_sub = V_mask_sub.transpose()
    #                 B = mpc.arithmetic.beaver_mult(V_sub, V_mask_sub, dosage, dosage_mask)

    #                 dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #                 dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #                 V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)
    #                 V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)

    #         remainder: int = n1 % bsize
    #         if remainder > 0:
    #             dosage = dosage.pad(remainder, m2)
    #             dosage_mask = dosage_mask.pad(remainder, m2)
    #             u_vec = u_vec.pad_vec(remainder)
    #             u_mask_vec = u_mask_vec.pad_vec(remainder)
    #             p_hat_vec = p_hat_vec.pad_vec(remainder)
    #             p_hat_mask_vec = p_hat_mask_vec.pad_vec(remainder)
    #             V_sub = V_sub.pad(remainder, k + NUM_COVS)
    #             V_mask_sub = V_mask_sub.pad(remainder, k + NUM_COVS)

    #             sx = mpc.arithmetic.beaver_mult_vec(u_vec, u_mask_vec, dosage, dosage_mask)
    #             sxp = mpc.arithmetic.beaver_mult_vec(p_hat_vec, p_hat_mask_vec, dosage, dosage_mask)

    #             sxx_tmp = mpc.arithmetic.beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #             for b in range(remainder):
    #                 sxx += sxx_tmp[b]

    #             V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-remainder
    #             V_mask_sub = V_mask_sub.transpose()

    #             B = mpc.arithmetic.beaver_mult(V_sub, V_mask_sub, dosage, dosage_mask)

    #         sx = mpc.arithmetic.beaver_reconstruct_vec(sx)
    #         sxp = mpc.arithmetic.beaver_reconstruct_vec(sxp)
    #         sxx = mpc.arithmetic.beaver_reconstruct_vec(sxx)
    #         B = mpc.arithmetic.beaver_reconstruct_mat(B)
    #         sxx *= fp_one
    #         sxx %= mpc.primes[0]

    #         # with open(get_cache_path(mpc.pid, "gwas_stats"), 'wb') as f:
    #         #     write_to_cache(f, sx)
    #         #     write_to_cache(f, sxx)
    #         #     write_to_cache(f, sxp)
    #         #     write_to_cache(f, B)

    #         print("Wrote results to cache")

    # B = B.transpose()  # m2-by-(k + NUM_COVS)

    # BB = mpc.arithmetic.inner_prod(B)  # m2
    # BB = mpc.fp.trunc_vec(BB)
    # if mpc.pid > 0:
    #     sxx -= BB
    # sxx %= mpc.primes[0]

    # sp = TP(0)  # Zp(0, BASE_P)
    # if mpc.pid > 0:
    #     for i in range(n1):
    #         sp += p_hat_mask[i]
    #         if mpc.pid == 1:
    #             sp += p_hat[i]
    # sp %= mpc.primes[0]

    # spp = TP(0)
    # spp = mpc.arithmetic.beaver_inner_prod(p_hat, p_hat_mask)
    # spp = mpc.arithmetic.beaver_reconstruct_elem(spp)

    # fp_n1_inv = TypeOps.double_to_fp(1.0 / n1, NBIT_K, NBIT_F)
    # sx *= fp_n1_inv
    # sp *= fp_n1_inv
    # sx %= mpc.primes[0]
    # sp %= mpc.primes[0]

    # sx = mpc.fp.trunc_vec(sx)
    # sp = mpc.fp.trunc_vec([sp])[0]
    # spp = mpc.fp.trunc_vec([spp])[0]

    # sx, sx_mask = mpc.arithmetic.beaver_partition_vec(sx)
    # sp, sp_mask = mpc.arithmetic.beaver_partition_elem(sp)

    # sp2 = TP(0)  # Zp(0, BASE_P)
    # spsx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # sx2 = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])

    # spsx = mpc.arithmetic.beaver_mult_scalar(sx, sx_mask, sp, sp_mask)
    # sp2 = mpc.arithmetic.beaver_mult(sp, sp_mask, sp, sp_mask)
    # sx2 = mpc.arithmetic.beaver_mult(sx, sx_mask, sx, sx_mask)

    # spsx = mpc.arithmetic.beaver_reconstruct_vec(spsx)
    # sp2 = mpc.arithmetic.beaver_reconstruct_elem(sp2)
    # sx2 = mpc.arithmetic.beaver_reconstruct_vec(sx2)

    # spsx *= n1
    # sp2 *= n1
    # sx2 *= n1
    # spsx %= mpc.primes[0]
    # sp2 %= mpc.primes[0]
    # sx2 %= mpc.primes[0]

    # spsx = mpc.fp.trunc_vec(spsx)
    # sp2 = mpc.fp.trunc_vec([sp2])[0]
    # sx2 = mpc.fp.trunc_vec(sx2)

    # numer = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # denom = [TP(0) for _ in range(m2 + 1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2 + 1)])
    # if mpc.pid > 0:
    #     numer = sxp - spsx
    #     for i in range(m2):
    #         denom[i] = sxx[i] - sx2[i]
    #     denom[m2] = spp - sp2
    # numer %= mpc.primes[0]
    # denom %= mpc.primes[0]

    # denom1_sqrt_inv = [TP(0) for _ in range(len(denom))]
    # if (file_exists(get_cache_path(mpc.pid, "denom_inv"))):
    #     print("denom_inv cache found")
    #     with open(get_cache_path(mpc.pid, "denom_inv")) as f:
    #         denom1_sqrt_inv = read_vector_from_cache[TP](f, len(denom), prime_bytes)
    # else:
    #     #TODO: Fix. _, denom1_sqrt_inv = mpc.fp.fp_sqrt(denom)
    #     pass
    #     # with open(get_cache_path(mpc.pid, "denom_inv"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #        write_to_cache(f, denom1_sqrt_inv)

    # denom2_sqrt_inv = denom1_sqrt_inv[m2]  # p term
    # denom1_sqrt_inv = denom1_sqrt_inv[0:m2]  # truncate

    # z = mpc.arithmetic.multiply_vec(numer, denom1_sqrt_inv)
    # z = mpc.fp.trunc_vec(z)

    # z *= denom2_sqrt_inv
    # z %= mpc.primes[0]
    # z = mpc.fp.trunc_vec(z)

    # print("Association statistics calculated")
    # z = mpc.comms.reveal_vector(z)
    # if mpc.pid == 2:
    #     z_double = TypeOps.fp_to_double_vec(z, NBIT_K, NBIT_F)
    #     # with open(get_output_path(mpc.pid, "assoc"), 'w') as f:
    #     #     for i in range(len(z_double)):
    #     #         f.write(f'{z_double[i]}\n')
    #     print("Result written to ", get_output_path(mpc.pid, "assoc"))

    # return True
