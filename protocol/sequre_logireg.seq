from os import terminal_size
from ..utils.param import *
from ..utils.type_ops import TypeOps
from ..utils.io import read_vector, read_matrix

from ..mpc.env import MPCEnv

from sequre import *


def open_input_files(mpc, test_run):
    pheno_path = (f"tests/data/input/gwas_pheno_shares_{mpc.pid}.txt" if test_run else
                  f"{GWAS_DATA_PATH}/__pheno_shares_{mpc.pid}.txt")
    cov_path = (f"tests/data/input/gwas_cov_shares_{mpc.pid}.txt" if test_run else
                f"{GWAS_DATA_PATH}/__cov_shares_{mpc.pid}.txt")
    geno_path = (f"tests/data/input/gwas_geno_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__geno_x_r.txt")
    geno_mask_path = (f"tests/data/input/gwas_geno_r_{mpc.pid}.txt" if test_run else
                      f"{GWAS_DATA_PATH}/__geno_r_{mpc.pid}.txt")
    eigen_path = (f"tests/data/input/logireg_eigen_shares_{mpc.pid}.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__eigen_shares_{mpc.pid}.txt")
    gkeep1_path = (f"tests/data/input/logireg_gkeep1.txt" if test_run else
                   f"{LOGIREG_DATA_PATH}/__gkeep1.txt")
    gkeep2_path = (f"tests/data/input/logireg_gkeep2.txt" if test_run else
                   f"{LOGIREG_DATA_PATH}/__gkeep2.txt")
    ikeep_path = (f"tests/data/input/logireg_ikeep.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__ikeep.txt")
    assoc_path = (f"tests/data/input/logireg_assoc.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__assoc.txt")
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(geno_mask_path),
            open(eigen_path),
            open(gkeep1_path),
            open(gkeep2_path),
            open(ikeep_path),
            open(assoc_path))


def table_lookup(mpc, x):
    v_0, v_1 = mpc.polynomial.table_lookup(x.share, 2)
    sv_0 = SecureValue(v_0)
    sv_1 = SecureValue(v_1)
    sv_0.fp = True
    sv_1.fp = True
    return sv_0, sv_1


@sequre_beaver
def neg_log_sigmoid(mpc, a):
    a_vec = a.flatten()
    depth = 6
    step = 4.0
    cur = a_vec.copy()
    a_ind = a_vec.zeros()

    for i in range(depth):
        cur_sign = cur > 0
        a_ind = a_ind + cur_sign * (1 << (depth - 1 - i))
        cur = cur - (2 * cur_sign - 1) * step
        step //= 2

    a_ind = a_ind + 1
    return table_lookup(mpc, a_ind)[1].reshape(a.shape())


@sequre_beaver
def parallel_logistic_regression(
        mpc, x, v, y, max_iter):
    n = len(v[0])
    eta = 0.3
    nbatch = 10
    batch_size = (n + nbatch - 1) // nbatch

    b0 = x.T[0].zeros()
    bv = mpc.matmul(x, v.T).zeros()
    bx = x.T[0].zeros()
    y_neg = 1 - y

    for it in range(max_iter):
        print(f'Logistic regression iteration {it} initialized at CP{mpc.pid}')
        batch_index = it % nbatch
        start_ind = batch_size * batch_index
        end_ind = start_ind + batch_size
        if end_ind > n: end_ind = n
        cur_bsize = end_ind - start_ind

        x_batch = x[:, start_ind:start_ind + cur_bsize]
        v_batch = v[:, start_ind:start_ind + cur_bsize]
        y_neg_batch = y_neg[start_ind:start_ind + cur_bsize]
        
        _, s_grad = neg_log_sigmoid(
            mpc, mpc.matmul(bv, v_batch) + x.to_fp() * bx + b0)

        s_grad = s_grad + y_neg_batch.to_fp()
        d0 = s_grad.T.sum()
        dx = mpc.dot(x_batch, s_grad)

        dv = mpc.matmul(s_grad * v_batch.T)

        step0 = step0 * 0.5 - d0 * eta / cur_bsize
        stepv = stepv * 0.5 - dv * eta / cur_bsize
        stepx = stepx * 0.5 - dx * eta / cur_bsize

        b0 = b0 + step0
        bv = bv + stepv
        bx = bx + stepx

    return b0, bv, bx


@sequre_beaver
def logireg_protocol(mpc, test_run = True):
    (f_pheno, f_cov, f_geno, f_geno_mask,
     f_eigen, f_gkeep1, f_gkeep2, f_ikeep,
     f_assoc) = open_input_files(test_run)     
    
    # TODO: Implemend threading. (See original implementation of this protocol)
    ntop = 100

    _, pheno, cov = read_labels(mpc, f_pheno, f_cov)
    gkeep1 = read_vector[int](f_gkeep1, NUM_SNPS)
    ikeep = read_vector[int](f_ikeep, NUM_INDS)
    n1 = sum(ikeep)
    gkeep2 = read_vector[int](f_gkeep2, NUM_SNPS)
    m2 = sum(gkeep2)
    cavec = list[tuple[int, float]](m2)
    for i, line in zip(range(m2), f_assoc):
        cavec.append((i, float(line) ** 2))
    cavec.sort(key=TypeOps.switch_pair[int, float], reverse=True)
    gkeep3 = [0 for _ in range(m2)]
    for i in range(ntop):
        gkeep3[cavec[i][0]] = 1

    pheno = [e for i, e in enumerate(pheno) if ikeep[i]]
    cov = [row for i, row in enumerate(cov) if ikeep[i]]
    V_val = read_matrix[int_t](f_eigen, NUM_DIM_TO_REDUCE_TO, n1)
    V = SecureValue[list[list[int_t]]](V_val)
    V.fp = True

    V = mpc.lin_alg.orthonormal_basis(V.extend(cov.T.to_fp()))
    V = V - V.T.sum() / len(V[0])
    V = V / mpc.sqrt(mpc.dot(V) / len(V[0]))

    gkeep = [(gkeep1[j] == 1) for j in range(NUM_SNPS)]

    ind: int = 0
    for j in range(NUM_SNPS):
        if gkeep[j]:
            gkeep[j] = (gkeep2[ind] == 1)
            ind += 1

    ind: int = 0
    for j in range(NUM_SNPS):
        if gkeep[j]:
            gkeep[j] = (gkeep3[ind] == 1)
            ind += 1
    
    _, _, X = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep, len(cov), NUM_SNPS)

    # TODO: Implement data shuffling. (See original implementation)

    b = parallel_logistic_regression(mpc, X, V, pheno, 1)
    return b[2]
