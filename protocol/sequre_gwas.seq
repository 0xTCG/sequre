from sequre import sequre_beaver

from ..utils.param import *
from ..utils.io import read_vector as read_vec, read_matrix as read_mat
from ..utils.custom_types import SecureValue

from ..stdlib.lin_alg import orthonormal_basis, eigen_decomp



def open_input_files(mpc, test_run):
    pheno_path = (f"tests/data/input/gwas_pheno_shares_{mpc.pid}.txt" if test_run else
                  f"{GWAS_DATA_PATH}/__pheno_shares_{mpc.pid}.txt")
    cov_path = (f"tests/data/input/gwas_cov_shares_{mpc.pid}.txt" if test_run else
                f"{GWAS_DATA_PATH}/__cov_shares_{mpc.pid}.txt")
    geno_path = (f"tests/data/input/gwas_geno_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__geno_x_r.txt")
    geno_mask_path = (f"tests/data/input/gwas_geno_r_{mpc.pid}.txt" if test_run else
                      f"{GWAS_DATA_PATH}/__geno_r_{mpc.pid}.txt")
    miss_path = (f"tests/data/input/gwas_miss_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__miss_x_r.txt")
    miss_mask_path = (f"tests/data/input/gwas_miss_r_{mpc.pid}.txt" if test_run else 
                      f"{GWAS_DATA_PATH}/__miss_r_{mpc.pid}.txt")
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(miss_path),
            open(geno_mask_path),
            open(miss_mask_path))


def reset_files(*files):
    for file in files:
        file.seek(0, 0)


def read_snps():
    snp_pos = []
    with open(SNP_POS_FILE) as f:
        for _, line in zip(range(NUM_SNPS), f):
            chrom, pos = line.split()
            snp_pos.append(size_u(int(chrom.strip()) * 10 ** 9 + int(pos.strip())))
    
    return SecureValue[list[size_u]](
        snp_pos, snp_pos, snp_pos.zeros(), snp_pos.zeros(),
        snp_pos.zeros(), list[list[size_u]](), False, True, False)


def read_labels(f_pheno, f_cov):
    pheno = read_vec[size_u](f_pheno, NUM_INDS)
    cov = read_mat[size_u](f_cov, NUM_INDS, NUM_COVS)

    return (
        read_snps(),
        SecureValue[list[size_u]](
            pheno, pheno, pheno.zeros(), pheno.zeros(),
            pheno.zeros(), list[list[size_u]](), False, True, False),
        SecureValue[list[list[size_u]]](
            cov, cov, cov.zeros(), cov.zeros(),
            cov.zeros(), list[list[list[size_u]]](), False, True, False))


def read_vector(mpc, f, f_mask, n):
    x_r = read_vec[size_u](f, n)
    r = read_vec[size_u](f_mask, n)
    share = (x_r + r) if mpc.pid == 2 else r

    return SecureValue[list[size_u]](
        share, x_r, r, x_r.zeros(),
        x_r.zeros(), list[list[size_u]](),
        False, False, False)


def read_matrix(mpc, f, f_mask, imask, jmask, rows, cols, offset, multiplicity = 1):
    share_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    x_r_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    r_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    
    batch_size = 0
    i = offset
    while batch_size < rows:
        if imask[i]: batch_size += 1
        for m in range(multiplicity):
            x_r = read_vec[size_u](f, cols)
            r = read_vec[size_u](f_mask, cols)
            if imask[i]:
                x_r = [x_r[j] for j in range(len(jmask)) if jmask[j]]
                r = [r[j] for j in range(len(jmask)) if jmask[j]]
                r_mats[m].append(r)
                x_r_mats[m].append(x_r)
                share_mats[m].append((x_r + r) if mpc.pid == 2 else r)
        i += 1
    
    svs = [SecureValue[list[list[size_u]]](
        share_mats[i], x_r_mats[i], r_mats[i], share_mats[i].zeros(),
        share_mats[i].zeros(), list[list[list[size_u]]](), False, False, False) for i in range(multiplicity)]

    return svs


def locus_distance_filter(snp_pos):
    selected = [0 for _ in range(len(snp_pos))]  # 1 selected, 0 unselected, -1 TBD

    prev = -1
    for i in range(len(selected)):
        if (prev < 0) or (snp_pos.share[i] - prev > LD_DIST_THRES):
            selected[i] = 1
            prev = int(snp_pos.share[i])
    
    return selected


@sequre_beaver
def load_dosage(mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
                imask, jmask, rows, cols):
    g = read_matrix(
        mpc, f_geno, f_geno_mask, imask, jmask,
        rows, cols, 0, 3)
    miss = read_matrix(
        mpc, f_miss, f_miss_mask, imask, jmask,
        rows, cols, 0)[0]
    dosage = g[1] + g[2] * 2

    return g, miss, dosage


@sequre_beaver
def quality_control(
        mpc, snp_pos, pheno, cov, f_geno,
        f_miss, f_geno_mask, f_miss_mask):
    gkeep1 = snp_pos.raw_ones()
    if not SKIP_QC:
        # n = len(snp_pos)
        # gmiss = snp_pos.zeros()
        # for _ in range(n): gmiss = gmiss + read_vector(mpc, f_miss, f_miss_mask, n)
        # gkeep1 = mpc.broadcast(gmiss < (n * GMISS_UB))
        raise NotImplementedError()

    snp_pos = snp_pos.filter(gkeep1)
    print(f"1st QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {len(pheno)}. "
          f"Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_miss, f_miss_mask)

    ikeep = pheno.raw_ones()
    if not SKIP_QC:
        # m = int(gkeep1.sum())
        # imiss = gkeep1.zeros()
        # ihet = gkeep1.zeros()

        # for i in range(len(ikeep)):
        #     g = read_matrix(mpc, f_geno, f_geno_mask, ikeep, gkeep1.ones(), 3, len(gkeep1), i * 3, 3)
        #     miss = read_vector(mpc, f_miss, f_miss_mask, len(gkeep1))

        #     for j, gk in enumerate(gkeep1):
        #         if gk:
        #             imiss[i] += miss[j]
        #             ihet[i] += g[1][j]

        # m1_obs = m - imiss
        # ihet = ihet.to_fp()
        # ikeep = mpc.broadcast(
        #     (imiss < (m * IMISS_UB)) *
        #     (ihet < (m1_obs * HET_UB)) *
        #     (ihet > (m1_obs * HET_LB)))
        raise NotImplementedError()

    pheno = pheno.filter(ikeep)
    cov = cov.filter(ikeep)
    print(f"2nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {len(pheno)}. "
          f"Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)
    
    ctrl = 1 - pheno

    n1_ctrl = int(ctrl.sum())
    g_count_ctrl = snp_pos.zeros()
    
    g, miss, dosage = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep1, len(pheno), len(gkeep1))

    gmiss = miss.sum()
    dosage_sum = dosage.sum()
    gmiss_ctrl = ctrl * miss
    dosage_sum_ctrl = ctrl * dosage
    for k in range(3): g_count_ctrl = g_count_ctrl + ctrl * g[k]
    
    dosage_tot_ctrl = (n1_ctrl - gmiss_ctrl) * 2
    maf = dosage_sum / ((len(pheno) - gmiss) * 2)
    # maf_ctrl = dosage_sum_ctrl / dosage_tot_ctrl
    # Maf_ctrl = 1 - maf_ctrl

    gkeep2 = snp_pos.raw_ones()
    if not SKIP_QC:
        # g_exp_ctrl = SecureValue[list[list[size_u]]]([[], [], []])
        # g_exp_ctrl[0] = Maf_ctrl * Maf_ctrl
        # g_exp_ctrl[1] = Maf_ctrl * maf_ctrl * 2
        # g_exp_ctrl[2] = maf_ctrl * maf_ctrl

        # g_exp_ctrl = g_exp_ctrl * dosage_tot_ctrl / 2
        # hwe_chisq = (((g_count_ctrl.to_fp() - g_exp_ctrl) ** 2) / g_exp_ctrl).sum()
        # gkeep2 = mpc.broadcast(
        #     (maf < MAF_UB) *
        #     (maf > MAF_LB) *
        #     (hwe_chisq < HWE_UB))
        raise NotImplementedError()

    g_var_bern = (maf * (1 - maf)).filter(gkeep2)
    maf = maf.filter(gkeep2)
    snp_pos = snp_pos.filter(gkeep2)
    print(f"3nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: "
          f"{len(pheno)}. Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)

    g_std_bern_inv = 1 / mpc.sqrt(g_var_bern)
    g_mean = maf * 2

    return (snp_pos, pheno, cov, g_mean,
            g_std_bern_inv, ikeep, gkeep1, gkeep2)


@sequre_beaver
def pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv,
        f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep1, gkeep2):
    selected = locus_distance_filter(snp_pos)

    # At this point "selected" contains the SNP filter for PCA, shared across all parties
    selected_snps_count = sum(selected)
    gkeep3 = [bool(e) for e in gkeep1]

    ind = 0
    for j in range(NUM_SNPS):
        if gkeep3[j]:
            gkeep3[j] = (gkeep2[ind] == 1)
            ind += 1

    ind = 0
    for j in range(NUM_SNPS):
        if gkeep3[j]:
            gkeep3[j] = (selected[ind] == 1)
            ind += 1

    _, pca_miss_mat, pca_g_mat = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep3, len(cov), NUM_SNPS)
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)

    g_mean_pca = g_mean.filter(selected)
    g_stdinv_pca = g_std_bern_inv.filter(selected)
    print(f"PCA filtering done at CP{mpc.pid}. "
        f"Number of selected individuals: "
        f"{len(cov)}. Number of selected SNPs: {selected_snps_count}.")

    # Pass 2: Random sketch
    kp = NUM_DIM_TO_REDUCE_TO + NUM_OVERSAMPLE
    Y_cur = SecureValue.zeros(kp, selected_snps_count)
    Y_cur_adj = SecureValue.zeros(kp, selected_snps_count)
    bucket_count = [0 for _ in range(kp)]

    for cur in range(len(cov)):
        # mpc.prg.switch_seed(-1)
        bucket_index = cur % kp  # __rand_int(kp + 1) - 1
        rand_sign = (cur % 2) * 2 - 1  # (__rand_int(3) - 1) * 2 - 1
        # mpc.prg.restore_seed(-1)

        # Flip miss bits so it points to places where g_mean should be subtracted
        miss = (1 - pca_miss_mat[cur]) * rand_sign
        # Update running sum
        Y_cur[bucket_index] += pca_g_mat[cur] * rand_sign
        # Update adjustment factor
        Y_cur_adj[bucket_index] += miss * g_mean_pca
        bucket_count[bucket_index] += 1

    # Subtract the adjustment factor
    Y_cur = Y_cur.to_fp() - Y_cur_adj

    # Get rid of empty buckets and normalize nonempty ones. Loop will be removed after #49 is fixed.
    for i, bc in enumerate(bucket_count): Y_cur[i] = Y_cur[i] / bc
    Y_cur.filter(bucket_count)
    kp = len(Y_cur)

    print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")
    Q = orthonormal_basis(mpc, Y_cur * g_stdinv_pca)
    pca_hit_mat = 1 - pca_miss_mat

    for pit in range(NUM_POWER_ITER + 1):
        Q_scaled = Q * g_stdinv_pca
        Q_scaled_gmean = Q_scaled * g_mean_pca

        Q = mpc.matmul(pca_g_mat, Q_scaled.T) - mpc.matmul(pca_hit_mat, Q_scaled_gmean.T)
        if pit == NUM_POWER_ITER: break

        ortho_Q = orthonormal_basis(mpc, Q.T)
        Q = orthonormal_basis(mpc,
            (mpc.matmul(ortho_Q, pca_g_mat) - mpc.matmul(ortho_Q, pca_hit_mat)
             * g_mean_pca) * g_stdinv_pca)
        print(f"Iter {pit + 1}. complete at CP{mpc.pid}.")

    print(f"Power iteration complete at CP{mpc.pid}.")

    Z = Q.T / len(snp_pos)
    U = eigen_decomp(mpc, mpc.matmul(Z, Z.T), ITER_PER_EVAL)[0][:NUM_DIM_TO_REDUCE_TO, :kp]
    V = orthonormal_basis(mpc, mpc.matmul(U, Z).extend(cov.T.to_fp()))

    print(f"Selected {NUM_DIM_TO_REDUCE_TO} eigenvectors at CP{mpc.pid}")
    return V


@sequre_beaver
def cochran_armitage(V, pheno):
    # pheno, pheno_mask = mpc.arithmetic.__beaver_partition(pheno)

    # Vp = mpc.arithmetic.__beaver_matmul(V, V_mask, [pheno].transpose(), [pheno_mask].transpose()).transpose()
    # Vp = mpc.arithmetic.__beaver_reconstruct(Vp)

    # Vp, Vp_mask = mpc.arithmetic.__beaver_partition(Vp)
    # VVp = mpc.arithmetic.__beaver_matmul(Vp, Vp_mask, V, V_mask)
    # VVp = mpc.arithmetic.__beaver_reconstruct(VVp)
    # VVp = mpc.fp.trunc(VVp)

    # VVp, VVp_mask = mpc.arithmetic.__beaver_partition(VVp)

    # p_hat = pheno * fp_one - VVp[0]
    # p_hat %= BASE_P
    # p_hat_mask = pheno_mask * fp_one - VVp_mask[0]
    # p_hat_mask %= BASE_P
    p_hat = pheno.to_fp() - mpc.matmul(V, pheno.expand_dims().T, V)[0]

    # V_sum = [TP(0) for _ in range(k + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(k + NUM_COVS)])
    # V_sum_mask = [TP(0) for _ in range(k + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(k + NUM_COVS)])
    # for i in range(k + NUM_COVS):
    #     for j in range(n1):
    #         V_sum[i] += V[i][j]
    #         V_sum_mask[i] += V_mask[i][j]
    #         V_sum[i] %= BASE_P
    #         V_sum_mask[i] %= BASE_P

    # u = mpc.arithmetic.__beaver_matmul([V_sum], [V_sum_mask], V, V_mask)[0]
    # u = mpc.arithmetic.__beaver_reconstruct(u)
    # u = mpc.fp.trunc(u)
    # if mpc.pid > 0:
    #     u *= -1
    #     u = mpc.arithmetic.add_public(u, fp_one)

    # u, u_mask = mpc.arithmetic.__beaver_partition(u)

    # sx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxp = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # B = [[TP(0) for _ in range(m2)] for _ in range(k + NUM_COVS)]  # Matrix(k + NUM_COVS, m2)

    # if (file_exists("gwas_stats")):
    #     # print("GWAS statistics cache found")
    #     # with open(get_cache_path(mpc.pid, "gwas_stats")) as f:
    #     #     sx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     sxx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     sxp = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     B = read_matrix_from_cache[TP](f, k + NUM_COVS, m2, prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     f_geno = open(geno_path)
    #     f_miss = open(miss_path)
    #     f_geno_mask = open(geno_mask_path)
    #     f_miss_mask = open(miss_mask_path)

    #     bsize: int = PITER_BATCH_SIZE

    #     print("Allocating batch variables ... ")

    #     dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #     dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)

    #     u_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     u_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     p_hat_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     p_hat_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])

    #     V = V.transpose()  # n1-by-(k + NUM_COVS)
    #     V_mask = V_mask.transpose()

    #     V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)
    #     V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)

    #     gkeep3: list[bool] = [False for _ in range(m0)]
    #     for j in range(m0):
    #         gkeep3[j] = (gkeep1[j] == 1)

    #     ind = 0
    #     for j in range(m0):
    #         if gkeep3[j]:
    #             gkeep3[j] = (gkeep2[ind] == 1)
    #             ind += 1

    #     ind = -1
    #     for cur in range(n1):
    #         ind += 1
    #         print(f"GWAS pass {cur}:")

    #         g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]
    #         g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]
    #         miss0 = [TP(0) for _ in range(m0)]
    #         miss0_mask = [TP(0) for _ in range(m0)]

    #         while ikeep[ind] != 1:
    #             raise NotImplementedError()
    #             # if mpc.pid > 0:
    #             #     f.read(mpc.boolean.primes_bytes[0] * 3 * m0)  # skip_data(f, 3, m0)  # g
    #             #     f.read(mpc.boolean.primes_bytes[0] * m0)  # skip_data(f, m0)  # miss

    #             #     mpc.prg.switch_seed(10)
    #             #     g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #             #     miss0_mask = rand_vec(m0, BASE_P)
    #             #     mpc.prg.restore_seed(10)
    #             # else:
    #             #     for p in range(1, 3):
    #             #         mpc.prg.switch_seed(10 + p)
    #             #         g0_mask = rand_mat([3, m0], BASE_P)  # Matrix(3, m0, randomise=True)
    #             #         miss0_mask = rand_vec(m0, BASE_P)
    #             #         mpc.prg.restore_seed(10 + p)
    #             # ind += 1

    #         if mpc.pid > 0:
    #             g0 = read_matrix[TP](f_geno, 3, m0)  # g
    #             miss0 = read_vector[TP](f_miss, m0)  # miss
    #         g0_mask = read_matrix[TP](f_geno_mask, 3, m0)
    #         miss0_mask = read_vector[TP](f_miss_mask, m0)

    #         g = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #         miss = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #         g_mask = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #         miss_mask = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #         ind2: int = 0

    #         for j in range(m0):
    #             if gkeep3[j]:
    #                 for k in range(3):
    #                     g[k][ind2] = g0[k][j]
    #                     g_mask[k][ind2] = g0_mask[k][j]

    #                 miss[ind2] = miss0[j]
    #                 miss_mask[ind2] = miss0_mask[j]
    #                 ind2 += 1

    #         dosage[cur % bsize] = (g[1] + (g[2] * 2) % BASE_P) % BASE_P
    #         dosage_mask[cur % bsize] = (g_mask[1] + (g_mask[2] * 2) % BASE_P) % BASE_P

    #         u_vec[cur % bsize] = u[cur]
    #         u_mask_vec[cur % bsize] = u_mask[cur]
    #         p_hat_vec[cur % bsize] = p_hat[cur]
    #         p_hat_mask_vec[cur % bsize] = p_hat_mask[cur]

    #         V_sub[cur % bsize] = V[cur]
    #         V_mask_sub[cur % bsize] = V_mask[cur]

    #         if cur % bsize == bsize - 1:
    #             sx += mpc.arithmetic.__beaver_matmul([u_vec], [u_mask_vec], dosage, dosage_mask)[0]
    #             sxp += mpc.arithmetic.__beaver_matmul([p_hat_vec], [p_hat_mask_vec], dosage, dosage_mask)[0]
    #             sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #             for b in range(bsize):
    #                 sxx += sxx_tmp[b]

    #             V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-bsize
    #             V_mask_sub = V_mask_sub.transpose()
    #             B += mpc.arithmetic.__beaver_matmul(V_sub, V_mask_sub, dosage, dosage_mask)

    #             dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #             dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #             V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)
    #             V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, k + NUM_COVS)

    #     remainder = n1 % bsize
    #     if remainder > 0:
    #         dosage = dosage.pad(remainder, m2)
    #         dosage_mask = dosage_mask.pad(remainder, m2)
    #         u_vec = u_vec.pad_vec(remainder)
    #         u_mask_vec = u_mask_vec.pad_vec(remainder)
    #         p_hat_vec = p_hat_vec.pad_vec(remainder)
    #         p_hat_mask_vec = p_hat_mask_vec.pad_vec(remainder)
    #         V_sub = V_sub.pad(remainder, k + NUM_COVS)
    #         V_mask_sub = V_mask_sub.pad(remainder, k + NUM_COVS)

    #         sx += mpc.arithmetic.__beaver_matmul([u_vec], [u_mask_vec], dosage, dosage_mask)[0]
    #         sxp += mpc.arithmetic.__beaver_matmul([p_hat_vec], [p_hat_mask_vec], dosage, dosage_mask)[0]

    #         sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #         for b in range(remainder):
    #             sxx += sxx_tmp[b]
    #             sxx %= BASE_P

    #         V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-remainder
    #         V_mask_sub = V_mask_sub.transpose()

    #         B += mpc.arithmetic.__beaver_matmul(V_sub, V_mask_sub, dosage, dosage_mask)

    #     sx = mpc.arithmetic.__beaver_reconstruct(sx)
    #     sxp = mpc.arithmetic.__beaver_reconstruct(sxp)
    #     sxx = mpc.arithmetic.__beaver_reconstruct(sxx)
    #     B = mpc.arithmetic.__beaver_reconstruct(B)
    #     sxx *= fp_one
    #     sxx %= BASE_P
    #     mpc.comms.sync_nodes()  # TODO: Remove sync

    #     # with open(get_cache_path(mpc.pid, "gwas_stats"), 'wb') as f:
    #     #     write_to_cache(f, sx)
    #     #     write_to_cache(f, sxx)
    #     #     write_to_cache(f, sxp)
    #     #     write_to_cache(f, B)

    # B = B.transpose()  # m2-by-(k + NUM_COVS)

    # BB = mpc.arithmetic.inner_prod(B)  # m2
    # BB = mpc.fp.trunc(BB)
    # if mpc.pid > 0:
    #     sxx -= BB
    # sxx %= BASE_P

    # sp = TP(0)  # Zp(0, BASE_P)
    # if mpc.pid > 0:
    #     for i in range(n1):
    #         sp += p_hat_mask[i]
    #         sp %= BASE_P
    #         if mpc.pid == 1:
    #             sp += p_hat[i]
    #             sp %= BASE_P

    # spp = TP(0)
    # spp = mpc.arithmetic.beaver_inner_prod(p_hat, p_hat_mask)
    # spp = mpc.arithmetic.__beaver_reconstruct(spp)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # fp_n1_inv = TypeOps.double_to_fp(1.0 / n1, NBIT_K, NBIT_F)
    # sx *= fp_n1_inv
    # sp *= fp_n1_inv
    # sx %= BASE_P
    # sp %= BASE_P

    # sx = mpc.fp.trunc(sx)
    # sp = mpc.fp.trunc(sp)
    # spp = mpc.fp.trunc(spp)

    # sx, sx_mask = mpc.arithmetic.__beaver_partition(sx)
    # sp, sp_mask = mpc.arithmetic.__beaver_partition(sp)

    # sp2 = TP(0)  # Zp(0, BASE_P)
    # spsx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # sx2 = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])

    # spsx = mpc.arithmetic.__beaver_mult(sx, sx_mask, sp, sp_mask)
    # sp2 = mpc.arithmetic.__beaver_mult(sp, sp_mask, sp, sp_mask)
    # sx2 = mpc.arithmetic.__beaver_mult(sx, sx_mask, sx, sx_mask)

    # mpc.comms.sync_nodes()  # TODO: Remove sync
    # spsx = mpc.arithmetic.__beaver_reconstruct(spsx)
    # sp2 = mpc.arithmetic.__beaver_reconstruct(sp2)
    # sx2 = mpc.arithmetic.__beaver_reconstruct(sx2)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # spsx *= n1
    # sp2 *= n1
    # sx2 *= n1
    # spsx %= BASE_P
    # sp2 %= BASE_P
    # sx2 %= BASE_P

    # spsx = mpc.fp.trunc(spsx)
    # sp2 = mpc.fp.trunc(sp2)
    # sx2 = mpc.fp.trunc(sx2)

    # numer = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # denom = [TP(0) for _ in range(m2 + 1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2 + 1)])
    # if mpc.pid > 0:
    #     numer = sxp - spsx
    #     for i in range(m2):
    #         denom[i] = sxx[i] - sx2[i]
    #     denom[m2] = spp - sp2
    # numer %= BASE_P
    # denom %= BASE_P

    # denom1_sqrt_inv = [TP(0) for _ in range(len(denom))]
    # if (file_exists("denom_inv")):
    #     # print("denom_inv cache found")
    #     # with open(get_cache_path(mpc.pid, "denom_inv")) as f:
    #     #     denom1_sqrt_inv = read_vector_from_cache[TP](f, len(denom), prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     _, denom1_sqrt_inv = mpc.fp.fp_sqrt(denom)
    #     # with open(get_cache_path(mpc.pid, "denom_inv"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #        write_to_cache(f, denom1_sqrt_inv)

    # denom2_sqrt_inv = denom1_sqrt_inv[m2]  # p term
    # denom1_sqrt_inv = denom1_sqrt_inv[:m2]  # truncate

    # z = mpc.arithmetic.multiply(numer, denom1_sqrt_inv)
    # z = mpc.fp.trunc(z)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # z = mpc.arithmetic.multiply(z, denom2_sqrt_inv)
    # z = mpc.fp.trunc(z)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # print(f"Association statistics calculated at CP{mpc.pid}")
    
    # return z


@sequre_beaver
def gwas_protocol(mpc, test_run):
    (f_pheno, f_cov, f_geno, f_miss,
     f_geno_mask, f_miss_mask) = open_input_files(mpc, test_run)
    snp_pos, pheno, cov = read_labels(f_pheno, f_cov)

    (snp_pos, pheno, cov, g_mean, g_std_bern_inv,
    ikeep, gkeep1, gkeep2) = quality_control(
        mpc, snp_pos, pheno, cov,
        f_geno, f_miss, f_geno_mask, f_miss_mask)

    V = pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv,
            f_geno, f_geno_mask, f_miss, f_miss_mask,
            ikeep, gkeep1, gkeep2)

    cochran_armitage(V, pheno)
