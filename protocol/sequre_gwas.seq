from sequre import sequre_beaver

from ..utils.param import *
from ..utils.io import read_vector as read_vec, read_matrix as read_mat
from ..utils.custom_types import SecureValue



def open_input_files(mpc, test_run):
    pheno_path = (f"tests/data/input/gwas_pheno_shares_{mpc.pid}.txt" if test_run else
                  f"{GWAS_DATA_PATH}/__pheno_shares_{mpc.pid}.txt")
    cov_path = (f"tests/data/input/gwas_cov_shares_{mpc.pid}.txt" if test_run else
                f"{GWAS_DATA_PATH}/__cov_shares_{mpc.pid}.txt")
    geno_path = (f"tests/data/input/gwas_geno_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__geno_x_r.txt")
    geno_mask_path = (f"tests/data/input/gwas_geno_r_{mpc.pid}.txt" if test_run else
                      f"{GWAS_DATA_PATH}/__geno_r_{mpc.pid}.txt")
    miss_path = (f"tests/data/input/gwas_miss_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__miss_x_r.txt")
    miss_mask_path = (f"tests/data/input/gwas_miss_r_{mpc.pid}.txt" if test_run else 
                      f"{GWAS_DATA_PATH}/__miss_r_{mpc.pid}.txt")
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(miss_path),
            open(geno_mask_path),
            open(miss_mask_path))


def read_snps():
    snp_pos = []
    with open(SNP_POS_FILE) as f:
        for _, line in zip(range(NUM_SNPS), f):
            chrom, pos = line.split()
            snp_pos.append(size_u(int(chrom.strip()) * 10 ** 9 + int(pos.strip())))
    
    return SecureValue[list[size_u]](
        snp_pos, snp_pos, snp_pos.zeros(), snp_pos.zeros(),
        snp_pos.zeros(), list[list[size_u]](), False, True, False)


def read_labels(f_pheno, f_cov):
    pheno = read_vec[size_u](f_pheno, NUM_INDS)
    cov = read_mat[size_u](f_cov, NUM_INDS, NUM_COVS)

    return (
        read_snps(),
        SecureValue[list[size_u]](
            pheno, pheno, pheno.zeros(), pheno.zeros(),
            pheno.zeros(), list[list[size_u]](), False, True, False),
        SecureValue[list[list[size_u]]](
            cov, cov, cov.zeros(), cov.zeros(),
            cov.zeros(), list[list[list[size_u]]](), False, True, False))


def read_vector(mpc, f, f_mask, n):
    x_r = read_vec[size_u](f, n)
    r = read_vec[size_u](f_mask, n)
    share = (x_r + r) if mpc.pid == 2 else r

    return SecureValue[list[size_u]](
        share, x_r, r, x_r.zeros(),
        x_r.zeros(), list[list[size_u]](),
        False, False, False)


def read_matrix(mpc, f, f_mask, imask, jmask, rows, cols, offset, multiplicity = 1):
    share_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    x_r_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    r_mats = [list[list[size_u]](rows * multiplicity) for _ in range(multiplicity)]
    
    batch_size = 0
    i = offset
    while batch_size < rows:
        if imask.share[i]: batch_size += 1
        for m in range(multiplicity):
            x_r = read_vec[size_u](f, cols)
            r = read_vec[size_u](f_mask, cols)
            if imask.share[i]:
                x_r = [x_r[j] for j in range(len(jmask)) if jmask[j]]
                r = [r[j] for j in range(len(jmask)) if jmask[j]]
                r_mats[m].append(r)
                x_r_mats[m].append(x_r)
                share_mats[m].append((x_r + r) if mpc.pid == 2 else r)
        i += 1
    
    svs = [SecureValue[list[list[size_u]]](
        share_mats[i], x_r_mats[i], r_mats[i], share_mats[i].zeros(),
        share_mats[i].zeros(), list[list[list[size_u]]](), False, False, False) for i in range(multiplicity)]

    return svs
        

@sequre_beaver
def quality_control(
        mpc, snp_pos, pheno, cov, f_geno,
        f_miss, f_geno_mask, f_miss_mask):
    gkeep1 = snp_pos.ones()
    if not SKIP_QC:
        # n = len(snp_pos)
        # gmiss = snp_pos.zeros()
        # for _ in range(n): gmiss = gmiss + read_vector(mpc, f_miss, f_miss_mask, n)
        # gkeep1 = mpc.broadcast(gmiss < (n * GMISS_UB))
        raise NotImplementedError()

    snp_pos = snp_pos.filter(gkeep1)
    print(f"1st QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {NUM_INDS}. "
          f"Number of selected SNPs: {int(gkeep1.sum())}.")
    f_miss.seek(0, 0)
    f_miss_mask.seek(0, 0)

    ikeep = pheno.ones()
    if not SKIP_QC:
        # m = int(gkeep1.sum())
        # imiss = gkeep1.zeros()
        # ihet = gkeep1.zeros()

        # for i in range(len(ikeep)):
        #     g = read_matrix(mpc, f_geno, f_geno_mask, ikeep, gkeep1.ones(), 3, len(gkeep1), i * 3, 3)
        #     miss = read_vector(mpc, f_miss, f_miss_mask, len(gkeep1))

        #     for j, gk in enumerate(gkeep1):
        #         if gk:
        #             imiss[i] += miss[j]
        #             ihet[i] += g[1][j]

        # m1_obs = m - imiss
        # ihet = ihet.to_fp()
        # ikeep = mpc.broadcast(
        #     (imiss < (m * IMISS_UB)) *
        #     (ihet < (m1_obs * HET_UB)) *
        #     (ihet > (m1_obs * HET_LB)))
        raise NotImplementedError()

    pheno = pheno.filter(ikeep)
    cov = cov.filter(ikeep)
    print(f"2nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {int(ikeep.sum())}. "
          f"Number of selected SNPs: {int(gkeep1.sum())}.")
    f_geno.seek(0, 0)
    f_miss.seek(0, 0)
    f_geno_mask.seek(0, 0)
    f_miss_mask.seek(0, 0)
    
    ctrl = 1 - pheno

    n1_ctrl = int(ctrl.sum())
    g_count_ctrl = snp_pos.zeros()
    
    g = read_matrix(
        mpc, f_geno, f_geno_mask, ikeep, gkeep1,
        int(ikeep.sum()), len(gkeep1), 0, 3)
    miss = read_matrix(
        mpc, f_miss, f_miss_mask, ikeep, gkeep1,
        int(ikeep.sum()), len(gkeep1), 0)[0]
    dosage = g[1] + g[2] * 2

    gmiss = miss.sum()
    dosage_sum = dosage.sum()
    gmiss_ctrl = ctrl * miss
    dosage_sum_ctrl = ctrl * dosage
    for k in range(3): g_count_ctrl = g_count_ctrl + ctrl * g[k]
    
    dosage_tot_ctrl = (n1_ctrl - gmiss_ctrl) * 2
    maf = dosage_sum / ((len(pheno) - gmiss) * 2)
    # maf_ctrl = dosage_sum_ctrl / dosage_tot_ctrl
    # Maf_ctrl = 1 - maf_ctrl

    gkeep2 = snp_pos.ones()
    if not SKIP_QC:
        # g_exp_ctrl = SecureValue[list[list[size_u]]]([[], [], []])
        # g_exp_ctrl[0] = Maf_ctrl * Maf_ctrl
        # g_exp_ctrl[1] = Maf_ctrl * maf_ctrl * 2
        # g_exp_ctrl[2] = maf_ctrl * maf_ctrl

        # g_exp_ctrl = g_exp_ctrl * dosage_tot_ctrl / 2
        # hwe_chisq = (((g_count_ctrl.to_fp() - g_exp_ctrl) ** 2) / g_exp_ctrl).sum()
        # gkeep2 = mpc.broadcast(
        #     (maf < MAF_UB) *
        #     (maf > MAF_LB) *
        #     (hwe_chisq < HWE_UB))
        raise NotImplementedError()

    g_var_bern = (maf * (1 - maf)).filter(gkeep2)
    maf = maf.filter(gkeep2)
    snp_pos = snp_pos.filter(gkeep2)
    print(f"3nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: "
          f"{int(ikeep.sum())}. Number of selected SNPs: {int(sum(gkeep2))}.")
    f_geno.seek(0, 0)
    f_miss.seek(0, 0)
    f_geno_mask.seek(0, 0)
    f_miss_mask.seek(0, 0)

    g_std_bern_inv = 1 / mpc.sqrt(g_var_bern)
    g_mean = maf * 2

    return snp_pos, pheno, cov, g_mean, g_std_bern_inv


@sequre_beaver
def gwas_protocol(mpc, test_run):
    kp = NUM_DIM_TO_REDUCE_TO + NUM_OVERSAMPLE

    (f_pheno, f_cov, f_geno, f_miss,
     f_geno_mask, f_miss_mask) = open_input_files(mpc, test_run)
    snp_pos, pheno, cov = read_labels(f_pheno, f_cov)

    snp_pos, pheno, cov, g_mean, g_std_bern_inv = quality_control(mpc,
        snp_pos, pheno, cov, f_geno, f_miss, f_geno_mask, f_miss_mask)

    # print(f"Starting population stratification analysis for {m2} elements")

    # selected = [-1 for _ in range(m2)]  # 1 selected, 0 unselected, -1 TBD
    # dist_thres = LD_DIST_THRES

    # prev = -1
    # for i in range(m2):
    #     selected[i] = 0
    #     if (prev < 0) or (snp_pos[i] - prev > dist_thres):
    #         selected[i] = 1
    #         prev = snp_pos[i]

    # # At this point "selected" contains the SNP filter for PCA, shared across all parties
    # m3 = 0
    # for i in range(len(selected)):
    #     if selected[i] == 1:
    #         m3 += 1

    # print("SNP selection complete: ", m3, " / ", m2, " selected")

    # pca_g_mat = []
    # pca_g_mask_mat = []
    # pca_miss_mat = []
    # pca_miss_mask_mat = []
    # # Cache the reduced G for PCA
    # if (file_exists("pca_input")):
    #     raise NotImplementedError()
    # else:
    #     gkeep3 = [False for _ in range(NUM_SNPS)]
    #     for j in range(NUM_SNPS):
    #         gkeep3[j] = (gkeep1[j] == 1)

    #     ind = 0
    #     for j in range(NUM_SNPS):
    #         if gkeep3[j]:
    #             gkeep3[j] = (gkeep2[ind] == 1)
    #             ind += 1

    #     ind = 0
    #     for j in range(NUM_SNPS):
    #         if gkeep3[j]:
    #             gkeep3[j] = (selected[ind] == 1)
    #             ind += 1

    #     f_geno = open(geno_path)
    #     f_miss = open(miss_path)
    #     f_geno_mask = open(geno_mask_path)
    #     f_miss_mask = open(miss_mask_path)
        
    #     bsize: int = n1 // 10

    #     ind = -1
    #     for i in range(n1):
    #         ind += 1

    #         g0 = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]  # Matrix()
    #         g0_mask = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]  # Matrix()
    #         miss0 = [TP(0) for _ in range(NUM_SNPS)]  # Vector()
    #         miss0_mask = [TP(0) for _ in range(NUM_SNPS)]  # Vector()

    #         while ikeep[ind] != 1:
    #             raise NotImplementedError()
    #             # if mpc.pid > 0:
    #             #     f_geno.read(mpc.boolean.primes_bytes[0] * 3 * NUM_SNPS)  # skip_data(f_geno, 3, NUM_SNPS)
    #             #     f_geno.read(mpc.boolean.primes_bytes[0] * NUM_SNPS)  # skip_data(f_geno, NUM_SNPS)

    #             #     mpc.prg.switch_seed(10)
    #             #     g0_mask = rand_mat([3, NUM_SNPS], BASE_P)  # Matrix(3, NUM_SNPS, randomise=True)
    #             #     miss0_mask = rand_vec(NUM_SNPS, BASE_P)
    #             #     mpc.prg.restore_seed(10)
    #             # else:
    #             #     for p in range(1, 3):
    #             #         mpc.prg.switch_seed(10 + p)
    #             #         g0_mask = rand_mat([3, NUM_SNPS], BASE_P)  # Matrix(3, NUM_SNPS, randomise=True)
    #             #         miss0_mask = rand_vec(NUM_SNPS, BASE_P)
    #             #         mpc.prg.restore_seed(10 + p)
    #             # ind += 1

    #         if mpc.pid > 0:
    #             g0 = read_matrix[TP](f_geno, 3, NUM_SNPS)
    #             miss0 = read_vector[TP](f_miss, NUM_SNPS)
    #         g0_mask = read_matrix[TP](f_geno_mask, 3, NUM_SNPS)
    #         miss0_mask = read_vector[TP](f_miss_mask, NUM_SNPS)

    #         # Filter out loci that failed missing rate filter
    #         g = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]  # Matrix(3, m3)
    #         g_mask = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]  # Matrix(3, m3)
    #         miss = [TP(0) for _ in range(NUM_SNPS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m3)])
    #         miss_mask = [TP(0) for _ in range(NUM_SNPS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m3)])
    #         ind2: int = 0
    #         for j in range(NUM_SNPS):
    #             if gkeep3[j]:
    #                 for k in range(3):
    #                     g[k][ind2] = g0[k][j]
    #                     g_mask[k][ind2] = g0_mask[k][j]
    #                 miss[ind2] = miss0[j]
    #                 miss_mask[ind2] = miss0_mask[j]
    #                 ind2 += 1

    #         dosage = (g[1] + (g[2] * 2) % BASE_P) % BASE_P
    #         dosage_mask = (g_mask[1] + (g_mask[2] * 2) % BASE_P) % BASE_P

    #         pca_g_mat.append(dosage)
    #         pca_g_mask_mat.append(dosage_mask)
    #         pca_miss_mat.append(miss)
    #         pca_miss_mask_mat.append(miss_mask)

    #     f_geno.close()
    #     f_miss.close()
    #     f_geno_mask.close()
    #     f_miss_mask.close()

    # g_mean_pca = [g_mean[i] for i in range(len(g_mean)) if selected[i]]
    # g_stdinv_pca = [g_std_bern_inv[i] for i in range(len(g_std_bern_inv)) if selected[i]]

    # g_mean_pca, g_mean_pca_mask = mpc.arithmetic.__beaver_partition(g_mean_pca)
    # g_stdinv_pca, g_stdinv_pca_mask = mpc.arithmetic.__beaver_partition(g_stdinv_pca)
    
    # # Pass 2: Random sketch
    # Y_cur = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    # if (file_exists("sketch")):
    #     # print("sketch cache found")
    #     # with open(get_cache_path(mpc.pid, "sketch")) as f:
    #     #     kp = TP(next(f))
    #     #     Y_cur = read_matrix_from_cache[TP](f, kp, m3, prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     Y_cur_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #     bucket_count = [0 for _ in range(kp)]

    #     for cur in range(n1):
    #         # Count sketch (use global PRG)
    #         mpc.prg.switch_seed(-1)
    #         bucket_index = __rand_int(kp + 1) - 1
    #         rand_sign = (__rand_int(3) - 1) * 2 - 1
    #         mpc.prg.restore_seed(-1)

    #         g = pca_g_mat[cur].copy()
    #         g_mask = pca_g_mask_mat[cur].copy()
    #         miss = pca_miss_mat[cur].copy()
    #         miss_mask = pca_miss_mask_mat[cur].copy()

    #         # Flip miss bits so it points to places where g_mean should be subtracted
    #         mpc.boolean.beaver_flip_bit(miss, miss_mask)

    #         # Update running sum
    #         if mpc.pid > 0:
    #             Y_cur[bucket_index] += g_mask * rand_sign
    #             if mpc.pid == 1:
    #                 Y_cur[bucket_index] += g * rand_sign
    #         Y_cur %= BASE_P

    #         # Update adjustment factor
    #         miss *= rand_sign
    #         miss_mask *= rand_sign
    #         Y_cur_adj[bucket_index] = mpc.arithmetic.__beaver_mult(
    #             miss, miss_mask, g_mean_pca, g_mean_pca_mask)

    #         bucket_count[bucket_index] += 1

    #     # Subtract the adjustment factor
    #     Y_cur_adj = mpc.arithmetic.__beaver_reconstruct(Y_cur_adj)
    #     if mpc.pid > 0:
    #         Y_cur = Y_cur * fp_one - Y_cur_adj
    #         Y_cur %= BASE_P
        
    #     # Get rid of empty buckets and normalize nonempty ones
    #     empty_slot = 0
    #     for i in range(kp):
    #         if bucket_count[i] > 0:
    #             fp_count_inv = TypeOps.double_to_fp(
    #                 1.0 / bucket_count[i], NBIT_K, NBIT_F)
    #             Y_cur[empty_slot] = (Y_cur[i] * fp_count_inv) % BASE_P
    #             empty_slot += 1
    #     kp = empty_slot
    #     Y_cur = Y_cur.pad(kp, m3)
    #     Y_cur = mpc.fp.trunc(Y_cur)

    #     # with open(get_cache_path(mpc.pid, "sketch"), 'wb') as f:
    #     #     write_to_cache(f, [kp])
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, Y_cur)
    
    # Y_cur, Y_cur_mask = mpc.arithmetic.__beaver_partition(Y_cur)

    # print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")

    # gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]

    # if (file_exists("piter")):
    #     # print("piter cache found")
    #     # with open(get_cache_path(mpc.pid, "piter")) as f:
    #     #     gQ = read_matrix_from_cache[TP](f, n1, kp, prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     # Divide by standard deviation
    #     Y = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #     for i in range(kp):
    #         Y[i] = mpc.arithmetic.__beaver_mult(Y_cur[i], Y_cur_mask[i], g_stdinv_pca, g_stdinv_pca_mask)

    #     Y = mpc.arithmetic.__beaver_reconstruct(Y)
    #     Y = mpc.fp.trunc(Y)

    #     # Calculate orthonormal bases of Y
    #     Q = mpc.lin_alg.orthonormal_basis(Y)

    #     # Power iteration
    #     for pit in range(NUM_POWER_ITER + 1):
    #         # This section is ran before each iteration AND once after all iterations
    #         Q, Q_mask = mpc.arithmetic.__beaver_partition(Q)

    #         # Normalize Q by standard deviations
    #         Q_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             Q_scaled[i] = mpc.arithmetic.__beaver_mult(Q[i], Q_mask[i], g_stdinv_pca, g_stdinv_pca_mask)

    #         Q_scaled = mpc.arithmetic.__beaver_reconstruct(Q_scaled)
    #         Q_scaled = mpc.fp.trunc(Q_scaled)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync

    #         Q_scaled, Q_scaled_mask = mpc.arithmetic.__beaver_partition(Q_scaled)

    #         # Pre-multiply with g_mean to simplify calculation of centering matrix
    #         Q_scaled_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             Q_scaled_gmean[i] = mpc.arithmetic.__beaver_mult(
    #                 Q_scaled[i], Q_scaled_mask[i], g_mean_pca, g_mean_pca_mask)
    #         Q_scaled_gmean = mpc.arithmetic.__beaver_reconstruct(Q_scaled_gmean)
    #         Q_scaled_gmean = mpc.fp.trunc(Q_scaled_gmean)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync

    #         Q_scaled = Q_scaled.transpose()  # m3-by-kp
    #         Q_scaled_mask = Q_scaled_mask.transpose()
    #         Q_scaled_gmean = Q_scaled_gmean.transpose()  # m3-by-kp
    #         Q_scaled_gmean, Q_scaled_gmean_mask = mpc.arithmetic.__beaver_partition(Q_scaled_gmean)

    #         bsize: int = PITER_BATCH_SIZE

    #         g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)

    #         # Pass 1
    #         gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]  # Matrix(n1, kp)
    #         gQ_adj = [[TP(0) for _ in range(kp)] for _ in range(n1)]  # Matrix(n1, kp)

    #         for cur in range(n1):
    #             g[cur % bsize] = pca_g_mat[cur].copy()
    #             g_mask[cur % bsize] = pca_g_mask_mat[cur].copy()
    #             miss[cur % bsize] = pca_miss_mat[cur].copy()
    #             miss_mask[cur % bsize] = pca_miss_mask_mat[cur].copy()
    #             mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize])

    #             if cur % bsize == bsize - 1:
    #                 tmp_mat = mpc.arithmetic.__beaver_mult(g, g_mask, Q_scaled, Q_scaled_mask)
    #                 for i in range(bsize):
    #                     gQ[cur-(bsize-1)+i] = tmp_mat[i]

    #                 tmp_mat = mpc.arithmetic.__beaver_mult(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask)
    #                 for i in range(bsize):
    #                     gQ_adj[cur-(bsize-1)+i] = tmp_mat[i]

    #         remainder = n1 % bsize
    #         if remainder > 0:
    #             g = g.pad(remainder, m3)
    #             g_mask = g_mask.pad(remainder, m3)
    #             miss = miss.pad(remainder, m3)
    #             miss_mask = miss_mask.pad(remainder, m3)

    #             tmp_mat = mpc.arithmetic.__beaver_mult(g, g_mask, Q_scaled, Q_scaled_mask)
    #             for i in range(remainder):
    #                 gQ[n1 - remainder + i] = tmp_mat[i]

    #             tmp_mat = mpc.arithmetic.__beaver_mult(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask)
    #             for i in range(remainder):
    #                 gQ_adj[n1 - remainder + i] = tmp_mat[i]
            
    #         gQ = mpc.arithmetic.__beaver_reconstruct(gQ)
    #         gQ_adj = mpc.arithmetic.__beaver_reconstruct(gQ_adj)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync
    #         if mpc.pid > 0:
    #             gQ -= gQ_adj
    #             gQ %= BASE_P

    #         if pit == NUM_POWER_ITER:  # Quit if all iterations are performed
    #             break

    #         gQ = gQ.transpose()  # kp-by-n1
    #         Q = mpc.lin_alg.orthonormal_basis(gQ)
    #         Q = Q.transpose()  # n1-by-kp

    #         Q, Q_mask = mpc.arithmetic.__beaver_partition(Q)

    #         gQ = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         gQ_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #         g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)
    #         miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]  # Matrix(bsize, m3)

    #         Qsub = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)
    #         Qsub_mask = [[TP(0) for _ in range(kp)] for _ in range(bsize)]  # Matrix(bsize, kp)

    #         # Pass 2
    #         for cur in range(n1):
    #             g[cur % bsize] = pca_g_mat[cur].copy()
    #             g_mask[cur % bsize] = pca_g_mask_mat[cur].copy()
    #             miss[cur % bsize] = pca_miss_mat[cur].copy()
    #             miss_mask[cur % bsize] = pca_miss_mask_mat[cur].copy()
    #             mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize])

    #             Qsub[cur % bsize] = Q[cur]
    #             Qsub_mask[cur % bsize] = Q_mask[cur]

    #             if cur % bsize == bsize - 1:
    #                 Qsub = Qsub.transpose()
    #                 Qsub_mask = Qsub_mask.transpose()

    #                 gQ = mpc.arithmetic.__beaver_mult(Qsub, Qsub_mask, g, g_mask)
    #                 gQ_adj = mpc.arithmetic.__beaver_mult(Qsub, Qsub_mask, miss, miss_mask)

    #                 Qsub = Qsub.pad(bsize, kp)
    #                 Qsub_mask = Qsub_mask.pad(bsize, kp)
            
    #         remainder = n1 % bsize
    #         if remainder > 0:
    #             g = g.pad(remainder, m3)
    #             g_mask = g_mask.pad(remainder, m3)
    #             miss = miss.pad(remainder, m3)
    #             miss_mask = miss_mask.pad(remainder, m3)
    #             Qsub = Qsub.pad(remainder, kp)
    #             Qsub_mask = Qsub_mask.pad(remainder, kp)

    #             Qsub = Qsub.transpose()
    #             Qsub_mask = Qsub_mask.transpose()

    #             gQ = mpc.arithmetic.__beaver_mult(Qsub, Qsub_mask, g, g_mask)
    #             gQ_adj = mpc.arithmetic.__beaver_mult(Qsub, Qsub_mask, miss, miss_mask)
            
    #         gQ = mpc.arithmetic.__beaver_reconstruct(gQ)
    #         gQ_adj = mpc.arithmetic.__beaver_reconstruct(gQ_adj)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync

    #         gQ_adj, gQ_adj_mask = mpc.arithmetic.__beaver_partition(gQ_adj)

    #         gQ_adj_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)
    #         for i in range(kp):
    #             gQ_adj_gmean[i] = mpc.arithmetic.__beaver_mult(
    #                 gQ_adj[i], gQ_adj_mask[i], g_mean_pca, g_mean_pca_mask)
    #         gQ_adj_gmean = mpc.arithmetic.__beaver_reconstruct(gQ_adj_gmean)
    #         gQ_adj_gmean = mpc.fp.trunc(gQ_adj_gmean)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync

    #         if mpc.pid > 0:
    #             gQ -= gQ_adj_gmean
    #         gQ, gQ_mask = mpc.arithmetic.__beaver_partition(gQ)

    #         gQ_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]  # Matrix(kp, m3)

    #         for i in range(kp):
    #             gQ_scaled[i] = mpc.arithmetic.__beaver_mult(gQ[i], gQ_mask[i], g_stdinv_pca, g_stdinv_pca_mask)
    #         gQ_scaled = mpc.arithmetic.__beaver_reconstruct(gQ_scaled)
    #         gQ_scaled = mpc.fp.trunc(gQ_scaled)
    #         mpc.comms.sync_nodes()  # TODO: Remove sync

    #         Q = mpc.lin_alg.orthonormal_basis(gQ_scaled)

    #         print(f"Iter {pit + 1}. complete at CP{mpc.pid}.")

    #     # with open(get_cache_path(mpc.pid, "piter"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, gQ)

    # print(f"Power iteration complete at CP{mpc.pid}.")

    # Z = gQ.copy()
    
    # print(f"Data projected to subspace at CP{mpc.pid}")
    # V = [[TP(0) for _ in range(n1)] for _ in range(NUM_DIM_TO_REDUCE_TO)]  # Matrix(NUM_DIM_TO_REDUCE_TO, n1)

    # # Eigendecomposition
    # if (file_exists("eigen")):
    #     # print("eigen cache found")
    #     # with open(get_cache_path(mpc.pid, "eigen")) as f:
    #     #     V = read_matrix_from_cache[TP](f, NUM_DIM_TO_REDUCE_TO, n1, prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     fp_m2_inv = TypeOps.double_to_fp(1.0 / m2, NBIT_K, NBIT_F)
    #     Z *= fp_m2_inv
    #     Z = mpc.fp.trunc(Z)

    #     Z = Z.transpose() # kp-by-n1

    #     Z, Z_mask = mpc.arithmetic.__beaver_partition(Z)

    #     # Form covariance matrix
    #     Z_gram = [[TP(0) for _ in range(kp)] for _ in range(kp)]  # Matrix(kp, kp)
    #     for i in range(kp):
    #         Z_gram[i] = mpc.arithmetic.__beaver_mult(Z, Z_mask, Z[i], Z_mask[i])
    #     Z_gram = mpc.arithmetic.__beaver_reconstruct(Z_gram)
    #     Z_gram = mpc.fp.trunc(Z_gram)

    #     print(f"Constructed reduced eigenvalue problem for shape {Z_gram.shape()}")

    #     U, L = mpc.lin_alg.eigen_decomp(Z_gram)

    #     print(f"Eigenvectors found at CP{mpc.pid}")

    #     # Select top eigenvectors and eigenvalues
    #     U = U.pad(NUM_DIM_TO_REDUCE_TO, kp)
    #     L = L.pad_vec(NUM_DIM_TO_REDUCE_TO)

    #     print(f"Selected {NUM_DIM_TO_REDUCE_TO} eigenvectors at CP{mpc.pid}")

    #     # Recover singular vectors
    #     U, U_mask = mpc.arithmetic.__beaver_partition(U)

    #     V = mpc.arithmetic.__beaver_mult(U, U_mask, Z, Z_mask)
    #     V = mpc.arithmetic.__beaver_reconstruct(V)
    #     V = mpc.fp.trunc(V)

    #     # with open(get_cache_path(mpc.pid, "eigen"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #         write_to_cache(f, V)

    # # Concatenate covariate matrix and jointly orthogonalize
    # cov = cov.transpose()
    # V = V.pad(NUM_DIM_TO_REDUCE_TO + NUM_COVS, n1)
    # if mpc.pid > 0:
    #     for i in range(NUM_COVS):
    #         V[NUM_DIM_TO_REDUCE_TO + i] = (cov[i] * fp_one) % BASE_P
    
    # V = mpc.lin_alg.orthonormal_basis(V)
    # V, V_mask = mpc.arithmetic.__beaver_partition(V)

    # print("Bases for top singular vectors and covariates calculated")

    # # Pass 4: Calculate GWAS statistics */
    # pheno, pheno_mask = mpc.arithmetic.__beaver_partition(pheno)

    # Vp = mpc.arithmetic.__beaver_mult(V, V_mask, pheno, pheno_mask)
    # Vp = mpc.arithmetic.__beaver_reconstruct(Vp)

    # Vp, Vp_mask = mpc.arithmetic.__beaver_partition(Vp)
    # VVp = mpc.arithmetic.__beaver_mult(Vp, Vp_mask, V, V_mask)
    # VVp = mpc.arithmetic.__beaver_reconstruct(VVp)
    # VVp = mpc.fp.trunc(VVp)

    # VVp, VVp_mask = mpc.arithmetic.__beaver_partition(VVp)

    # p_hat = pheno * fp_one - VVp
    # p_hat %= BASE_P
    # p_hat_mask = pheno_mask * fp_one - VVp_mask
    # p_hat_mask %= BASE_P

    # print("Phenotypes corrected")

    # V_sum = [TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)])
    # V_sum_mask = [TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)])
    # for i in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS):
    #     for j in range(n1):
    #         V_sum[i] += V[i][j]
    #         V_sum_mask[i] += V_mask[i][j]

    # u = mpc.arithmetic.__beaver_mult(V_sum, V_sum_mask, V, V_mask)
    # u = mpc.arithmetic.__beaver_reconstruct(u)
    # u = mpc.fp.trunc(u)
    # if mpc.pid > 0:
    #     u *= -1
    #     u = mpc.arithmetic.add_public(u, fp_one)

    # u, u_mask = mpc.arithmetic.__beaver_partition(u)

    # sx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # sxp = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, base=BASE_P) for _ in range(m2)])
    # B = [[TP(0) for _ in range(m2)] for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)]  # Matrix(NUM_DIM_TO_REDUCE_TO + NUM_COVS, m2)

    # if (file_exists("gwas_stats")):
    #     # print("GWAS statistics cache found")
    #     # with open(get_cache_path(mpc.pid, "gwas_stats")) as f:
    #     #     sx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     sxx = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     sxp = read_vector_from_cache[TP](f, m2, prime_bytes)
    #     #     B = read_matrix_from_cache[TP](f, NUM_DIM_TO_REDUCE_TO + NUM_COVS, m2, prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     f_geno = open(geno_path)
    #     f_miss = open(miss_path)
    #     f_geno_mask = open(geno_mask_path)
    #     f_miss_mask = open(miss_mask_path)

    #     bsize: int = PITER_BATCH_SIZE

    #     print("Allocating batch variables ... ")

    #     dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #     dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)

    #     u_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     u_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     p_hat_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])
    #     p_hat_mask_vec = [TP(0) for _ in range(bsize)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(bsize)])

    #     V = V.transpose()  # n1-by-(NUM_DIM_TO_REDUCE_TO + NUM_COVS)
    #     V_mask = V_mask.transpose()

    #     V_sub = [[TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, NUM_DIM_TO_REDUCE_TO + NUM_COVS)
    #     V_mask_sub = [[TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, NUM_DIM_TO_REDUCE_TO + NUM_COVS)

    #     gkeep3: list[bool] = [False for _ in range(NUM_SNPS)]
    #     for j in range(NUM_SNPS):
    #         gkeep3[j] = (gkeep1[j] == 1)

    #     ind = 0
    #     for j in range(NUM_SNPS):
    #         if gkeep3[j]:
    #             gkeep3[j] = (gkeep2[ind] == 1)
    #             ind += 1

    #     ind = -1
    #     for cur in range(n1):
    #         ind += 1
    #         print(f"GWAS pass {cur}:")

    #         g0 = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]
    #         g0_mask = [[TP(0) for _ in range(NUM_SNPS)] for _ in range(3)]
    #         miss0 = [TP(0) for _ in range(NUM_SNPS)]
    #         miss0_mask = [TP(0) for _ in range(NUM_SNPS)]

    #         while ikeep[ind] != 1:
    #             raise NotImplementedError()
    #             # if mpc.pid > 0:
    #             #     f.read(mpc.boolean.primes_bytes[0] * 3 * NUM_SNPS)  # skip_data(f, 3, NUM_SNPS)  # g
    #             #     f.read(mpc.boolean.primes_bytes[0] * NUM_SNPS)  # skip_data(f, NUM_SNPS)  # miss

    #             #     mpc.prg.switch_seed(10)
    #             #     g0_mask = rand_mat([3, NUM_SNPS], BASE_P)  # Matrix(3, NUM_SNPS, randomise=True)
    #             #     miss0_mask = rand_vec(NUM_SNPS, BASE_P)
    #             #     mpc.prg.restore_seed(10)
    #             # else:
    #             #     for p in range(1, 3):
    #             #         mpc.prg.switch_seed(10 + p)
    #             #         g0_mask = rand_mat([3, NUM_SNPS], BASE_P)  # Matrix(3, NUM_SNPS, randomise=True)
    #             #         miss0_mask = rand_vec(NUM_SNPS, BASE_P)
    #             #         mpc.prg.restore_seed(10 + p)
    #             # ind += 1

    #         if mpc.pid > 0:
    #             g0 = read_matrix[TP](f_geno, 3, NUM_SNPS)  # g
    #             miss0 = read_vector[TP](f_miss, NUM_SNPS)  # miss
    #         g0_mask = read_matrix[TP](f_geno_mask, 3, NUM_SNPS)
    #         miss0_mask = read_vector[TP](f_miss_mask, NUM_SNPS)

    #         g = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #         miss = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #         g_mask = [[TP(0) for _ in range(m2)] for _ in range(3)]  # Matrix(3, m2)
    #         miss_mask = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    #         ind2: int = 0

    #         for j in range(NUM_SNPS):
    #             if gkeep3[j]:
    #                 for k in range(3):
    #                     g[k][ind2] = g0[k][j]
    #                     g_mask[k][ind2] = g0_mask[k][j]

    #                 miss[ind2] = miss0[j]
    #                 miss_mask[ind2] = miss0_mask[j]
    #                 ind2 += 1

    #         dosage[cur % bsize] = (g[1] + (g[2] * 2) % BASE_P) % BASE_P
    #         dosage_mask[cur % bsize] = (g_mask[1] + (g_mask[2] * 2) % BASE_P) % BASE_P

    #         u_vec[cur % bsize] = u[cur]
    #         u_mask_vec[cur % bsize] = u_mask[cur]
    #         p_hat_vec[cur % bsize] = p_hat[cur]
    #         p_hat_mask_vec[cur % bsize] = p_hat_mask[cur]

    #         V_sub[cur % bsize] = V[cur]
    #         V_mask_sub[cur % bsize] = V_mask[cur]

    #         if cur % bsize == bsize - 1:
    #             sx = mpc.arithmetic.__beaver_mult(u_vec, u_mask_vec, dosage, dosage_mask)
    #             sxp = mpc.arithmetic.__beaver_mult(p_hat_vec, p_hat_mask_vec, dosage, dosage_mask)
    #             sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #             for b in range(bsize):
    #                 sxx += sxx_tmp[b]

    #             V_sub = V_sub.transpose()  # (NUM_DIM_TO_REDUCE_TO + NUM_COVS)-by-bsize
    #             V_mask_sub = V_mask_sub.transpose()
    #             B = mpc.arithmetic.__beaver_mult(V_sub, V_mask_sub, dosage, dosage_mask)

    #             dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #             dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]  # Matrix(bsize, m2)
    #             V_sub = [[TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, NUM_DIM_TO_REDUCE_TO + NUM_COVS)
    #             V_mask_sub = [[TP(0) for _ in range(NUM_DIM_TO_REDUCE_TO + NUM_COVS)] for _ in range(bsize)]  # Matrix(bsize, NUM_DIM_TO_REDUCE_TO + NUM_COVS)

    #     remainder = n1 % bsize
    #     if remainder > 0:
    #         dosage = dosage.pad(remainder, m2)
    #         dosage_mask = dosage_mask.pad(remainder, m2)
    #         u_vec = u_vec.pad_vec(remainder)
    #         u_mask_vec = u_mask_vec.pad_vec(remainder)
    #         p_hat_vec = p_hat_vec.pad_vec(remainder)
    #         p_hat_mask_vec = p_hat_mask_vec.pad_vec(remainder)
    #         V_sub = V_sub.pad(remainder, NUM_DIM_TO_REDUCE_TO + NUM_COVS)
    #         V_mask_sub = V_mask_sub.pad(remainder, NUM_DIM_TO_REDUCE_TO + NUM_COVS)

    #         sx = mpc.arithmetic.__beaver_mult(u_vec, u_mask_vec, dosage, dosage_mask)
    #         sxp = mpc.arithmetic.__beaver_mult(p_hat_vec, p_hat_mask_vec, dosage, dosage_mask)

    #         sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask)
    #         for b in range(remainder):
    #             sxx += sxx_tmp[b]
    #             sxx %= BASE_P

    #         V_sub = V_sub.transpose()  # (NUM_DIM_TO_REDUCE_TO + NUM_COVS)-by-remainder
    #         V_mask_sub = V_mask_sub.transpose()

    #         B = mpc.arithmetic.__beaver_mult(V_sub, V_mask_sub, dosage, dosage_mask)

    #     sx = mpc.arithmetic.__beaver_reconstruct(sx)
    #     sxp = mpc.arithmetic.__beaver_reconstruct(sxp)
    #     sxx = mpc.arithmetic.__beaver_reconstruct(sxx)
    #     B = mpc.arithmetic.__beaver_reconstruct(B)
    #     sxx *= fp_one
    #     sxx %= BASE_P
    #     mpc.comms.sync_nodes()  # TODO: Remove sync

    #     # with open(get_cache_path(mpc.pid, "gwas_stats"), 'wb') as f:
    #     #     write_to_cache(f, sx)
    #     #     write_to_cache(f, sxx)
    #     #     write_to_cache(f, sxp)
    #     #     write_to_cache(f, B)

    # B = B.transpose()  # m2-by-(NUM_DIM_TO_REDUCE_TO + NUM_COVS)

    # BB = mpc.arithmetic.inner_prod(B)  # m2
    # BB = mpc.fp.trunc(BB)
    # if mpc.pid > 0:
    #     sxx -= BB
    # sxx %= BASE_P

    # sp = TP(0)  # Zp(0, BASE_P)
    # if mpc.pid > 0:
    #     for i in range(n1):
    #         sp += p_hat_mask[i]
    #         sp %= BASE_P
    #         if mpc.pid == 1:
    #             sp += p_hat[i]
    #             sp %= BASE_P

    # spp = TP(0)
    # spp = mpc.arithmetic.beaver_inner_prod(p_hat, p_hat_mask)
    # spp = mpc.arithmetic.__beaver_reconstruct(spp)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # fp_n1_inv = TypeOps.double_to_fp(1.0 / n1, NBIT_K, NBIT_F)
    # sx *= fp_n1_inv
    # sp *= fp_n1_inv
    # sx %= BASE_P
    # sp %= BASE_P

    # sx = mpc.fp.trunc(sx)
    # sp = mpc.fp.trunc(sp)
    # spp = mpc.fp.trunc(spp)

    # sx, sx_mask = mpc.arithmetic.__beaver_partition(sx)
    # sp, sp_mask = mpc.arithmetic.__beaver_partition(sp)

    # sp2 = TP(0)  # Zp(0, BASE_P)
    # spsx = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # sx2 = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])

    # spsx = mpc.arithmetic.__beaver_mult(sx, sx_mask, sp, sp_mask)
    # sp2 = mpc.arithmetic.__beaver_mult(sp, sp_mask, sp, sp_mask)
    # sx2 = mpc.arithmetic.__beaver_mult(sx, sx_mask, sx, sx_mask)

    # mpc.comms.sync_nodes()  # TODO: Remove sync
    # spsx = mpc.arithmetic.__beaver_reconstruct(spsx)
    # sp2 = mpc.arithmetic.__beaver_reconstruct(sp2)
    # sx2 = mpc.arithmetic.__beaver_reconstruct(sx2)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # spsx *= n1
    # sp2 *= n1
    # sx2 *= n1
    # spsx %= BASE_P
    # sp2 %= BASE_P
    # sx2 %= BASE_P

    # spsx = mpc.fp.trunc(spsx)
    # sp2 = mpc.fp.trunc(sp2)
    # sx2 = mpc.fp.trunc(sx2)

    # numer = [TP(0) for _ in range(m2)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2)])
    # denom = [TP(0) for _ in range(m2 + 1)]  # Vector([TP(0)  # Zp(0, BASE_P) for _ in range(m2 + 1)])
    # if mpc.pid > 0:
    #     numer = sxp - spsx
    #     for i in range(m2):
    #         denom[i] = sxx[i] - sx2[i]
    #     denom[m2] = spp - sp2
    # numer %= BASE_P
    # denom %= BASE_P

    # denom1_sqrt_inv = [TP(0) for _ in range(len(denom))]
    # if (file_exists("denom_inv")):
    #     # print("denom_inv cache found")
    #     # with open(get_cache_path(mpc.pid, "denom_inv")) as f:
    #     #     denom1_sqrt_inv = read_vector_from_cache[TP](f, len(denom), prime_bytes)
    #     raise NotImplementedError()
    # else:
    #     _, denom1_sqrt_inv = mpc.fp.fp_sqrt(denom)
    #     # with open(get_cache_path(mpc.pid, "denom_inv"), 'wb') as f:
    #     #     if mpc.pid > 0:
    #     #        write_to_cache(f, denom1_sqrt_inv)

    # denom2_sqrt_inv = denom1_sqrt_inv[m2]  # p term
    # denom1_sqrt_inv = denom1_sqrt_inv[:m2]  # truncate

    # z = mpc.arithmetic.multiply(numer, denom1_sqrt_inv)
    # z = mpc.fp.trunc(z)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # z = mpc.arithmetic.multiply(numer, denom2_sqrt_inv)
    # z = mpc.fp.trunc(z)
    # mpc.comms.sync_nodes()  # TODO: Remove sync

    # print(f"Association statistics calculated at CP{mpc.pid}")

    # f_pheno.close()
    # f_cov.close()
    # f_geno.close()
    # f_miss.close()
    # f_geno_mask.close()
    # f_miss_mask.close()
    
    # return z
    return list[float]()
