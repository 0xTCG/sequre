from numpy.create import array, zeros_like, zeros, ones

from sequre.utils.io import read_matrix
from sequre.utils.stats import score_multi_classificator

from sequre.stdlib.learn.neural_net.layers import Input, Dense
from sequre.stdlib.learn.neural_net.model import Sequential
from sequre.stdlib.learn.lin_reg import LinReg

from sequre.types.multiparty_union import MPU


def genotype_imputation(mpc):
    sample_size_per_party = 512
    sample_size = (mpc.comms.number_of_parties - 1) * sample_size_per_party
    test_size = 128
    data_size = sample_size + test_size
    
    feature_rank = 32
    output_size = 1
    step_size = 0.001
    lin_reg_step_size = 1 / (1 << 13)
    epochs = 100
    
    with open("tests/data/imputation/geno_data.txt") as fx, open("tests/data/imputation/labels.txt") as fy:
        raw_X = read_matrix(fx, data_size, 31, False, TP=float)
        raw_y = read_matrix(fy, data_size, output_size, False, TP=float)

    np_X = zeros((data_size, feature_rank), dtype=float)
    np_X[:, :31] = array(raw_X)
    np_y = array(raw_y)

    training_X = np_X[:sample_size]
    training_y = np_y[:sample_size]
    test_X = np_X[sample_size:]
    test_y = np_y[sample_size:]
    
    # Raw data
    X = training_X
    y = training_y
    X_test = test_X
    y_test = test_y
    initial_w = ones((feature_rank + 1, 1))
    
    # # MPU data
    # X_partition = zeros_like(np_X) if mpc.pid == 0 else np_X[(mpc.pid - 1) * sample_size_per_party:mpc.pid * sample_size_per_party]
    # y_partition = zeros_like(np_y) if mpc.pid == 0 else np_y[(mpc.pid - 1) * sample_size_per_party:mpc.pid * sample_size_per_party]
    # X = MPU(mpc, X_partition, "partition")
    # y = MPU(mpc, y_partition, "partition")
    
    # Neural net (linear)
    layers = (
        Input[type(X)](feature_rank),
        Dense[type(X)]("linear", output_size))
    nn = Sequential(layers).compile(mpc, loss="hinge", optimizer="bgd")
    nn.fit(mpc, X=X, y=y, step=step_size, epochs=epochs, verbose=False)
    predictions = nn.predict(mpc, X_test)
    accuracy = score_multi_classificator(predictions.flatten().tolist(), y_test.flatten().tolist())
    print(f"CP{mpc.pid}:\tGenotype imputation via neural-net (linear) final test accuracy: {accuracy}")

    # Neural net (relu)
    layers = (
        Input[type(X)](feature_rank),
        Dense[type(X)]("relu", output_size))
    nn = Sequential(layers).compile(mpc, loss="hinge", optimizer="bgd")
    nn.fit(mpc, X=X, y=y, step=step_size, epochs=epochs, verbose=False)
    predictions = nn.predict(mpc, X_test)
    accuracy = score_multi_classificator(predictions.flatten().tolist(), y_test.flatten().tolist())
    print(f"CP{mpc.pid}:\tGenotype imputation via neural-net (relu) final test accuracy: {accuracy}")

    # Lin reg (BGD)
    lin_reg = LinReg(initial_w).fit(mpc, X=X, y=y, step=lin_reg_step_size, epochs=epochs)
    predictions = lin_reg.predict(mpc, X_test)
    accuracy = score_multi_classificator(predictions.flatten().tolist(), y_test.flatten().tolist())
    print(f"CP{mpc.pid}:\tGenotype imputation via lin-reg (BGD) final test accuracy: {accuracy}")

    # Lin reg (MBGD)
    lin_reg = LinReg(initial_w, "mbgd").fit(mpc, X=X, y=y, step=lin_reg_step_size, epochs=epochs)
    predictions = lin_reg.predict(mpc, X_test)
    accuracy = score_multi_classificator(predictions.flatten().tolist(), y_test.flatten().tolist())
    print(f"CP{mpc.pid}:\tGenotype imputation via lin-reg (MBGD) final test accuracy: {accuracy}")
