import math, time

from sequre.lattiseq.ckks import new_ciphertext, Ciphertext
from sequre.utils.io import read_matrix_start
from sequre.utils.utils import zeros_vec, ones, one_hot_vector


def collective_king_protocol(mpc, path, start, rows, cols, comparison_dic):
    data = read_matrix_start(open(path), rows, cols, start, TP=type(int))

    start_time = time.time()
    print("Start Protocol", mpc.pid, mpc.comms.number_of_parties)
    # exchange number of rows
    all_pids_rows = []
    for i in range(mpc.comms.number_of_parties):
        all_pids_rows.append(0)

    print(mpc.pid, len(all_pids_rows))
    for other_pid in range(1, mpc.comms.number_of_parties):
        if other_pid == mpc.pid:
            if mpc.pid > 0:
                all_pids_rows[other_pid] = rows
        else:
            if mpc.pid > 0:
                print(mpc.pid, " sends to ", other_pid)
                mpc.comms.send(rows, other_pid)
                if other_pid != 0:
                    print(mpc.pid, " receives from ", other_pid)
                    all_pids_rows[other_pid] = int(mpc.comms.receive(other_pid, T=int))
    print(mpc.pid, "finished exchanging number of rows: ", all_pids_rows)
    send_time = time.time()
    print(mpc.pid, " time to exchange rows", send_time-start_time)

    list_parties_sent = []
    print(mpc.pid, "prepares data to send to ", comparison_dic)
    for other_pid in comparison_dic:
        if mpc.pid > 0:
            if other_pid != mpc.pid:
                for j in comparison_dic[other_pid]:
                    if j == mpc.pid:
                        print(mpc.pid, " sends its data to ", other_pid)
                        list_parties_sent.append(other_pid)

                        # prepares local data to send
                        # Y
                        rows_other = all_pids_rows[other_pid]
                        y = data

                        # Compute 1 \times Y^T \cdot Y^T
                        ones_matrix = ones(rows_other, cols, TP=int)

                        yT = y.transpose()
                        yTYT = yT * yT
                        One_yTYT = ones_matrix.matmul(yTYT)
                        One_yTYT_T = One_yTYT.transpose()

                        # Compute matrix of number of ones per row (i.e., nbr of heterozygous),
                        # for denominator of king kinship coeff.
                        het_y = []
                        for i in range(rows):
                            new_count = data[i].count(1)
                            if new_count == 0:
                                new_count = 1
                            row = []
                            for _ in range(rows_other):
                                row.append(-1.0 / new_count)
                            het_y.append(row)
                        #het_yT = het_y.transpose()

                        print(mpc.pid, " starts sending")
                        # encrypt and send
                        # send y (row-wise encrypted)
                        y_encrypted = []
                        for i in range(len(y)): #TODO matrix encryption function
                            encrypted_row, _ = mpc.he.encrypt_vector(y[i])
                            y_encrypted.append(encrypted_row)
                        mpc.comms.send_as_jar(y_encrypted, other_pid)
                        print(mpc.pid, " sent y to ",  other_pid)
                        one_YTYT_encrypted = []
                        for i in range(len(ones_matrix)):
                            encrypted_row, _ = mpc.he.encrypt_vector(One_yTYT_T[i])
                            one_YTYT_encrypted.append(encrypted_row)
                        mpc.comms.send_as_jar(one_YTYT_encrypted, other_pid)
                        print(mpc.pid, " sent YTYT to ",  other_pid)

                        # send hetY (column-wise encrypted) // TODO send only vector
                        het_yT_encrypted = []
                        for i in range(len(het_y)):
                            encrypted_row, _ = mpc.he.encrypt_vector(het_y[i])
                            het_yT_encrypted.append(encrypted_row)

                        mpc.comms.send_as_jar(het_yT_encrypted, other_pid)
                        print(mpc.pid, " sent hetY to ",  other_pid)
                        localsend_time = time.time()
                        print(mpc.pid, "  time to encrypt and send ", localsend_time-send_time)
                        #after sending the data, this node is ready to help in collective operations
                        # zeros = new_ciphertext(mpc.he.crypto_params.params, 1, mpc.he.crypto_params.params.max_level(), mpc.he.crypto_params.params.default_scale)
                        # help for interactive operations
                        # # devrypt for debugging
                        # for i in range(rows_other):
                        #     for j in range(int(math.ceil(rows/mpc.he.crypto_params.params.slots()))):
                        #         result=mpc.he.decode_vector(
                        #             mpc.he.crypto_params,
                        #             [mpc.he.collective_decrypt(
                        #                 mpc.he.crypto_params,
                        #                 zeros,
                        #                 other_pid)],
                        #             DTP=float)

                        # help for sign test // TODO

                        # # help for debug again
                        # for _ in range(rows_other):
                        #     for _ in range(int(math.ceil(rows/mpc.he.crypto_params.params.slots()))):
                        #         result=mpc.he.decode_vector(
                        #             mpc.he.crypto_params,
                        #             [mpc.he.collective_decrypt(
                        #                 mpc.he.crypto_params,
                        #                 zeros,
                        #                 other_pid)],
                        #             DTP=float)
    #
    if mpc.pid == 0:
        # auxiliary party helps for SMC computations
        print(mpc.pid, " ready to help, as always")

    receive_time = time.time()
    if mpc.pid in comparison_dic:
        for other_pid in comparison_dic[mpc.pid]:
            rows_other = all_pids_rows[other_pid]
            y = mpc.comms.receive_as_jar(other_pid, list[list[Ciphertext]])
            print(mpc.pid, "received y", len(y))

            one_YTYT = mpc.comms.receive_as_jar(other_pid, list[list[Ciphertext]])
            print(mpc.pid, "received OneYTYT", len(one_YTYT), len(one_YTYT[0]))

            het_y = mpc.comms.receive_as_jar(other_pid, list[list[Ciphertext]])
            print(mpc.pid, "received hetY", len(het_y), len(het_y[0]))
            local_time = time.time()
            print(mpc.pid, "  time to receive ", local_time-receive_time)

            # prepare local data for comparison
            # X
            x = data

            # Compute X \cdot X \times 1
            ones_matrix = ones(cols, rows_other, TP=int)

            xX = x * x
            xX_one = xX.matmul(ones_matrix)
            print(xX_one)
            # compute matrix of number of ones per row (i.e., nbr of heterozygous)
            het_x = []
            for i in range(rows):
                new_count = data[i].count(1)
                if new_count == 0:
                    new_count = 1
                row = []
                for _ in range(rows_other):
                    row.append(-1.0 / new_count)
                het_x.append(row)

            # column encoded
            het_x_encoded = []
            het_xT = het_x.transpose()
            # TODO matrix encoding function
            for i in range(len(het_xT)):
                encoded_row, _ = mpc.he.encode_vector(het_xT[i])
                het_x_encoded.append(encoded_row)

            print(mpc.pid, " ready to compute distance")

            # compute kinship coefficients, XXOne - 2XYT + OneYTYT; 2XYT computed as 2YXT
            # TODO scaling matrix function
            two_X = x #.transpose()
            for r in range(len(two_X)):
                for l in range(len(two_X[0])):
                    two_X[r][l] = two_X[r][l] * (-2)

            # TODO matrix multiplication (CPMatMult4 in sfgwas-private/gwas/matrixmult.go/CPMatMult4)
            # for now, simple dot-product-based matrix multi
            matmul_time = time.time()
            print(mpc.pid, " time for local comput. ", matmul_time-local_time)
            
            # TODO mask function
            masks = [mpc.he.encode_vector(one_hot_vector(i, rows_other, TP=float))[0] for i in range(len(two_X))]
            
            # TODO create a function for this simple matrix multi approach
            two_XYT =[]
            for r_y in range(len(y)):
                # TODO function to initialize an encrypted vector of 0
                two_XYT_row, _ = mpc.he.encrypt_vector(zeros_vec(rows_other, TP=float))

                for c_two_XT in range(len(two_X)): #rows of two_X = columns of two_XT
                    twoXT_col, _ = mpc.he.encode_vector(two_X[c_two_XT])
                    mult_row_col = mpc.he.mult_plain(y[r_y],twoXT_col)

                    # TODO inner sum function for vector
                    rotate = 1
                    nbrRotations = int(math.ceil(math.log2(mpc.he.crypto_params.params.slots())))
                    # for small matrices it would be better to do #int(math.ceil(math.log2(cols)))
                    rotatedResult = mult_row_col
                    for _ in range(nbrRotations):
                        rotated = mpc.he.rotate(rotatedResult, rotate)
                        rotatedResult = mpc.he.add(rotatedResult, rotated)
                        rotate = rotate << 1

                    rotatedResult = mpc.he.mult_plain(rotatedResult, masks[c_two_XT])
                    # if small matrices approach rotatedResult = mpc.he.rotate(rotatedResult, -c_two_XT)
                    print("placed in", c_two_XT, " in row ", r_y, "/", len(y))
                    two_XYT_row = mpc.he.add(two_XYT_row, rotatedResult)
                two_XYT.append(two_XYT_row)

            aftermat_time = time.time()
            print(mpc.pid, " time for mat mult ", aftermat_time-matmul_time)

            # encode column-wise XXone
            xX_OneT = xX_one.transpose()
            xX_One_encode = []
            for i in range(len(xX)):
                encoded_row, _ = mpc.he.encode_vector(xX_OneT[i])
                xX_One_encode.append(encoded_row)


            # XXoneEncode + twoXYT + YSquare
            # TODO matrix addition function
            distance = one_YTYT
            for i in range(len(one_YTYT)):
                distance[i] = mpc.he.add(distance[i], xX_One_encode[i])
                distance[i] = mpc.he.add(distance[i], two_XYT[i])
            print(mpc.pid, " ready to debug")

            # debugging
            # # TODO matrix decrypt function
            # for i in range(len(distance)):
            #     for j in range(len(distance[0])):
            #         result=mpc.he.decode_vector(
            #             mpc.he.crypto_params,
            #             [mpc.he.collective_decrypt(
            #                 mpc.he.crypto_params,
            #                 distance[i][j],
            #                 mpc.pid)],
            #             DTP=float)
            #         print(result[:2*rows])

            min_time = time.time()
            print(mpc.pid, " time after mult before min ", min_time-aftermat_time)
            # compute minimum between hetX and hetY values for each sample comparison
            # with secret sharing (maximum of inverses) (here using MHE only might be more efficient)
            print(mpc.pid, ": start minimum computation")
            het_x_minus_het_y = []
            for i in range(len(het_x_minus_het_y)):
                het_x_minus_het_y.append(mpc.he.add(het_y[i], het_x_encoded[i]))

            ones_for_het = -ones(rows, rows_other, TP=float)
            # encode column-wise XXone
            ones_for_hetT = ones_for_het.transpose()
            ones_for_het_encode = [mpc.he.encode_vector(ones_for_hetT[i])[0] for i in range(len(xX))]

            het_x_minus_het_y_sign_enc = []
            # TODO HE matrix -> secret share and back
            for i in range(len(het_x_minus_het_y)):
                row = []
                for j in range(len(het_x_minus_het_y[0])):
                    secret_share = mpc.he.cipher_to_additive_share(het_x_minus_het_y[i][j], mpc.comms.hub_pid)
                    # TODO isPositive with secret_share
                    #het_x_minus_het_y_sign = mpc.comms.reveal(mpc.boolean.is_positive(secret_share, FIELD_SIZE))
                    ciphertext = mpc.he.additive_share_to_cipher(secret_share, mpc.comms.hub_pid)
                    row.append(ciphertext)
                het_x_minus_het_y_sign_enc.append(row)

            for i in range(len(het_x_minus_het_y_sign_enc)):
                tmp = mpc.he.add_plain(het_x_minus_het_y_sign_enc[i], ones_for_het_encode[i])
                tmp = mpc.he.mult(tmp, het_y[i])
                het_x_minus_het_y_sign_enc[i] = mpc.he.mult_plain(het_x_minus_het_y_sign_enc[i], het_x_encoded[i])
                het_x_minus_het_y_sign_enc[i] = mpc.he.add(het_x_minus_het_y_sign_enc[i], tmp)
                # R = D x H
                distance[i] = mpc.he.mult(het_x_minus_het_y_sign_enc[i], distance[i])

            decrypt_time = time.time()
            print(mpc.pid, "  time for min and final comput ", decrypt_time-min_time)

            # # debugging
            # for i in range(len(distance)):
            #     for j in range(len(distance[0])):
            #         result=mpc.he.decode_vector(
            #             mpc.he.crypto_params,
            #             [mpc.he.collective_decrypt(mpc.he.crypto_params, distance[i][j], mpc.pid)],
            #             DTP=float)
            #         print(result[:rows << 1])

            final_time = time.time()
            print(mpc.pid, "  time to decrypt ", final_time-decrypt_time)
