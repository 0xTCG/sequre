import time

from sequre.lattiseq.ckks import Ciphertext, Plaintext
from sequre.types.cipher_tensor import CipherTensor
from sequre.utils.io import read_matrix_start
from sequre.utils.utils import zeros_vec, ones


def collective_king_protocol(mpc, path, start, rows, cols, comparison_dic):
    data = read_matrix_start(open(path), rows, cols, start, TP=type(int))

    # exchange number of rows
    all_pids_rows = zeros_vec(mpc.comms.number_of_parties, TP=int)

    for other_pid in range(1, mpc.comms.number_of_parties):
        if other_pid == mpc.pid:
            if mpc.pid > 0:
                all_pids_rows[other_pid] = rows
        else:
            if mpc.pid > 0:
                mpc.comms.send_as_jar(rows, other_pid)
                if other_pid != 0:
                    all_pids_rows[other_pid] = mpc.comms.receive_as_jar(other_pid, int)
    
    if mpc.pid > 0:
        for other_pid in comparison_dic:
            if other_pid != mpc.pid:
                for j in comparison_dic[other_pid]:
                    if j == mpc.pid:
                        # prepares local data to send
                        # Y
                        rows_other = all_pids_rows[other_pid]
                        y = data

                        # Compute 1 \times Y^T \cdot Y^T
                        y_t = y.transpose()
                        one_ytyt = ones(rows_other, cols, TP=int).matmul(y_t * y_t)
                        one_ytyt_t = one_ytyt.transpose()

                        # Compute matrix of number of ones per row (i.e., nbr of heterozygous),
                        # for denominator of king kinship coeff.
                        het_y = -ones(rows, rows_other, TP=float)
                        for i in range(rows):
                            new_count = data[i].count(1)
                            if new_count: het_y[i] /= new_count

                        # encrypt and send
                        # send y (row-wise encrypted)
                        mpc.comms.send_as_jar(CipherTensor[Ciphertext].enc(mpc, y), other_pid)
                        mpc.comms.send_as_jar(CipherTensor[Ciphertext].enc(mpc, one_ytyt_t), other_pid)
                        # send hetY (column-wise encrypted) // TODO send only vector
                        mpc.comms.send_as_jar(CipherTensor[Ciphertext].enc(mpc, het_y), other_pid)

                        # after sending the data, this node is ready to help in collective operations
                        # help for sign test // TODO

    if mpc.pid in comparison_dic:
        for other_pid in comparison_dic[mpc.pid]:
            rows_other = all_pids_rows[other_pid]
            y = mpc.comms.receive_as_jar(other_pid, CipherTensor[Ciphertext])
            one_y_t_y_t = mpc.comms.receive_as_jar(other_pid, CipherTensor[Ciphertext])
            het_y = mpc.comms.receive_as_jar(other_pid, CipherTensor[Ciphertext])

            # prepare local data for comparison
            x = data
            # Compute X \cdot X \times 1
            xx_one = (x * x).matmul(ones(cols, rows_other, TP=int))

            # compute matrix of number of ones per row (i.e., nbr of heterozygous)
            het_x = -ones(rows, rows_other, TP=float)
            for i in range(rows):
                new_count = data[i].count(1)
                if new_count: het_x[i] /= new_count

            # compute kinship coefficients, XXOne - 2XYT + OneYTYT; 2XYT computed as 2YXT
            with time.timing("Matmul"):
                two_x_y_t = y.matmul(mpc, x * (-2), debug=True)

            # # compute minimum between hetX and hetY values for each sample comparison
            # # with secret sharing (maximum of inverses) (here using MHE only might be more efficient)
            # het_x_encoded = CipherTensor[Plaintext].enc(mpc, het_x.transpose())
            # het_x_minus_het_y_sign_enc = het_y.add(mpc, het_x_encoded) # TODO: ((het_y + het_x_encoded).shared_tensor() > 0).cipher_tensor()
            # a = one_y_t_y_t.add(mpc, xx_one.transpose()).add(mpc, two_x_y_t)
            # b = het_x_minus_het_y_sign_enc.mul(mpc, het_x_encoded).add(mpc, het_x_minus_het_y_sign_enc.add(mpc, -ones(rows, rows_other, TP=int).transpose()).mul(mpc, het_y))
            # distance = a.mul(mpc, b)

            # print(distance.reveal(mpc))
