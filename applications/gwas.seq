from sequre.attributes import *

from sequre.utils.param import int_t
from sequre.utils.io import read_filtered_vector, read_filtered_matrix, read_vector, read_matrix, reset_files
from sequre.types.shared_tensor import SharedTensor

from sequre.stdlib.internal import Internal as sq
from sequre.stdlib.lin_alg import orthonormal_basis, eigen_decomp

from utils.param import *
from utils.data_sharing import shares_paths


def open_input_files(mpc, test_run):
    _, pheno_path, _ = shares_paths(mpc, 'gwas', 'pheno', test_run)
    _, cov_path, _ = shares_paths(mpc, 'gwas', 'cov', test_run)
    _, geno_mask_path, geno_path = shares_paths(mpc, 'gwas', 'geno', test_run)
    _, miss_mask_path, miss_path = shares_paths(mpc, 'gwas', 'miss', test_run)
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(miss_path),
            open(geno_mask_path),
            open(miss_mask_path))


def read_snps(test_run, modulus):
    snp_pos = []
    with open(SNP_POS_TEST_FILE if test_run else SNP_POS_FILE) as f:
        for _, line in zip(range(NUM_SNPS), f):
            chrom, pos = line.split()
            snp_pos.append(int_t(int(chrom.strip()) * 10 ** 9 + int(pos.strip())))
    
    return SharedTensor[list[int_t]](
        snp_pos, snp_pos, snp_pos.zeros(), modulus, snp_pos.zeros(),
        snp_pos.zeros(), False, True, False)


def read_labels(mpc, f_pheno, f_cov, test_run, modulus):
    pheno = read_vector[int_t](f_pheno, NUM_INDS)
    cov = read_matrix[int_t](f_cov, NUM_INDS, NUM_COVS)
    pheno_x_r, pheno_r = mpc.arithmetic.__beaver_partition(pheno, modulus)
    cov_x_r, cov_r = mpc.arithmetic.__beaver_partition(cov, modulus)

    return (
        read_snps(test_run, modulus),
        SharedTensor[list[int_t]](
            pheno, pheno_x_r, pheno_r, modulus, list[int_t](),
            list[int_t](), False, False, False),
        SharedTensor[list[list[int_t]]](
            cov, cov_x_r, cov_r, modulus, list[list[int_t]](),
            list[list[int_t]](), False, False, False))


def locus_distance_filter(snp_pos):
    selected = [0 for _ in range(len(snp_pos))]  # 1 selected, 0 unselected, -1 TBD

    prev = -1
    for i in range(len(selected)):
        if (prev < 0) or (snp_pos.share[i] - prev > LD_DIST_THRES):
            selected[i] = 1
            prev = int(snp_pos.share[i])
    
    return selected


@sequre_beaver
def load_dosage(mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
                imask, jmask, rows, cols, modulus):
    g = read_filtered_matrix(
        mpc, f_geno, f_geno_mask, imask, jmask,
        rows, cols, 0, 3, modulus)
    miss = read_filtered_matrix(
        mpc, f_miss, f_miss_mask, imask, jmask,
        rows, cols, 0, 1, modulus)[0]
    dosage = g[1] + g[2] * 2

    return g, miss, dosage


@sequre_beaver
def quality_control(
        mpc, snp_pos, pheno, cov, f_geno,
        f_miss, f_geno_mask, f_miss_mask):
    modulus = pheno.modulus
    gkeep1 = snp_pos.raw_ones()
    if not SKIP_QC:
        n = len(snp_pos)
        gmiss = snp_pos.zeros()
        for _ in range(n): gmiss = gmiss + read_filtered_vector(mpc, f_miss, f_miss_mask, n, modulus)
        gkeep1 = sq.broadcast(mpc, gmiss < (n * GMISS_UB)).share

    snp_pos = snp_pos.filter(gkeep1)
    print(f"1st QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {len(pheno)}. "
          f"Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_miss, f_miss_mask)

    ikeep = pheno.raw_ones()
    if not SKIP_QC:
        m = int(sum(gkeep1))
        g, miss, _ = load_dosage(mpc, f_geno, f_geno_mask,
            f_miss, f_miss_mask, ikeep, gkeep1, len(ikeep), m, modulus)
        
        imiss = miss.T.sum()
        ihet = g[1].T.sum()

        m1_obs = m - imiss
        ihet = ihet.to_fp()
        ikeep = sq.broadcast(
            mpc,
            (imiss < (m * IMISS_UB)) *
            (ihet < (m1_obs * HET_UB)) *
            (ihet > (m1_obs * HET_LB))).share

    pheno = pheno.filter(ikeep)
    cov = cov.filter(ikeep)
    print(f"2nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {len(pheno)}. "
          f"Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)
    
    ctrl = 1 - pheno

    n1_ctrl = int(ctrl.sum())
    
    g, miss, dosage = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep1, len(pheno), len(gkeep1), modulus)

    gmiss = miss.sum()
    dosage_sum = dosage.sum()
    gmiss_ctrl = sq.matmul(mpc, ctrl.expand_dims(), miss)[0]
    dosage_sum_ctrl = sq.matmul(mpc, ctrl.expand_dims(), dosage)[0]
    g_count_ctrl = [sq.matmul(mpc, ctrl.expand_dims(), e)[0] for e in g]
    
    dosage_tot_ctrl = (n1_ctrl - gmiss_ctrl) * 2
    maf = dosage_sum / ((len(pheno) - gmiss) * 2)
    maf_ctrl = dosage_sum_ctrl / dosage_tot_ctrl
    Maf_ctrl = 1 - maf_ctrl

    gkeep2 = snp_pos.raw_ones()
    if not SKIP_QC:
        # TODO: #98 This QC does not work properly.
        g_exp_ctrl = [
            Maf_ctrl * Maf_ctrl * dosage_tot_ctrl / 2,
            Maf_ctrl * maf_ctrl * dosage_tot_ctrl,
            maf_ctrl * maf_ctrl * dosage_tot_ctrl / 2]

        hwe_chisq = sum([((e.to_fp() - g_exp_ctrl[i]) ** 2) / g_exp_ctrl[i] for i, e in enumerate(g_count_ctrl)])
        gkeep2 = sq.broadcast(
            mpc,
            (maf < MAF_UB) *
            (maf > MAF_LB) *
            (hwe_chisq < HWE_UB)).share

    g_var_bern = (maf * (1 - maf)).filter(gkeep2)
    maf = maf.filter(gkeep2)
    snp_pos = snp_pos.filter(gkeep2)
    print(f"3rd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: "
          f"{len(pheno)}. Number of selected SNPs: {len(snp_pos)}.")
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)

    g_std_bern_inv = 1 / sq.sqrt(mpc, g_var_bern)
    g_mean = maf * 2

    return (snp_pos, pheno, cov, g_mean,
            g_std_bern_inv, ikeep, gkeep1, gkeep2)


@sequre_beaver
def pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv,
        f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep1, gkeep2):
    modulus = cov.modulus
    selected = locus_distance_filter(snp_pos)

    # At this point "selected" contains the SNP filter for PCA, shared across all parties
    selected_snps_count = sum(selected)
    gkeep3 = [bool(e) for e in gkeep1]

    ind = 0
    for j in range(NUM_SNPS):
        if gkeep3[j]:
            gkeep3[j] = (gkeep2[ind] == 1)
            ind += 1

    ind = 0
    for j in range(NUM_SNPS):
        if gkeep3[j]:
            gkeep3[j] = (selected[ind] == 1)
            ind += 1

    _, pca_miss_mat, pca_g_mat = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep3, len(cov), NUM_SNPS, modulus)
    reset_files(f_geno, f_geno_mask, f_miss, f_miss_mask)

    g_mean_pca = g_mean.filter(selected)
    g_stdinv_pca = g_std_bern_inv.filter(selected)
    print(f"PCA filtering done at CP{mpc.pid}. "
        f"Number of selected individuals: "
        f"{len(cov)}. Number of selected SNPs: {selected_snps_count}.")

    # Pass 2: Random sketch
    kp = NUM_DIM_TO_REDUCE_TO + NUM_OVERSAMPLE
    Y_cur = SharedTensor.zeros(kp, selected_snps_count, modulus)
    Y_cur_adj = SharedTensor.zeros(kp, selected_snps_count, modulus)
    bucket_count = [0 for _ in range(kp)]

    for cur in range(len(cov)):
        # TODO: #151 Randomize buckets and signs in GWAS randomized PCA
        # mpc.prg.switch_seed(-1)
        bucket_index = cur % kp  # __rand_int(kp + 1) - 1
        rand_sign = (cur % 2) * 2 - 1  # (__rand_int(3) - 1) * 2 - 1
        # mpc.prg.restore_seed(-1)

        # Flip miss bits so it points to places where g_mean should be subtracted
        miss = (1 - pca_miss_mat[cur])
        if rand_sign == -1:
            miss = -miss
            Y_cur[bucket_index] += -pca_g_mat[cur]
        else: Y_cur[bucket_index] += pca_g_mat[cur]
        Y_cur_adj[bucket_index] += miss * g_mean_pca
        bucket_count[bucket_index] += 1

    # Subtract the adjustment factor
    Y_cur = Y_cur.to_fp() - Y_cur_adj

    # Get rid of empty buckets and normalize nonempty ones. Loop will be removed after #49 is fixed.
    for i, bc in enumerate(bucket_count): Y_cur[i] = Y_cur[i] / bc
    Y_cur.filter(bucket_count)
    kp = len(Y_cur)

    print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")
    Q = orthonormal_basis(mpc, Y_cur * g_stdinv_pca)
    pca_hit_mat = 1 - pca_miss_mat

    for pit in range(NUM_POWER_ITER + 1):
        Q_scaled = Q * g_stdinv_pca
        Q_scaled_gmean = Q_scaled * g_mean_pca

        Q = sq.matmul(mpc, pca_g_mat, Q_scaled.T) - sq.matmul(mpc, pca_hit_mat, Q_scaled_gmean.T)
        if pit == NUM_POWER_ITER: break

        ortho_Q = orthonormal_basis(mpc, Q.T)
        Q = orthonormal_basis(mpc,
            (sq.matmul(mpc, ortho_Q, pca_g_mat) - sq.matmul(mpc, ortho_Q, pca_hit_mat)
             * g_mean_pca) * g_stdinv_pca)
        print(f"Iter {pit + 1}. complete at CP{mpc.pid}.")

    print(f"Power iteration complete at CP{mpc.pid}.")

    Z = Q.T / len(snp_pos)
    U = eigen_decomp(mpc, sq.matmul(mpc, Z, Z.T))[0][:NUM_DIM_TO_REDUCE_TO, :kp]
    if U.modulus.popcnt() == 1: U = U.zeros()  # TODO: #129 #54 Remove this mock after support for big modulus is added
    V = orthonormal_basis(mpc, sq.matmul(mpc, U, Z).extend(cov.T.to_fp()))

    print(f"Selected {NUM_DIM_TO_REDUCE_TO} eigenvectors at CP{mpc.pid}.")
    return V, pca_g_mat


@sequre_beaver
def cochran_armitage(mpc, V, pheno, dosage):
    p_hat = pheno.expand_dims().to_fp() - sq.matmul(mpc, pheno.expand_dims(), V.T, V)
    sp = p_hat.T.sum()[0]
    sx = sq.matmul(mpc, (1 - sq.matmul(mpc, V.T.sum().expand_dims(), V)), dosage)[0]
    spp = sq.dot(mpc, p_hat[0])
    sxp = sq.matmul(mpc, p_hat, dosage)[0]
    sxx = (dosage * dosage).sum().to_fp()
    norm_sp = sp / len(pheno)
    numer = sxp - sx * norm_sp
    denom = (sxx - sq.dot(mpc, sq.matmul(mpc, V, dosage)) - sx * sx / len(pheno)) * (spp - sp * norm_sp)
    assoc = numer / sq.sqrt(mpc, denom)

    print(f"Computed associations at CP{mpc.pid}.")
    return assoc


@sequre_beaver
def gwas_protocol(mpc, test_run, modulus):
    (f_pheno, f_cov, f_geno, f_miss,
     f_geno_mask, f_miss_mask) = open_input_files(mpc, test_run)
    snp_pos, pheno, cov = read_labels(mpc, f_pheno, f_cov, test_run, modulus)

    (snp_pos, pheno, cov, g_mean, g_std_bern_inv,
    ikeep, gkeep1, gkeep2) = quality_control(
        mpc, snp_pos, pheno, cov,
        f_geno, f_miss, f_geno_mask, f_miss_mask)

    V, dosage = pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv,
                    f_geno, f_geno_mask, f_miss, f_miss_mask,
                    ikeep, gkeep1, gkeep2)
    
    return cochran_armitage(mpc, V, pheno, dosage)
