from sequre.attributes import *

from sequre.utils.param import int_t
from sequre.utils.io import read_filtered_matrix, read_vector, read_matrix, reset_files, log
from sequre.types.shared_tensor import SharedTensor

from sequre.stdlib.internal import Internal as sq
from sequre.stdlib.lin_alg import orthonormal_basis, eigen_decomp

from utils.param import *
from utils.data_sharing import shares_paths


def open_input_files(mpc, test_run):
    _, pheno_path, _ = shares_paths(mpc, 'gwas', 'pheno', test_run)
    _, cov_path, _ = shares_paths(mpc, 'gwas', 'cov', test_run)
    _, geno_mask_path, geno_path = shares_paths(mpc, 'gwas', 'geno', test_run)
    _, miss_mask_path, miss_path = shares_paths(mpc, 'gwas', 'miss', test_run)
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(miss_path),
            open(geno_mask_path),
            open(miss_mask_path))


def read_snps(test_run, modulus):
    snp_pos = []
    with open(SNP_POS_TEST_FILE if test_run else SNP_POS_FILE) as f:
        for _, line in zip(range(NUM_SNPS), f):
            chrom, pos = line.split()
            snp_pos.append(int_t(int(chrom.strip()) * 10 ** 9 + int(pos.strip())))
    
    return SharedTensor[list[int_t]](
        snp_pos, snp_pos, snp_pos.zeros(), modulus, snp_pos.zeros(),
        snp_pos.zeros(), False, True, False)


def read_labels(mpc, f_pheno, f_cov, test_run, modulus):
    pheno = read_vector[int_t](f_pheno, NUM_INDS)
    cov = read_matrix[int_t](f_cov, NUM_INDS, NUM_COVS)
    pheno_x_r, pheno_r = mpc.arithmetic.__beaver_partition(pheno, modulus)
    cov_x_r, cov_r = mpc.arithmetic.__beaver_partition(cov, modulus)

    return (
        read_snps(test_run, modulus),
        SharedTensor[list[int_t]](
            pheno, pheno_x_r, pheno_r, modulus, list[int_t](),
            list[int_t](), False, False, False),
        SharedTensor[list[list[int_t]]](
            cov, cov_x_r, cov_r, modulus, list[list[int_t]](),
            list[list[int_t]](), False, False, False))


def locus_distance_filter(snp_pos):
    selected = [0 for _ in range(len(snp_pos))]  # 1 selected, 0 unselected, -1 TBD

    prev = -1
    for i in range(len(selected)):
        if (prev < 0) or (snp_pos.share[i] - prev > LD_DIST_THRES):
            selected[i] = 1
            prev = int(snp_pos.share[i])
    
    return selected


@sequre_beaver
def load_dosage(mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
                imask, jmask, rows, cols, modulus):
    g = read_filtered_matrix(
        mpc, f_geno, f_geno_mask, imask, jmask,
        rows, cols, 0, 3, modulus)
    miss = read_filtered_matrix(
        mpc, f_miss, f_miss_mask, imask, jmask,
        rows, cols, 0, 1, modulus)[0]
    dosage = g[1] + g[2] * 2

    return g, miss, dosage


@sequre_beaver
def quality_control(
        mpc, num_inds, num_snps, snp_pos, pheno, cov, g, miss, dosage):
    gkeep1 = [int_t(1) for _ in range(num_snps)]
    if not SKIP_QC:
        gkeep1 = sq.broadcast(mpc, miss.sum() < int(num_inds * GMISS_UB)).share
    
    snp_pos = snp_pos.filter(gkeep1)
    print(f"1st QC filtering done at CP{mpc.pid}. "
          f"Number of selected SNPs: {len(snp_pos)}.")

    ikeep = [int_t(1) for _ in range(num_inds)]
    if not SKIP_QC:
        m = int(sum(gkeep1))
        imiss = miss.T.filter(gkeep1).sum()
        ihet = g[1].T.filter(gkeep1).sum()

        m1_obs = m - imiss
        ihet = ihet.to_fp()
        ikeep = sq.broadcast(
            mpc,
            (imiss < int(m * IMISS_UB)) *
            (ihet < m1_obs * HET_UB) *
            (ihet > m1_obs * HET_LB)).share
    
    pheno = pheno.filter(ikeep)
    cov = cov.filter(ikeep)
    print(f"2nd QC filtering done at CP{mpc.pid}. "
          f"Number of selected individuals: {len(pheno)}.")
    
    ctrl = 1 - pheno
    
    fitered_g = [e.filter(ikeep).T.filter(gkeep1).T for e in g]
    filtered_miss = miss.filter(ikeep).T.filter(gkeep1).T
    filtered_dosage = dosage.filter(ikeep).T.filter(gkeep1).T

    gmiss = filtered_miss.sum()
    dosage_sum = filtered_dosage.sum()
    gmiss_ctrl = sq.matmul(mpc, ctrl.expand_dims(), filtered_miss)[0]
    dosage_sum_ctrl = sq.matmul(mpc, ctrl.expand_dims(), filtered_dosage)[0]
    g_count_ctrl = [sq.matmul(mpc, ctrl.expand_dims(), e)[0] for e in fitered_g]

    dosage_tot_ctrl = (-gmiss_ctrl + ctrl.sum()) * 2
    maf = dosage_sum / ((len(pheno) - gmiss) * 2)
    maf_ctrl = dosage_sum_ctrl / dosage_tot_ctrl
    Maf_ctrl = 1 - maf_ctrl

    gkeep2 = snp_pos.raw_ones()
    if not SKIP_QC:
        g_exp_ctrl = [
            Maf_ctrl * Maf_ctrl * dosage_tot_ctrl / 2,
            Maf_ctrl * maf_ctrl * dosage_tot_ctrl,
            maf_ctrl * maf_ctrl * dosage_tot_ctrl / 2]

        hwe_chisq = sum([((e.to_fp() - g_exp_ctrl[i]) ** 2) / g_exp_ctrl[i] for i, e in enumerate(g_count_ctrl)])
        gkeep2 = sq.broadcast(
            mpc,
            (maf < MAF_UB) *
            (maf > MAF_LB) *
            (hwe_chisq < HWE_UB)).share

    g_var_bern = (maf * (1 - maf)).filter(gkeep2)
    maf = maf.filter(gkeep2)
    snp_pos = snp_pos.filter(gkeep2)
    print(f"3rd QC filtering done at CP{mpc.pid}. "
          f"Number of selected SNPs: {len(snp_pos)}.")

    g_std_bern_inv = 1 / sq.sqrt(mpc, g_var_bern)
    g_mean = maf * 2

    gkeep = [bool(e) for e in gkeep1]

    ind = 0
    for j in range(NUM_SNPS):
        if gkeep[j]:
            gkeep[j] = (gkeep2[ind] == 1)
            ind += 1

    return (snp_pos, pheno, cov, g_mean,
            g_std_bern_inv, ikeep, gkeep)


@sequre_beaver
def pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv,
        ikeep, gkeep, miss, dosage):
    modulus = cov.modulus
    selected = locus_distance_filter(snp_pos)
    pca_snp_keep_mask = gkeep.copy()

    ind = 0
    for j in range(NUM_SNPS):
        if pca_snp_keep_mask[j]:
            pca_snp_keep_mask[j] = (selected[ind] == 1)
            ind += 1
    
    selected_snps_count = pca_snp_keep_mask.to_int().sum()

    pca_miss_mat = miss.filter(ikeep).T.filter(pca_snp_keep_mask).T
    pca_g_mat = dosage.filter(ikeep).T.filter(pca_snp_keep_mask).T

    g_mean_pca = g_mean.filter(selected)
    g_stdinv_pca = g_std_bern_inv.filter(selected)
    print(f"PCA filtering done at CP{mpc.pid}. "
        f"Number of selected individuals: "
        f"{len(cov)}. Number of selected SNPs: {selected_snps_count}.")

    # Pass 2: Random sketch
    kp = NUM_DIM_TO_REDUCE_TO + NUM_OVERSAMPLE
    Y_cur = SharedTensor.zeros(kp, selected_snps_count, modulus)
    Y_cur_adj = SharedTensor.zeros(kp, selected_snps_count, modulus)
    bucket_count = [0 for _ in range(kp)]

    for cur in range(len(cov)):
        mpc.prg.switch_seed(-1)
        bucket_index = kp.rand(kp) - 1
        rand_sign = (kp.rand(2) - 1) * 2 - 1
        mpc.prg.restore_seed(-1)

        # Flip miss bits so it points to places where g_mean should be subtracted
        flip_miss = (1 - pca_miss_mat[cur])
        if rand_sign == -1:
            flip_miss = -flip_miss
            Y_cur[bucket_index] += -pca_g_mat[cur]
        else: Y_cur[bucket_index] += pca_g_mat[cur]
        Y_cur_adj[bucket_index] += flip_miss * g_mean_pca
        bucket_count[bucket_index] += 1

    # Subtract the adjustment factor
    Y_cur = Y_cur.to_fp() - Y_cur_adj

    # Get rid of empty buckets and normalize nonempty ones. Loop will be removed after #49 is fixed.
    for i, bc in enumerate(bucket_count): Y_cur[i] = Y_cur[i] / bc
    Y_cur.filter(bucket_count)
    kp = len(Y_cur)

    print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")
    Q = orthonormal_basis(mpc, Y_cur * g_stdinv_pca)
    pca_hit_mat = 1 - pca_miss_mat

    for pit in range(NUM_POWER_ITER + 1):
        Q_scaled = Q * g_stdinv_pca
        Q_scaled_gmean = Q_scaled * g_mean_pca

        Q = sq.matmul(mpc, pca_g_mat, Q_scaled.T) - sq.matmul(mpc, pca_hit_mat, Q_scaled_gmean.T)
        if pit == NUM_POWER_ITER: break

        ortho_Q = orthonormal_basis(mpc, Q.T)
        Q = orthonormal_basis(mpc,
            (sq.matmul(mpc, ortho_Q, pca_g_mat) - sq.matmul(mpc, ortho_Q, pca_hit_mat)
             * g_mean_pca) * g_stdinv_pca)
        print(f"Iter {pit + 1}. complete at CP{mpc.pid}.")

    print(f"Power iteration complete at CP{mpc.pid}.")

    Z = Q.T / len(snp_pos)
    U = eigen_decomp(mpc, sq.matmul(mpc, Z, Z.T))[0][:NUM_DIM_TO_REDUCE_TO, :kp]
    V = orthonormal_basis(mpc, sq.matmul(mpc, U, Z).extend(cov.T.to_fp()))

    print(f"Selected {NUM_DIM_TO_REDUCE_TO} eigenvectors at CP{mpc.pid}.")
    return V


@sequre_beaver
def cochran_armitage(mpc, V, pheno, dosage):
    p_hat = pheno.expand_dims().to_fp() - sq.matmul(mpc, pheno.expand_dims(), V.T, V)
    sp = p_hat.T.sum()[0]
    sx = sq.matmul(mpc, (1 - sq.matmul(mpc, V.T.sum().expand_dims(), V)), dosage)[0]
    spp = sq.dot(mpc, p_hat[0])
    sxp = sq.matmul(mpc, p_hat, dosage)[0]
    sxx = (dosage * dosage).sum().to_fp() - sq.dot(mpc, sq.matmul(mpc, V, dosage))
    norm_sp = sp / len(pheno)
    numer = sxp - sx * norm_sp
    denom = (sxx - sx * sx / len(pheno)) * (spp - sp * norm_sp)
    assoc = numer / sq.sqrt(mpc, denom)

    print(f"Computed associations at CP{mpc.pid}.")
    return assoc


@sequre_beaver
def gwas_protocol(mpc, test_run, modulus):
    (f_pheno, f_cov, f_geno, f_miss,
     f_geno_mask, f_miss_mask) = open_input_files(mpc, test_run)
    snp_pos, pheno, cov = read_labels(mpc, f_pheno, f_cov, test_run, modulus)
    g, miss, dosage = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        [int_t(1) for _ in range(NUM_INDS)],
        [int_t(1) for _ in range(NUM_SNPS)],
        NUM_INDS, NUM_SNPS, modulus)

    (snp_pos, pheno, cov, g_mean, g_std_bern_inv,
    ikeep, gwas_snp_keep_mask) = quality_control(
        mpc, NUM_INDS, NUM_SNPS, snp_pos, pheno, cov, g, miss, dosage)
    
    V = pca(mpc, snp_pos, cov, g_mean, g_std_bern_inv, ikeep, gwas_snp_keep_mask, miss, dosage)
    
    return cochran_armitage(mpc, V, pheno, dosage.filter(ikeep).T.filter(gwas_snp_keep_mask).T)
