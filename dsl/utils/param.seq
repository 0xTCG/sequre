""" Module containing all params """

# Optimizations toggles
BEAVER_CACHING: bool = True
MATRIX_OPT: bool = True
MODULUS_OPT: bool = True
PATTERN_MATHCING_OPT: bool = True

# Sequre intrinsic types
int_t = Int[128]  # 63 bit
transfer_int = i64  # 63 bit  # Must be half the size of int_t
MODULUS_BITS: int = 63  # 63 bit
FIELD_SIZE = int_t(9223372036854775783)  # 63 bit
NBIT_K: int = 40  # 63 bit
NBIT_F: int = 19  # 63 bit
NBIT_V: int = 1  # 63 bit

# int_t = i32  # 31 bit
# transfer_int = i32  # 31 bit  # Must be half the size of int_t
# MODULUS_BITS: int = 30  # 31 bit
# FIELD_SIZE = int_t(2 ** 30 - 35)  # 31 bit
# NBIT_K: int = 19  # 31 bit
# NBIT_F: int = 9  # 31 bit
# NBIT_V: int = 1  # 31 bit

# int_t = i32  # 15 bit
# transfer_int = i32  # 15 bit  # Must be half the size of int_t
# MODULUS_BITS: int = 15  # 15 bit
# FIELD_SIZE = int_t(32749)  # 15 bit
# NBIT_K: int = 10  # 15 bit
# NBIT_F: int = 3  # 15 bit
# NBIT_V: int = 1  # 15 bit

transfer_int_small = i8  # Must be one byte, as none of the small fields should exceed 128
list_u32 = array[u32]

SECOND_FIELD_SIZE = 23
THIRD_FIELD_SIZE = 11
SECOND_RING_SIZE = 16

RING_SIZE = int_t(1) << MODULUS_BITS
RING_MASK = RING_SIZE - 1
MOD_CONST = int_t.get_mod_const(FIELD_SIZE)
SECOND_MOD_CONST = int.get_mod_const(SECOND_FIELD_SIZE)
THIRD_MOD_CONST = int.get_mod_const(THIRD_FIELD_SIZE)
assert RING_SIZE.popcnt() == 1, "Ring size not a power of 2."
assert FIELD_SIZE < RING_SIZE, f"Ring size should be larger than field size. Your ring size: {RING_SIZE}, and field size: {FIELD_SIZE}."
assert SECOND_FIELD_SIZE < typeof(SECOND_FIELD_SIZE)(128)
assert THIRD_FIELD_SIZE < typeof(THIRD_FIELD_SIZE)(128)
print(f'Field size: {FIELD_SIZE}. Ring size: {RING_SIZE}')

# Ports
# The party with smaller ID listens on the port
# and the other connects to it. Make sure the firewall
# setting of the listener allows these ports.
PORT_P0_P1: int = 8001
PORT_P0_P2: int = PORT_P0_P1 + 1
PORT_P1_P2: int = PORT_P0_P2 + 1
ALL_PORTS: list[int] = [PORT_P0_P1, PORT_P0_P2, PORT_P1_P2]

# Socket
# BUFFER_SIZE: int = 1 << 10
AF_PREFIX: str = "sock."
AF_UNIX: int = 1
SOCK_STREAM: int = 1
SHUT_RDWR: int = 2
P0_P1_SOCKET_PATH: str = f'{AF_PREFIX}{PORT_P0_P1}'
P0_P2_SOCKET_PATH: str = f'{AF_PREFIX}{PORT_P0_P2}'
P1_P2_SOCKET_PATH: str = f'{AF_PREFIX}{PORT_P1_P2}'

# GWAS
ITER_PER_EVAL: int = 5

NUM_INDS: int = 1000
NUM_SNPS: int = 1000
NUM_COVS: int = 10
NUM_DIM_TO_REDUCE_TO: int = 5

NUM_OVERSAMPLE: int = 5
NUM_POWER_ITER: int = 10

SIGMOID_APPROX_PATH: str = 'data/sigmoid_approx.txt'

IMISS_UB: float = 0.05
GMISS_UB: float = 0.1
HET_LB: float = 0.25
HET_UB: float = 0.30
MAF_LB: float = 0.4
MAF_UB: float = 0.6
HWE_UB: float = 28.3740
LD_DIST_THRES: int = 1
DIV_MAX_N: int = 100000

PITER_BATCH_SIZE: int = 100
PAR_THRES: int = 50
NUM_THREADS: int = 20

SKIP_QC: bool = True
LOGIREG_ITER: int = 1
MATMUL_LEAF_SIZE: int = 64

# Neural net params
FEATURE_RANK: int = 6903
MOMENTUM: float = 0.9
LEARN_RATE: float = 0.2
N_CLASSES: int = 2
N_HIDDEN: int = 1
REG: float = 0.0
DROPOUT: int = 0
LOSS: str = "hinge"
N_NEURONS: int = 100
NN_BATCH_SIZE: int = 50
MAX_EPOCHS: int = 10
N_FILE_BATCH: int = 150
