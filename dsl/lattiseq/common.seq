BIG_INT_LEN: Static[int] = 384


@extend
class int:
    @llvm
    def bit_reverse(self: int) -> int:
        declare i64 @llvm.bitreverse.i64(i64)
        %0 = call i64 @llvm.bitreverse.i64(i64 %self)
        ret i64 %0
    def bit_reverse_subset(self: int, bitlen: int) -> int:
	    return self.bit_reverse() >> (64 - bitlen)


@extend
class UInt:
    @llvm
    def __new__(other: UInt[1]) -> UInt[N]:
        %0 = zext i1 %other to i{=N}
        ret i{=N} %0
    @llvm
    def __new__(other: bool) -> UInt[N]:
        %0 = zext i8 %other to i{=N}
        ret i{=N} %0
    @llvm
    def raw_add_overflow(self: UInt[N], other: UInt[N]) -> tuple[UInt[N], UInt[1]]:
        declare {i{=N}, i1} @llvm.uadd.with.overflow.i{=N}(i{=N}, i{=N})
        %res = call {i{=N}, i1} @llvm.uadd.with.overflow.i{=N}(i{=N} %self, i{=N} %other)
        ret {i{=N}, i1} %res
    @llvm
    def bit_reverse(self: UInt[N]) -> UInt[N]:
        declare i{=N} @llvm.bitreverse.i{=N}(i{=N})
        %0 = call i{=N} @llvm.bitreverse.i{=N}(i{=N} %self)
        ret i{=N} %0
    def bit_reverse_subset(self: UInt[N], bitlen: int) -> UInt[N]:
        return self.bit_reverse() >> UInt[N](N - bitlen)
    def mul_overflow(self: UInt[N], other: UInt[N]) -> tuple[UInt[N], UInt[N]]:
        #TODO: Implement faster solution
        p = self.ext_double() * other.ext_double()
        return (p >> UInt[N * 2](N)).trunc_half(), p.trunc_half()
    def add_overflow(self: UInt[N], other: UInt[N]) -> tuple[UInt[N], UInt[N]]:
        s, overflow = self.raw_add_overflow(other)
        return s, UInt[N](overflow)
    def setbit(self: UInt[N], idx: int, value: int) -> UInt[N]:
        mask = (UInt[N](1) << UInt[N](idx))
        if value == 1: self |= mask
        elif value == 0: self &= (mask ^ UInt[N](-1))
        else: raise ValueError("Invalid bit value")
        return self
    def getbit(self: UInt[N], idx: int) -> int:
        return (self & (UInt[N](1) << UInt[N](idx))).popcnt()
    def udiv_naive(self: UInt[N], other: UInt[N]) -> tuple[UInt[N], UInt[N]]:
        Q = UInt[N](0)
        R = UInt[N](0)
        for i in range(int(self.bitlen()), -1, -1):
            R <<= UInt[N](1)
            # self_i = (self >> UInt[N](i)) & UInt[N](1)  # 1st way
            # R ^= (-self_i ^ R) & UInt[N](1)  # 1st way
            # R = R.setbit(0, self.getbit(i))  # 2nd way
            if self.getbit(i): R |= UInt[N](1)
            if R >= other:
                R -= other
                # Q ^= (UInt[N](-1) ^ Q) & (UInt[N](1) << UInt[N](i)) # 1st way
                # Q = Q.setbit(i, 1)  # 2nd way
                Q |= (UInt[N](1) << UInt[N](i))
        return Q, R
    # @llvm
    def bigint_floordiv(self: UInt[N], other: UInt[N]) -> UInt[N]:
        q, _ = self.udiv_naive(other)
        return q
    # @llvm
    def bigint_mod(self: UInt[N], other: UInt[N]) -> UInt[N]:
        _, r = self.udiv_naive(other)
        return r
    @llvm
    def trunc_half(self: UInt[N]) -> UInt[N // 2]:
        %0 = trunc i{=N} %self to i{=N//2}
        ret i{=N//2} %0
    @llvm
    def trunc_to_u64(self: UInt[N]) -> u64:
        %0 = trunc i{=N} %self to i64
        ret i64 %0
    @llvm
    def ext_double(self: UInt[N]) -> UInt[N * 2]:
        %0 = zext i{=N} %self to i{=N*2}
        ret i{=N*2} %0
    @llvm
    def ext_to_bigint(self: UInt[N]) -> UInt[BIG_INT_LEN]:
        %0 = zext i{=N} %self to i{=BIG_INT_LEN}
        ret i{=BIG_INT_LEN} %0
    def split_lo_hi(self: UInt[N]) -> tuple[UInt[N], UInt[N]]:
        self_lo = self & UInt[N // 2](-1).ext_double()
        self_hi = self >> UInt[N](N // 2)
        return self_hi, self_lo
    def mul_mod_via_ext(self: UInt[BIG_INT_LEN], other: UInt[BIG_INT_LEN], mod: UInt[BIG_INT_LEN]) -> UInt[BIG_INT_LEN]:
        # self_hi, self_lo = self.split_lo_hi()
        # other_hi, other_lo = other.split_lo_hi()

        # ll = self_lo * other_lo
        # hl = self_hi * other_lo
        # lh = self_lo * other_hi
        # hh = self_hi * other_hi

        # hh_factor = (UInt[BIG_INT_LEN](1) << UInt[BIG_INT_LEN](BIG_INT_LEN)).bigint_mod(mod)
        # hl_factor = (UInt[BIG_INT_LEN](1) << UInt[BIG_INT_LEN](BIG_INT_LEN // 2)).bigint_mod(mod)

        # first_term = hh.bigint_mod(mod) * hh_factor

        # second_term = (hl.bigint_mod(mod) + lh.bigint_mod(mod)).bigint_mod(mod) * hl_factor

        # return (first_term.bigint_mod(mod) + second_term.bigint_mod(mod) + ll.bigint_mod(mod)).bigint_mod(mod)
        m = self.ext_double() * other.ext_double()
        mo = m.bigint_mod(mod.ext_double())
        return mo.trunc_half()
    def big_pow_mod(self: UInt[BIG_INT_LEN], power: UInt[BIG_INT_LEN], mod: UInt[BIG_INT_LEN]) -> UInt[BIG_INT_LEN]:
        if power == UInt[BIG_INT_LEN](0): return UInt[BIG_INT_LEN](1)
        if self == UInt[BIG_INT_LEN](0): return UInt[BIG_INT_LEN](0)
        number = UInt[BIG_INT_LEN](1)
        
        while power:
            if power & UInt[BIG_INT_LEN](1):
                number = number.mul_mod_via_ext(self, mod)
            power >>= UInt[BIG_INT_LEN](1)
            self = self.mul_mod_via_ext(self, mod)
        
        return number
    def mod_inv(self: UInt[BIG_INT_LEN], prime: UInt[BIG_INT_LEN]) -> UInt[BIG_INT_LEN]:
        return self.big_pow_mod(prime - UInt[BIG_INT_LEN](2), prime)
    def __str__(self: UInt[N]) -> str:
        self_cp = self
        int_str = ''
        while self_cp:
            remainder = 0
            quotient = UInt[N](0)
            # Euclidean division
            for bit_idx in range(N - 1, -1, -1):
                mask = int((self_cp & (UInt[N](1) << UInt[N](bit_idx))) != UInt[N](0))
                remainder = (remainder << 1) + mask
                if remainder >= 10:
                    quotient = (quotient << UInt[N](1)) + UInt[N](1)
                    remainder -= 10
                else: quotient = quotient << UInt[N](1)
            int_str = str(remainder) + int_str
            self_cp = quotient
        return int_str if int_str else '0'


big_uint = UInt[BIG_INT_LEN]
