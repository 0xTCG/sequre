"""
Ported from https://github.com/tuneinsight/lattigo/tree/master/ring
"""

import ring


# Poly represents a polynomial in the ring of polynomial modulo q*p.
# This type is simply the union type between two ring.Poly, each one
# containing the modulus q and p coefficients of that polynomial.
# The modulus q represent the ciphertext modulus and the modulus p
# the special primes for the RNS decomposition during homomorphic
# operations involving keys.
class Poly:
    q: ring.Poly
    p: ring.Poly

    def __str__(self):
        return f"""\tQPPolynomial:
                \tQ: {self.q}
                \tP: {self.p}
        """

    # level_q returns the level of the polynomial modulo q.
    # Returns -1 if the modulus q is absent.
    def level_q(self):
        if self.q: return self.q.level()
        return -1
    
    # level_p returns the level of the polynomial modulo p.
    # Returns -1 if the modulus p is absent.
    def level_p(self):
        if self.p: return self.p.level()
        return -1


# Ring is a structure that implements the operation in the ring R_QP.
# This type is simply a union type between the two Ring types representing
# R_Q and R_P.
class Ring:
    ring_q: ring.Ring
    ring_p: ring.Ring

    def __init__(self, ring_q, ring_p):
        self.ring_q = ring_q
        self.ring_p = ring_p
    
    # new_poly creates a new polynomial with all coefficients set to 0.
    def new_poly(self):
        q = self.ring_q.new_poly()
        p = self.ring_p.new_poly()
        
        return Poly(q, p)
    
    # extend_basis_small_norm_and_center extends a small-norm polynomial polQ in R_Q to a polynomial
    # polQP in R_QP.
    def extend_basis_small_norm_and_center(self, poly_in_q, level_p, poly_out_q, poly_out_p):
        q = self.ring_q.modulus[0]
        q_half = q >> u64(1)

        if isinstance(poly_out_q, ring.Poly): poly_out_q.set(poly_in_q)

        for j in range(self.ring_q.n):
            coeff = poly_in_q.coeffs[0][j]

            sign = u64(1)
            if coeff > q_half:
                coeff = q - coeff
                sign = u64(0)

            for i, pi in enumerate(self.ring_p.modulus[:level_p+1]):
                poly_out_p.coeffs[i][j] = (coeff * sign) | (pi - coeff) * (sign ^ u64(1))
        
        poly_out_p.update_buffer()
    
    # ntt_lvl computes the NTT of p1 and returns the result on p2.
    # The operation is performed at level_q for the ringQ and level_p for the ringP.
    def ntt_lvl(self, level_q: int, level_p: int, p1: Poly, p2: Poly):
        if self.ring_q: self.ring_q.ntt_lvl(level_q, p1.q, p2.q)
        if self.ring_p: self.ring_p.ntt_lvl(level_p, p1.p, p2.p)
    
    # mform_lvl switches p1 to the Montgomery domain and writes the result on p2.
    # The operation is performed at level_q for the ringQ and level_p for the ringP.
    def mform_lvl(self, level_q, level_p, p1, p2):
        if self.ring_q: self.ring_q.mform_lvl(level_q, p1.q, p2.q)
        if self.ring_p: self.ring_p.mform_lvl(level_p, p1.p, p2.p)
    
    # new_poly_lvl creates a new polynomial with all coefficients set to 0.
    def new_poly_lvl(self, level_q, level_p):
        assert self.ring_q, "ring_q not set in RingQP"
        assert self.ring_p, "ring_p not set in RingQP"
        return Poly(self.ring_q.new_poly_lvl(level_q), self.ring_p.new_poly_lvl(level_p))
    
    # mul_coeffs_montgomery_and_sublvl multiplies p1 by p2 coefficient-wise with
    # a Montgomery modular reduction and subtracts the result from p3.
    # The operation is performed at level_q for the ringQ and level_p for the ringP.
    def mul_coeffs_montgomery_and_sublvl(self, level_q, level_p, p1, p2, p3):
        if self.ring_q: self.ring_q.mul_coeffs_montgomery_and_sublvl(level_q, p1.q, p2.q, p3.q)
        if self.ring_p: self.ring_p.mul_coeffs_montgomery_and_sublvl(level_p, p1.p, p2.p, p3.p)
    
    # inv_ntt_lvl computes the inverse-NTT of p1 and returns the result on p2.
    # The operation is performed at level_q for the ringQ and level_p for the ringP.
    def inv_ntt_lvl(self, level_q, level_p, p1, p2):
        if self.ring_q: self.ring_q.inv_ntt_lvl(level_q, p1.q, p2.q)
        if self.ring_p: self.ring_p.inv_ntt_lvl(level_p, p1.p, p2.p)


# UniformSampler is a type for sampling polynomials in Ring.
class UniformSampler:
    sampler_q: ring.UniformSampler
    sampler_p: ring.UniformSampler

    def __init__(self, sampler_q, sampler_p):
        self.sampler_q = sampler_q
        self.sampler_p = sampler_p
    
    def __str__(self) -> str:
        return f"""\tRingQPUniformSampler:
                \tsamplerQ: {self.sampler_q}
                \tsamplerP: {self.sampler_p}
        """
    
    # read_lvl samples a new polynomial in Ring and stores it into p.
    def read_lvl(self, level_q, level_p, p):
        if p.q and self.sampler_q: self.sampler_q.read_lvl(level_q, p.q)
        if p.p and self.sampler_p: self.sampler_p.read_lvl(level_p, p.p)


def new_uniform_sampler(prng, r):
    sampler_q = ring.new_uniform_sampler(prng, r.ring_q)
    sampler_p = ring.new_uniform_sampler(prng, r.ring_p)
    
    return UniformSampler(sampler_q, sampler_p)
