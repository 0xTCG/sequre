"""
Ported from https://github.com/tuneinsight/lattigo/tree/master/ckks
"""

import math

from ..types.builtin import Complex
from ..utils.utils import zeros_vec

import rlwe, ring, ringqp, utils

from rlwe import Parameters as RLWEParams
from rlwe import KeyGenerator as RLWEKeyGen
from rlwe import Plaintext as RLWEPlaintext
from rlwe import Ciphertext as RLWECiphertext
from rlwe import PkEncryptor as RLWEPkEncryptor
from rlwe import SkEncryptor as RLWESkEncryptor
from rlwe import Decryptor as RLWEDecryptor
from common import BIG_INT_LEN, big_uint, big_int


GALOISGEN: Static[int] = 5
MIN_LOG_SLOTS: Static[int] = 0


class Parameters(RLWEParams):
    log_slots: int
    default_scale: float

    def __init__(self, log_slots, default_scale):
        self.log_slots = log_slots
        self.default_scale = default_scale
    
    def __str__(self) -> str:
        return f"""\tCKKSParams:
                \tLog slots: {self.log_slots}
                \tDefault scale: {self.default_scale}
                \t{self.get_rlwe_params()}
        """
    
    def get_rlwe_params(self) -> RLWEParams:
        return RLWEParams(
            self.logn,
            self.qi,
            self.pi,
            self.pow2_base,
            self.sigma,
            self.h,
            self.ring_q,
            self.ring_p,
            self.ring_type)

    def from_rlwe_params(self, rlwe_params) -> Parameters:
        self.logn = rlwe_params.logn
        self.qi =  rlwe_params.qi
        self.pi = rlwe_params.pi
        self.pow2_base = rlwe_params.pow2_base
        self.sigma = rlwe_params.sigma
        self.h = rlwe_params.h
        self.ring_q = rlwe_params.ring_q
        self.ring_p = rlwe_params.ring_p
        self.ring_type = rlwe_params.ring_type

        return self
    
    # Returns the maximum ciphertext level
    def max_level(self) -> int:
        return self.q_count() - 1
    
    # Returns number of available plaintext slots
    def slots(self):
        return 1 << self.log_slots
    
    # Returns the log of the maximum number of slots enabled by the parameters
    def max_log_slots(self):
        if self.ring_type == ring.StandardRing:
            return self.logn - 1
        elif self.ring_type == ring.ConjugateInvariantRing:
            return self.logn
        else: raise ValueError("Invalid ring type")
    
    # Returns the theoretical maximum of plaintext slots allowed by the ring degree
    def max_slots(self):
        if self.ring_type == ring.StandardRing: return self.n() >> 1
        elif self.ring_type == ring.ConjugateInvariantRing: return self.n()
        else: raise ValueError("invalid ring type")
    
    # Returns the size of the modulus q in bits at a specific level
    def logq_lvl(self, level: int) -> int:
        return int(self.q_lvl(level).bitlen())
    
    # Returns the product of the moduli at the given level as a big.Int
    def q_lvl(self, level: int) -> big_uint:
        tmp = big_uint(1)
        for qi in self.q()[:level + 1]: tmp *= qi.ext_to_bigint()
        return tmp


class ParametersLiteral:
    logn: int
    q: list[u64]
    p: list[u64]
    logq: list[int]
    logp: list[int]
    pow2_base: int
    sigma: float
    h: int
    ring_type: int
    log_slots: int
    default_scale: float

    def __init__(self, logn, logq, logp, log_slots, default_scale):
        self.logn = logn
        self.q = list[u64]()
        self.p = list[u64]()
        self.logq = logq
        self.logp = logp
        self.log_slots = log_slots
        self.default_scale = default_scale

    def rlwe_parameters(self):
        return rlwe.ParametersLiteral(
            logn=self.logn,
            q=self.q,
            p=self.p,
            logq=self.logq,
            logp=self.logp,
            pow2_base=self.pow2_base,
            sigma=self.sigma,
            h=self.h,
            ring_type=self.ring_type)


class KeyGenerator(RLWEKeyGen):
    ckks_params: Parameters

    def __init__(self, rlwe_keygen, ckks_params):
        self.sk = rlwe_keygen.sk
        self.uniform_sampler = rlwe_keygen.uniform_sampler
        self.params = rlwe_keygen.params
        self.ckks_params = ckks_params
        self.prng = rlwe_keygen.prng
        self.gaussian_sampler = rlwe_keygen.gaussian_sampler
        self.ternary_sampler = rlwe_keygen.ternary_sampler
        self.basisextender = rlwe_keygen.basisextender
        self.buffq = rlwe_keygen.buffq
        self.buffp = rlwe_keygen.buffp
        self.buffqp = rlwe_keygen.buffqp
    
    def __str__(self) -> str:
        return f"""\tCKKSKeyGen:
                \t{self.ckks_params}
                \t{self.get_rlwe_keygen()}
        """
    
    def get_rlwe_keygen(self):
        return RLWEKeyGen(self.get_rlwe_skencryptor())


# Plaintext is is a Element with only one Poly.
class Plaintext(RLWEPlaintext):
    scale: float

    def __init__(self, plaintext, scale):
        self.value = plaintext.value
        self.scale = scale
    
    def __str__(self):
        return f"""\tCKKSPlaintext:
                \tScale: {self.scale}
                \t{self.get_rlwe_plaintext()}
        """
    
    def get_rlwe_plaintext(self):
        return RLWEPlaintext(value=self.value)


# Ciphertext is *ring.Poly array representing a polynomial of degree > 0 with coefficients in R_Q.
class Ciphertext(RLWECiphertext):
    scale: float

    def __init__(self, ciphertext, scale):
        self.value = ciphertext.value
        self.scale = scale
    
    def __str__(self):
        return f"""\tCKKSCiphertext:
                \tScale: {self.scale}
                \t{self.get_rlwe_ciphertext()}
        """

    def get_rlwe_ciphertext(self):
        return RLWECiphertext(value=self.value)


class PkEncryptor(RLWEPkEncryptor):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buffq = rlwe_enc.buffq
        self.buffp = rlwe_enc.buffp
        self.buffqp = rlwe_enc.buffqp

        self.pk = rlwe_enc.pk

        self.ckks_params = params


# NewCiphertext creates a new Ciphertext parameterized by degree, level and scale.
def new_ciphertext(params: Parameters, degree: int, level: int, scale: float) -> Ciphertext:
	ciphertext = Ciphertext(
        ciphertext=rlwe.new_ciphertext(params.get_rlwe_params(), degree, level),
        scale=scale)
	for pol in ciphertext.value: pol.is_ntt = True
	return ciphertext


class SkEncryptor(RLWESkEncryptor):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buffq = rlwe_enc.buffq
        self.buffp = rlwe_enc.buffp
        self.buffqp = rlwe_enc.buffqp

        self.sk = rlwe_enc.sk
        self.uniform_sampler = rlwe_enc.uniform_sampler

        self.ckks_params = params
    
    # encrypt_new encrypts the input plaintext returns the result as a newly allocated ciphertext.
    # The level of the output ciphertext is min(plaintext.level(), ciphertext.level()).
    def encrypt_new(self, plaintext: Plaintext) -> Ciphertext:
        ciphertext = new_ciphertext(self.ckks_params, 1, plaintext.level(), plaintext.scale)
        self.encrypt(plaintext.get_rlwe_plaintext(), ciphertext.get_rlwe_ciphertext())
        return ciphertext


# NewPlaintext creates a new Plaintext of level level and scale scale.
def new_plaintext(params: Parameters, level: int, scale: float) -> Plaintext:
	pt = Plaintext(
        plaintext=rlwe.new_plaintext(params.get_rlwe_params(), level),
        scale=scale)
	pt.value.is_ntt = True
	return pt


class Decryptor(RLWEDecryptor):
    params: Parameters

    def __init__(self, rlwe_dec, params):
        self.ring_q = rlwe_dec.ring_q
        self.buff = rlwe_dec.buff
        self.sk = rlwe_dec.sk

        self.params = params
    
    def __str__(self):
        return f"""\tCKKSDecryptor:
                \t{self.params}
                \t{self.get_rlwe_decryptor()}
        """
    
    def get_rlwe_decryptor(self):
        return RLWEDecryptor(self.ring_q, self.buff, self.sk)
    
    # decrypt decrypts the ciphertext and write the result in ptOut.
    def decrypt_new(self, ciphertext: Ciphertext) -> Plaintext:
        pt = new_plaintext(self.params, ciphertext.level(), ciphertext.scale)
        self.decrypt(ciphertext.get_rlwe_ciphertext(), pt.get_rlwe_plaintext())
        return pt


# encoder is a struct storing the necessary parameters to encode a slice of complex number on a Plaintext.
class Encoder:
    params: Parameters
    bigint_chain: list[big_uint]
    bigint_coeffs: list[big_uint]
    q_half: big_uint
    buff: ring.Poly
    m: int
    rot_group: list[int]
    gaussian_sampler: ring.GaussianSampler


def new_parameters(rlwe_params, log_slots, default_scale):
    if not rlwe_params: raise ValueError("provided RLWE parameters are invalid")

    max_log_slots = int(rlwe_params.ring_q.nth_root.bitlen()) - 3

    if log_slots > max_log_slots or log_slots < MIN_LOG_SLOTS:
        raise ValueError(f"logSlot={log_slots} is larger than the logn-1={max_log_slots} or smaller than {MIN_LOG_SLOTS}")

    return Parameters(log_slots, default_scale).from_rlwe_params(rlwe_params)


def new_parameters_from_literal(pl):
    rlwe_params = rlwe.new_parameters_from_literal(pl.rlwe_parameters())

    if pl.log_slots == 0:
        if pl.ring_type == ring.StandardRing: pl.log_slots = pl.logn - 1
        elif pl.ring_type == ring.ConjugateInvariantRing: pl.log_slots = pl.logn

    return new_parameters(rlwe_params, pl.log_slots, pl.default_scale)


# NewKeyGenerator creates a RLWEKeyGen instance from the CKKS parameters.
def new_key_generator(params):
    return KeyGenerator(rlwe.new_key_generator(params.get_rlwe_params()), params)


# NewEncryptor instantiates a new Encryptor for the CKKS scheme. The key argument can
# be *rlwe.PublicKey, *rlwe.SecretKey or nil.
def new_encryptor(params: Parameters, key):
    if isinstance(key, rlwe.PublicKey):
        return PkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    elif isinstance(key, rlwe.SecretKey):
        return SkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    else:
	    raise ValueError("cannot NewEncryptor: key must be either *rlwe.PublicKey or *rlwe.SecretKey")


# NewDecryptor instantiates a Decryptor for the CKKS scheme.
def new_decryptor(params: Parameters, sk: rlwe.SecretKey) -> Decryptor:
	return Decryptor(rlwe.new_decryptor(params.get_rlwe_params(), sk), params)


def gen_bigint_chain(q: list[u64]) -> list[big_uint]:
    num_bits_total = 1
    for m in q: num_bits_total += int(m.bitlen())
    assert num_bits_total <= BIG_INT_LEN, (
        f"Moduli product too large for the bigint in use. Increase the bigint size."
        f" Current bigint size: {BIG_INT_LEN}. Required size: {num_bits_total}")

    bigint_chain = list[big_uint](len(q))
    bigint_chain.append(q[0].ext_to_bigint())
	
    for i in range(1, len(q)):
        bigint_chain.append(q[i].ext_to_bigint())
        bigint_chain[i] *= bigint_chain[i-1]
	
    return bigint_chain


def new_encoder(params: Parameters) -> Encoder:
	m = int(params.ring_q.nth_root)

	rot_group = list[int](m >> 1)
	five_pows = 1
	for _ in range(m >> 2):
		rot_group.append(five_pows) 
		five_pows *= GALOISGEN
		five_pows &= (m - 1)

	gaussian_sampler = ring.new_gaussian_sampler(utils.new_prng(), params.ring_q, params.sigma, int(6 * params.sigma))

	return Encoder(
		params=params,
		bigint_chain=gen_bigint_chain(params.q()),
		bigint_coeffs=zeros_vec(m >> 1, TP=big_uint),
		q_half=big_uint(0),
		buff=params.ring_q.new_poly(),
		m=m,
		rot_group=rot_group,
		gaussian_sampler=gaussian_sampler)


# SliceBitReverseInPlaceComplex128 applies an in-place bit-reverse permuation on the input slice.
def slice_bit_reverse_in_place_complex128(slice: list[Complex], n: int):
    j = 0

    for i in range(1, n):
        bit = n >> 1

        while j >= bit:
            j -= bit
            bit >>= 1

        j += bit

        if i < j: slice[i], slice[j] = slice[j], slice[i]


# SpecialiFFTVec performs the CKKS special inverse FFT transform in place.
def special_ifft_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                j, k = j + 1, k + 1

    for i in range(n):
        values[i] /= Complex(float(n), 0)

    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTVec performs the CKKS special FFT transform in place.
def special_fft_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    slice_bit_reverse_in_place_complex128(values, n)
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]

                j, k = j + 1, k + 1


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[Complex], scale_val: Complex):
	for i in range(len(values)): values[i] /= scale_val


# SpecialiFFTUL8Vec performs the CKKS special inverse FFT transform in place with unrolled loops of size 8.
def special_ifft_ul8_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], (values[k + 1] - values[k + lenh + 1]) * roots[(lenq - (rot_group[j + 1] & mask)) << log_gap]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], (values[k + 2] - values[k + lenh + 2]) * roots[(lenq - (rot_group[j + 2] & mask)) << log_gap]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], (values[k + 3] - values[k + lenh + 3]) * roots[(lenq - (rot_group[j + 3] & mask)) << log_gap]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], (values[k + 4] - values[k + lenh + 4]) * roots[(lenq - (rot_group[j + 4] & mask)) << log_gap]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], (values[k + 5] - values[k + lenh + 5]) * roots[(lenq - (rot_group[j + 5] & mask)) << log_gap]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], (values[k + 6] - values[k + lenh + 6]) * roots[(lenq - (rot_group[j + 6] & mask)) << log_gap]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], (values[k + 7] - values[k + lenh + 7]) * roots[(lenq - (rot_group[j + 7] & mask)) << log_gap]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]
            psi4 = roots[(lenq - (rot_group[4] & mask)) << log_gap]
            psi5 = roots[(lenq - (rot_group[5] & mask)) << log_gap]
            psi6 = roots[(lenq - (rot_group[6] & mask)) << log_gap]
            psi7 = roots[(lenq - (rot_group[7] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 8] = values[i] + values[i + 8], (values[i] - values[i + 8]) * psi0
                values[i + 1], values[i + 9] = values[i + 1] + values[i + 9], (values[i + 1] - values[i + 9]) * psi1
                values[i + 2], values[i + 10] = values[i + 2] + values[i + 10], (values[i + 2] - values[i + 10]) * psi2
                values[i + 3], values[i + 11] = values[i + 3] + values[i + 11], (values[i + 3] - values[i + 11]) * psi3
                values[i + 4], values[i + 12] = values[i + 4] + values[i + 12], (values[i + 4] - values[i + 12]) * psi4
                values[i + 5], values[i + 13] = values[i + 5] + values[i + 13], (values[i + 5] - values[i + 13]) * psi5
                values[i + 6], values[i + 14] = values[i + 6] + values[i + 14], (values[i + 6] - values[i + 14]) * psi6
                values[i + 7], values[i + 15] = values[i + 7] + values[i + 15], (values[i + 7] - values[i + 15]) * psi7

        elif lenh == 4:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 4] = values[i] + values[i + 4], (values[i] - values[i + 4]) * psi0
                values[i + 1], values[i + 5] = values[i + 1] + values[i + 5], (values[i + 1] - values[i + 5]) * psi1
                values[i + 2], values[i + 6] = values[i + 2] + values[i + 6], (values[i + 2] - values[i + 6]) * psi2
                values[i + 3], values[i + 7] = values[i + 3] + values[i + 7], (values[i + 3] - values[i + 7]) * psi3
                values[i + 8], values[i + 12] = values[i + 8] + values[i + 12], (values[i + 8] - values[i + 12]) * psi0
                values[i + 9], values[i + 13] = values[i + 9] + values[i + 13], (values[i + 9] - values[i + 13]) * psi1
                values[i + 10], values[i + 14] = values[i + 10] + values[i + 14], (values[i + 10] - values[i + 14]) * psi2
                values[i + 11], values[i + 15] = values[i + 11] + values[i + 15], (values[i + 11] - values[i + 15]) * psi3
        elif lenh == 2:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 2] = values[i] + values[i + 2], (values[i] - values[i + 2]) * psi0
                values[i + 1], values[i + 3] = values[i + 1] + values[i + 3], (values[i + 1] - values[i + 3]) * psi1
                values[i + 4], values[i + 6] = values[i + 4] + values[i + 6], (values[i + 4] - values[i + 6]) * psi0
                values[i + 5], values[i + 7] = values[i + 5] + values[i + 7], (values[i + 5] - values[i + 7]) * psi1
                values[i + 8], values[i + 10] = values[i + 8] + values[i + 10], (values[i + 8] - values[i + 10]) * psi0
                values[i + 9], values[i + 11] = values[i + 9] + values[i + 11], (values[i + 9] - values[i + 11]) * psi1
                values[i + 12], values[i + 14] = values[i + 12] + values[i + 14], (values[i + 12] - values[i + 14]) * psi0
                values[i + 13], values[i + 15] = values[i + 13] + values[i + 15], (values[i + 13] - values[i + 15]) * psi1
        elif lenh == 1:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 1] = values[i] + values[i + 1], (values[i] - values[i + 1]) * psi0
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], (values[i + 2] - values[i + 3]) * psi0
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], (values[i + 4] - values[i + 5]) * psi0
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], (values[i + 6] - values[i + 7]) * psi0
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], (values[i + 8] - values[i + 9]) * psi0
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], (values[i + 10] - values[i + 11]) * psi0
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], (values[i + 12] - values[i + 13]) * psi0
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], (values[i + 14] - values[i + 15]) * psi0

    divide_complex128_slice_vec(values, Complex(float(n), 0))
    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTUL8Vec performs the CKKS special FFT transform in place with unrolled loops of size 8.
def special_fft_ul8_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    slice_bit_reverse_in_place_complex128(values, n)

    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                    values[k + lenh + 1] *= roots[(rot_group[j + 1] & mask) << log_gap]
                    values[k + lenh + 2] *= roots[(rot_group[j + 2] & mask) << log_gap]
                    values[k + lenh + 3] *= roots[(rot_group[j + 3] & mask) << log_gap]
                    values[k + lenh + 4] *= roots[(rot_group[j + 4] & mask) << log_gap]
                    values[k + lenh + 5] *= roots[(rot_group[j + 5] & mask) << log_gap]
                    values[k + lenh + 6] *= roots[(rot_group[j + 6] & mask) << log_gap]
                    values[k + lenh + 7] *= roots[(rot_group[j + 7] & mask) << log_gap]

                    values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], values[k + 1] - values[k + lenh + 1]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], values[k + 2] - values[k + lenh + 2]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], values[k + 3] - values[k + lenh + 3]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], values[k + 4] - values[k + lenh + 4]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], values[k + 5] - values[k + lenh + 5]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], values[k + 6] - values[k + lenh + 6]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], values[k + 7] - values[k + lenh + 7]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]
            psi4 = roots[(rot_group[4] & mask) << log_gap]
            psi5 = roots[(rot_group[5] & mask) << log_gap]
            psi6 = roots[(rot_group[6] & mask) << log_gap]
            psi7 = roots[(rot_group[7] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 8] *= psi0
                values[i + 9] *= psi1
                values[i + 10] *= psi2
                values[i + 11] *= psi3
                values[i + 12] *= psi4
                values[i + 13] *= psi5
                values[i + 14] *= psi6
                values[i + 15] *= psi7

                values[i], values[i + 8] = values[i]+values[i + 8], values[i] - values[i + 8]
                values[i + 1], values[i + 9] = values[i + 1]+values[i + 9], values[i + 1] - values[i + 9]
                values[i + 2], values[i + 10] = values[i + 2]+values[i + 10], values[i + 2] - values[i + 10]
                values[i + 3], values[i + 11] = values[i + 3]+values[i + 11], values[i + 3] - values[i + 11]
                values[i + 4], values[i + 12] = values[i + 4]+values[i + 12], values[i + 4] - values[i + 12]
                values[i + 5], values[i + 13] = values[i + 5]+values[i + 13], values[i + 5] - values[i + 13]
                values[i + 6], values[i + 14] = values[i + 6]+values[i + 14], values[i + 6] - values[i + 14]
                values[i + 7], values[i + 15] = values[i + 7]+values[i + 15], values[i + 7] - values[i + 15]
        elif lenh == 4:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 4] *= psi0
                values[i + 5] *= psi1
                values[i + 6] *= psi2
                values[i + 7] *= psi3
                values[i + 12] *= psi0
                values[i + 13] *= psi1
                values[i + 14] *= psi2
                values[i + 15] *= psi3

                values[i], values[i + 4] = values[i]+values[i + 4], values[i] - values[i + 4]
                values[i + 1], values[i + 5] = values[i + 1]+values[i + 5], values[i + 1] - values[i + 5]
                values[i + 2], values[i + 6] = values[i + 2]+values[i + 6], values[i + 2] - values[i + 6]
                values[i + 3], values[i + 7] = values[i + 3]+values[i + 7], values[i + 3] - values[i + 7]
                values[i + 8], values[i + 12] = values[i + 8]+values[i + 12], values[i + 8] - values[i + 12]
                values[i + 9], values[i + 13] = values[i + 9]+values[i + 13], values[i + 9] - values[i + 13]
                values[i + 10], values[i + 14] = values[i + 10]+values[i + 14], values[i + 10] - values[i + 14]
                values[i + 11], values[i + 15] = values[i + 11]+values[i + 15], values[i + 11] - values[i + 15]
        elif lenh == 2:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 2] *= psi0
                values[i + 3] *= psi1
                values[i + 6] *= psi0
                values[i + 7] *= psi1
                values[i + 10] *= psi0
                values[i + 11] *= psi1
                values[i + 14] *= psi0
                values[i + 15] *= psi1

                values[i], values[i + 2] = values[i]+values[i + 2], values[i] - values[i + 2]
                values[i + 1], values[i + 3] = values[i + 1]+values[i + 3], values[i + 1] - values[i + 3]
                values[i + 4], values[i + 6] = values[i + 4]+values[i + 6], values[i + 4] - values[i + 6]
                values[i + 5], values[i + 7] = values[i + 5]+values[i + 7], values[i + 5] - values[i + 7]
                values[i + 8], values[i + 10] = values[i + 8]+values[i + 10], values[i + 8] - values[i + 10]
                values[i + 9], values[i + 11] = values[i + 9]+values[i + 11], values[i + 9] - values[i + 11]
                values[i + 12], values[i + 14] = values[i + 12]+values[i + 14], values[i + 12] - values[i + 14]
                values[i + 13], values[i + 15] = values[i + 13]+values[i + 15], values[i + 13] - values[i + 15]
        elif lenh == 1:
            psi0 = roots[(rot_group[0] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 1] *= psi0
                values[i + 3] *= psi0
                values[i + 5] *= psi0
                values[i + 7] *= psi0
                values[i + 9] *= psi0
                values[i + 11] *= psi0
                values[i + 13] *= psi0
                values[i + 15] *= psi0

                values[i], values[i + 1] = values[i] + values[i + 1], values[i] - values[i + 1]
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], values[i + 2] - values[i + 3]
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], values[i + 4] - values[i + 5]
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], values[i + 6] - values[i + 7]
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], values[i + 8] - values[i + 9]
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], values[i + 10] - values[i + 11]
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], values[i + 12] - values[i + 13]
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], values[i + 14] - values[i + 15]


def single_float_to_fixed_point_crt(level: int, i: int, value: float, scale: float, ring_q: ring.Ring, coeffs: list[list[u64]]):
    is_negative = False

    if value < 0:
        is_negative = True
        scale *= -1

    value *= scale
    moduli = ring_q.modulus

    if value > 1.8446744073709552e+19:
        # xFlo = big_float(value)
        # xFlo += big_float(0.5)
        # xInt = big_uint(xFlo)
        # for j, qi in enumerate(moduli[:level + 1]):
        #     tmp = xInt % qi
        #     if is_negative: coeffs[j][i] = qi - tmp
        #     else: coeffs[j][i] = tmp
        raise NotImplementedError()
    else:
        bred_params = ring_q.bred_params

        c = u64(int(value + 0.5))
        if is_negative:
            for j, qi in enumerate(moduli[:level + 1]):
                if c > qi: coeffs[j][i] = qi - ring.bred_add(c, qi, bred_params[j])
                else: coeffs[j][i] = qi - c
        else:
            for j, qi in enumerate(moduli[:level + 1]):
                if c > u64(0x1fffffffffffffff): coeffs[j][i] = ring.bred_add(c, qi, bred_params[j])
                else: coeffs[j][i] = c


# NttAndMontgomeryLvl takes the polynomial polIn Z[Y] outside of the NTT domain to the polynomial Z[X] in the NTT domain where Y = X^(gap).
# This method is used to accelerate the NTT of polynomials that encode sparse plaintexts.
def ntt_and_montgomery_lvl(level: int, log_slots: int, ring_q: ring.Ring, montgomery: bool, pol: ring.Poly):
    if u64(1 << log_slots) == ring_q.nth_root >> u64(2):
        ring_q.ntt_lvl(level, pol, pol)
        if montgomery: ring_q.mform_lvl(level, pol, pol)
    else:
        n = 0

        if ring_q.type() == ring.StandardRing: n = 2 << log_slots
        elif ring_q.type() == ring.ConjugateInvariantRing:
            n = 1 << log_slots
            # NTT = ring_NTTConjugateInvariant
            raise NotImplementedError()
        else: raise ValueError("Invalid ring type")

        gap = ring_q.n // n
        for i in range(level + 1):
            coeffs = pol.coeffs[i]

            # NTT in dimension n
            ring.ntt(coeffs, coeffs, n, ring_q.ntt_psi[i], ring_q.modulus[i], ring_q.mred_params[i], ring_q.bred_params[i])
            if montgomery: ring.mform_vec(coeffs, coeffs, ring_q.modulus[i], ring_q.bred_params[i])

            # Maps NTT in dimension n to NTT in dimension n
            for j in range(n - 1, -1, -1):
                c = coeffs[j]
                for w in range(gap): coeffs[j * gap + w] = c
    
    pol.update_buffer()


def complex_to_fixed_point_crt(level: int, values: list[Complex], scale: float, ring_q: ring.Ring, coeffs: list[list[u64]], is_ring_standard: bool):
    for i, v in enumerate(values):
        single_float_to_fixed_point_crt(level, i, v.r, scale, ring_q, coeffs)

    if is_ring_standard:
        slots = len(values)
        for i, v in enumerate(values):
            single_float_to_fixed_point_crt(level, i + slots, v.i, scale, ring_q, coeffs)


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[Complex], scale_val: Complex):
	for i in range(len(values)): values[i] /= scale_val


def poly_to_complex_no_crt(coeffs: list[u64], values: list[Complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring):
    slots = 1 << log_slots
    max_slots = int(ring_q.nth_root >> u64(2))
    gap = max_slots // slots
    q = ring_q.modulus[0]

    c = u64(0)
    i, idx = 0, 0
    while i < slots:
        c = coeffs[idx]
        if c >= q >> u64(1): values[i] = Complex(-float(q - c), 0)
        else: values[i] = Complex(float(c), 0)
        i, idx = i + 1, idx + gap

    if not isreal:
        i, idx = 0, max_slots
        while i < slots:
            c = coeffs[idx]
            if c >= q >> u64(1): values[i] += Complex(0, -float(q - c))
            else: values[i] += Complex(0, float(c))
            i, idx = i + 1, idx + gap

    divide_complex128_slice_vec(values, Complex(scale, 0))


# Divides x by n^2, returns a float
def scale_down(coeff: big_int, n: float) -> float:
    return float(coeff.trunc_to_i64()) / n


def poly_to_complex_crt(poly: ring.Poly, bigint_coeffs: list[big_uint], values: list[Complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring, q: big_uint):
    max_slots = int(ring_q.nth_root >> u64(2))
    slots = 1 << log_slots
    gap = max_slots // slots

    ring_q.poly_to_bigint(poly, gap, bigint_coeffs)

    q_half = q >> big_uint(1)

    for i in range(slots):
        c = bigint_coeffs[i]
        c = c.bigint_mod(q)
        c_intn = c.to_intn()
        if c >= q_half: c_intn -= q.to_intn()
        values[i] = Complex(scale_down(c_intn, scale), 0)
    
    if not isreal:
        i, j = 0, slots
        while i < slots:
            c = bigint_coeffs[j]
            c = c.bigint_mod(q)
            c_intn = c.to_intn()
            if c >= q_half: c_intn -= q.to_intn()
            values[i] += Complex(0, scale_down(c_intn, scale))

            i, j = i + 1, j + 1
    

# StandardDeviation computes the scaled standard deviation of the input vector.
def standard_deviation(vec: list[float], scale: float) -> float:
    # We assume that the error is centered around zero
    n = float(len(vec))
    mean = 0.0
    err = 0.0

    for c in vec: mean += c
    mean /= n

    for c in vec:
        tmp = c - mean
        err += tmp * tmp

    return math.sqrt(err / n) * scale


class EncoderComplex128(Encoder):
    values: list[Complex]
    values_float: list[float]
    roots: list[Complex]

    def __init__(self, encoder: Encoder, roots: list[Complex], values: list[Complex], values_float: list[float]):
        self.params=encoder.params
        self.bigint_chain=encoder.bigint_chain
        self.bigint_coeffs=encoder.bigint_coeffs
        self.q_half=encoder.q_half
        self.buff=encoder.buff
        self.m=encoder.m
        self.rot_group=encoder.rot_group
        self.gaussian_sampler=encoder.gaussian_sampler

        self.roots=roots
        self.values=values
        self.values_float=values_float
    
    def __str__(self):
        return f"""\tCKKSEncoderComplex:
                \tvalues[:10]: {self.values[:10]}
        """
    
    # encode encodes a set of values on the target plaintext.
    # This method is identical to "EncodeSlots".
    # Encoding is done at the level and scale of the plaintext.
    # User must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariant.
    # Returned plaintext is always in the NTT domain.
    def encode(self, values, plaintext: Plaintext, log_slots: int):
        self.embed(values, log_slots, plaintext.scale, False, plaintext.value)
    
    # embed is a generic method to encode a set of values on the target polyOut interface.
    # This method is at the core of the slot encoding.
    # values: values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariant.
    # logslots: user must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # scale: the scaling factor used do discretize float64 to fixed point integers.
    # montgomery: if true then the value written on polyOut are put in the Montgomery domain.
    # polyOut: polyOut.(type) can be either ringqp.Poly or *ring.Poly.
    # The encoding encoding is done at the level of polyOut.
    # Values written on  polyOut are always in the NTT domain.
    def embed(self, values, log_slots: int, scale: float, montgomery: bool, polyOut):
        if log_slots < MIN_LOG_SLOTS or log_slots > self.params.max_log_slots():
            raise ValueError(f"cannot embed: log_slots ({log_slots}) must be greater or equal to {MIN_LOG_SLOTS} and smaller than {self.params.max_log_slots()}\n")

        slots = 1 << log_slots
        len_values = 0

        # First checks the type of input values
        # If complex
        if isinstance(values, list[Complex]):
            # Checks that the number of values is with the possible range
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            if self.params.ring_type == ring.StandardRing:
                self.values[:len_values] = copy(values)
            elif self.params.ring_type == ring.ConjugateInvariantRing:
                # Discards the imaginary part
                for i, v in enumerate(values):
                    self.values[i] = Complex(v.r, 0)
            else:
                raise ValueError("cannot embed: ring_type must be ring.Standard or ring.ConjugateInvariant")
        # If floats only
        elif isinstance(values, list[float]):
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            for i, v in enumerate(values):
                self.values[i] = Complex(v, 0)
        else:
            raise ValueError(f"cannot embed: values.(type) must be []complex128 or []float64.")

        for i in range(len_values, slots):
            self.values[i] = Complex(0)

        if log_slots < 4:
            special_ifft_vec(self.values, slots, self.m, self.rot_group, self.roots)
        else:
            special_ifft_ul8_vec(self.values, slots, self.m, self.rot_group, self.roots)

        is_ring_standard = self.params.ring_type == ring.StandardRing

        if isinstance(polyOut, ringqp.Poly):
            complex_to_fixed_point_crt(polyOut.q.level(), self.values[:slots], scale, self.params.ring_q, self.q.coeffs, is_ring_standard)
            ntt_and_montgomery_lvl(polyOut.q.level(), log_slots, self.params.ring_q, montgomery, polyOut.q)

            if polyOut.p:
                complex_to_fixed_point_crt(polyOut.p.level(), self.values[:slots], scale, self.params.ring_p, polyOut.p.coeffs, is_ring_standard)
                ntt_and_montgomery_lvl(polyOut.p.level(), log_slots, self.params.ring_p, montgomery, polyOut.p)
        elif isinstance(polyOut, ring.Poly):
            complex_to_fixed_point_crt(polyOut.level(), self.values[:slots], scale, self.params.ring_q, polyOut.coeffs, is_ring_standard)
            ntt_and_montgomery_lvl(polyOut.level(), log_slots, self.params.ring_q, montgomery, polyOut)
        else:
            raise ValueError("cannot embed: invalid polyOut.(type) must be ringqp.Poly or *ring.Poly")

    # decode decodes the input plaintext on a new slice of complex128.
    # This method is the same as .DecodeSlots(*).
    def decode(self, plaintext: Plaintext, log_slots: int):
        return self.decode_slots_public(plaintext, log_slots, 0)
    
    # decode_slots_public decodes the input plaintext on a new slice of complex128.
    # Adds, before the decoding step, an error with standard deviation sigma and bound floor(sqrt(2*pi)*sigma).
    # If the underlying ring_type is ConjugateInvariant, the imaginary part (and
    # its related error) are zero.
    def decode_slots_public(self, plaintext: Plaintext, log_slots: int, bound: float):
        return self.decode_public(plaintext, log_slots, bound)
    
    def decode_public(self, plaintext: Plaintext, log_slots: int, sigma: float):
        if log_slots > self.params.max_log_slots() or log_slots < MIN_LOG_SLOTS:
            raise ValueError(f"cannot decode: ensure that {MIN_LOG_SLOTS} <= log_slots ({log_slots}) <= {self.params.max_log_slots()}")

        if plaintext.value.is_ntt:
            self.params.ring_q.inv_ntt_lvl(plaintext.level(), plaintext.value, self.buff)
        else:
            ring.copy_values_lvl(plaintext.level(), plaintext.value, self.buff)

        # B = floor(sigma * sqrt(2*pi))
        if sigma != 0:
            self.gaussian_sampler.read_and_add_from_dist_lvl(plaintext.level(), self.buff, self.params.ring_q, sigma, int(2.5066282746310002 * sigma))
        
        self.plaintext_to_complex(plaintext.level(), plaintext.scale, log_slots, self.buff, self.values)

        if log_slots < 3:
            special_fft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else:
            special_fft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        return copy(self.values)
    
    def plaintext_to_complex(self, level: int, scale: float, log_slots: int, p: ring.Poly, values: list[Complex]):
        isreal = self.params.ring_type == ring.ConjugateInvariantRing
        if level == 0:
            poly_to_complex_no_crt(p.coeffs[0], values, scale, log_slots, isreal, self.params.ring_q)
        else:
            poly_to_complex_crt(p, self.bigint_coeffs, values, scale, log_slots, isreal, self.params.ring_q, self.bigint_chain[level])

        if isreal: # [X]/(X^n+1) to [X+X^-1]/(X^n+1)
            slots = 1 << log_slots
            for i in range(1, slots): self.values[i] -= Complex(0, self.values[slots-i].r)
    
    # get_err_std_slot_domain returns StandardDeviation(values_want-values_have)*scale
    # which is the scaled standard deviation of two complex vectors.
    def get_err_std_slot_domain(self, values_want: list[Complex], values_have: list[Complex], scale: float) -> float:
        for i in range(len(values_want)):
            err = values_want[i] - values_have[i]
            self.values_float[2 * i] = err.r
            self.values_float[2 * i + 1] = err.i

        return standard_deviation(self.values_float[:len(values_want) * 2], scale)
    
    # get_err_std_coeff_domain returns StandardDeviation(encode(values_want-values_have))*scale
    # which is the scaled standard deviation in the coefficient domain of the difference
    # of two complex vector in the slot domain.
    def get_err_std_coeff_domain(self, values_want: list[Complex], values_have: list[Complex], scale: float) -> float:
        for i in range(len(values_have)): self.values[i] = (values_want[i] - values_have[i])
        for i in range(len(values_have), len(self.values)): self.values[i] = Complex(0, 0)

        log_slots = int((len(values_have) - 1).bitlen())

        # Runs FFT^-1 with the smallest power of two length that is greater than the input size
        if log_slots < 3: special_ifft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else: special_ifft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        for i in range(len(values_want)):
            self.values_float[2 * i] = self.values[i].r
            self.values_float[2 * i + 1] = self.values[i].i

        return standard_deviation(self.values_float[:len(values_want) * 2], scale)


# NewEncoder creates a new Encoder that is used to encode a slice of complex values of size at most n/2 (the number of slots) on a Plaintext.
def new_encoder_complex(params: Parameters) -> EncoderComplex128:
	ecd = new_encoder(params)

	roots = list[Complex](ecd.m + 1)
	for i in range(ecd.m):
		angle = 2 * 3.141592653589793 * i / ecd.m
		roots.append(Complex(math.cos(angle), math.sin(angle)))

	roots.append(roots[0])

	return EncoderComplex128(
        encoder=ecd,
        roots=roots,
        values=zeros_vec(ecd.m >> 2, TP=Complex),
        values_float=zeros_vec(ecd.m >> 1, TP=float))


# Stats is a struct storing the real, imaginary and l2 norm (modulus)
# about the precision of a complex value.
class Stats:
    real: float
    imag: float
    l2: float


# PrecisionStats is a struct storing statistic about the precision of a CKKS plaintext
class PrecisionStats:
    max_delta: Stats
    min_delta: Stats
    max_precision: Stats
    min_precision: Stats
    mean_delta: Stats
    mean_precision: Stats
    median_delta: Stats
    median_precision: Stats
    std_freq: float
    std_time: float

    real_dist: list[dict[str, float]]
    imag_dist: list[dict[str, float]]
    l2_dist: list[dict[str, float]]

    cdf_resol: int

    def __str__(self) -> str:
        return f"""
            ┌─────────┬───────┬───────┬───────┐
            │    Log2 │ REAL  │ IMAG  │ l2    │
            ├─────────┼───────┼───────┼───────┤
            │MIN Prec │ {round(self.min_precision.real, 2)} │ {round(self.min_precision.imag, 2)} │ {round(self.min_precision.l2, 2)} │
            │MAX Prec │ {round(self.max_precision.real, 2)} │ {round(self.max_precision.imag, 2)} │ {round(self.max_precision.l2, 2)} │
            │AVG Prec │ {round(self.mean_precision.real, 2)} │ {round(self.mean_precision.imag, 2)} │ {round(self.mean_precision.l2, 2)} │
            │MED Prec │ {round(self.median_precision.real, 2)} │ {round(self.median_precision.imag, 2)} │ {round(self.median_precision.l2, 2)} │
            └─────────┴───────┴───────┴───────┘

            Err STD Slots  : {math.log2(self.std_freq)} Log2
            Err STD coeffs : {math.log2(self.std_time)} Log2
        """
    
    def calc_cdf(self, precs: list[float], res: list[dict[str, float]]):
        sorted_precs = sorted(precs)
        min_prec = sorted_precs[0]
        max_prec = sorted_precs[len(sorted_precs)-1]
        for i in range(self.cdf_resol):
            cur_prec = min_prec + float(i) * (max_prec - min_prec) / float(self.cdf_resol)
            for count_smaller, p in enumerate(sorted_precs):
                if p >= cur_prec:
                    res[i]["Prec"] = cur_prec
                    res[i]["Count"] = count_smaller
                    break


def delta_to_precision(c: Stats) -> Stats:
	return Stats(math.log2(1 / c.real), math.log2(1 / c.imag), math.log2(1 / c.l2))


def calc_median(values: list[Stats]) -> Stats:
    tmp = sorted([v.real for v in values])
    for i in range(len(values)): values[i].real = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].imag
    tmp.sort()
    for i in range(len(values)): values[i].imag = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].l2
    tmp.sort()
    for i in range(len(values)): values[i].l2 = tmp[i]
    index = len(values) // 2
    if len(values) & 1 == 1 or index + 1 == len(values):
        return Stats(values[index].real, values[index].imag, values[index].l2)

    return Stats((values[index].real + values[index+1].real) / 2,
		(values[index].imag + values[index+1].imag) / 2,
		(values[index].l2 + values[index+1].l2) / 2)


# GetPrecisionStats generates a PrecisionStats struct from the reference values and the decrypted values
# vWant.(type) must be either []complex128 or []float64
# element.(type) must be either *Plaintext, *Ciphertext, []complex128 or []float64. If not *Ciphertext, then decryptor can be nil.
def get_precision_stats(
        params: Parameters, encoder: EncoderComplex128,
        v_want: list, element, log_slots: int, sigma: float) -> PrecisionStats:
    values_test = []
    values_want = []
    
    if isinstance(element, Ciphertext):
        raise NotImplementedError()
        # values_test = encoder.decode_public(decryptor.decrypt_new(element), log_slots, sigma)
    elif isinstance(element, Plaintext):
        values_test = encoder.decode_public(element, log_slots, sigma)
    elif isinstance(element, list[Complex]):
        values_test = element
    elif isinstance(element, list[float]):
        values_test = [Complex(e, 0) for e in element]
    else: raise TypeError("Invalid type for test values")

    if isinstance(v_want, list[Complex]): values_want = v_want
    elif isinstance(v_want, list[float]): values_want = [Complex(e, 0) for e in v_want]
    else: raise TypeError("Invalid type for test values")

    slots = len(values_want)
    diff = [Stats() for _ in range(slots)]

    prec = PrecisionStats()
    prec.max_delta = Stats(0, 0, 0)
    prec.min_delta = Stats(1, 1, 1)
    prec.mean_delta = Stats(0, 0, 0)
    prec.cdf_resol = 500
    prec.real_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.imag_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.l2_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]

    prec_real = [0.0 for _ in range(len(values_want))]
    prec_imag = [0.0 for _ in range(len(values_want))]
    prec_l2 = [0.0 for _ in range(len(values_want))]

    for i in range(len(values_want)):
        delta_real = abs(values_test[i].r - values_want[i].r)
        delta_imag = abs(values_test[i].i - values_want[i].i)
        delta_l2 = math.sqrt(delta_real * delta_real + delta_imag * delta_imag)
        prec_real[i] = math.log2(1 / delta_real)
        prec_imag[i] = math.log2(1 / delta_imag)
        prec_l2[i] = math.log2(1 / delta_l2)

        diff[i].real = delta_real
        diff[i].imag = delta_imag
        diff[i].l2 = delta_l2

        prec.mean_delta.real += delta_real
        prec.mean_delta.imag += delta_imag
        prec.mean_delta.l2 += delta_l2

        if delta_real > prec.max_delta.real: prec.max_delta.real = delta_real
        if delta_imag > prec.max_delta.imag: prec.max_delta.imag = delta_imag
        if delta_l2 > prec.max_delta.l2: prec.max_delta.l2 = delta_l2
        if delta_real < prec.min_delta.real: prec.min_delta.real = delta_real
        if delta_imag < prec.min_delta.imag: prec.min_delta.imag = delta_imag
        if delta_l2 < prec.min_delta.l2: prec.min_delta.l2 = delta_l2

    prec.calc_cdf(prec_real, prec.real_dist)
    prec.calc_cdf(prec_imag, prec.imag_dist)
    prec.calc_cdf(prec_l2, prec.l2_dist)
    
    prec.min_precision = delta_to_precision(prec.max_delta)
    prec.max_precision = delta_to_precision(prec.min_delta)
    prec.mean_delta.real /= float(slots)
    prec.mean_delta.imag /= float(slots)
    prec.mean_delta.l2 /= float(slots)
    prec.mean_precision = delta_to_precision(prec.mean_delta)
    prec.median_delta = calc_median(diff)
    prec.median_precision = delta_to_precision(prec.median_delta)
    prec.std_freq = encoder.get_err_std_slot_domain(values_want[:], values_test[:], params.default_scale)
    prec.std_time = encoder.get_err_std_coeff_domain(values_want, values_test, params.default_scale)
    
    return prec
