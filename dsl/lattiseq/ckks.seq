"""
Ported from https://github.com/tuneinsight/lattigo/tree/master/ckks
"""

import math

from ..types.builtin import Complex
from ..utils.utils import zeros_vec

import rlwe, ring, ringqp, utils

from rlwe import Parameters as RLWEParams
from rlwe import KeyGenerator as RLWEKeyGen
from rlwe import Plaintext as RLWEPlaintext
from rlwe import Ciphertext as RLWECiphertext
from rlwe import PkEncryptor as RLWEPkEncryptor
from rlwe import SkEncryptor as RLWESkEncryptor
from rlwe import Decryptor as RLWEDecryptor
from rlwe import Evaluator as RLWEEvaluator
from common import BIG_INT_LEN, big_uint, big_int, GALOIS_GEN, MIN_LOG_SLOTS



class Parameters(RLWEParams):
    log_slots: int
    default_scale: float

    def __init__(self, log_slots, default_scale):
        self.log_slots = log_slots
        self.default_scale = default_scale
    
    def __str__(self) -> str:
        return f"""\tCKKSParams:
                \tLog slots: {self.log_slots}
                \tDefault scale: {self.default_scale}
                \t{self.get_rlwe_params()}
        """
    
    def get_rlwe_params(self) -> RLWEParams:
        return RLWEParams(
            self.logn,
            self.qi,
            self.pi,
            self.pow2_base,
            self.sigma,
            self.h,
            self.ring_q,
            self.ring_p,
            self.ring_type)

    def set_rlwe_params(self, rlwe_params):
        self.logn = rlwe_params.logn
        self.qi =  rlwe_params.qi
        self.pi = rlwe_params.pi
        self.pow2_base = rlwe_params.pow2_base
        self.sigma = rlwe_params.sigma
        self.h = rlwe_params.h
        self.ring_q = rlwe_params.ring_q
        self.ring_p = rlwe_params.ring_p
        self.ring_type = rlwe_params.ring_type
    
    def from_rlwe_params(self, rlwe_params) -> Parameters:
        self.set_rlwe_params(rlwe_params)
        return self
    
    # Returns the maximum ciphertext level
    def max_level(self) -> int:
        return self.q_count() - 1
    
    # Returns number of available plaintext slots
    def slots(self):
        return 1 << self.log_slots
    
    # Returns the log of the maximum number of slots enabled by the parameters
    def max_log_slots(self):
        if self.ring_type == ring.StandardRing:
            return self.logn - 1
        elif self.ring_type == ring.ConjugateInvariantRing:
            return self.logn
        else: raise ValueError("Invalid ring type")
    
    # Returns the theoretical maximum of plaintext slots allowed by the ring degree
    def max_slots(self):
        if self.ring_type == ring.StandardRing: return self.n() >> 1
        elif self.ring_type == ring.ConjugateInvariantRing: return self.n()
        else: raise ValueError("invalid ring type")
    
    # Returns the size of the modulus q in bits at a specific level
    def logq_lvl(self, level: int) -> int:
        return int(self.q_lvl(level).bitlen())
    
    # Returns the product of the moduli at the given level as a big.Int
    def q_lvl(self, level: int) -> big_uint:
        tmp = big_uint(1)
        for qi in self.q()[:level + 1]: tmp *= qi.ext_to_bigint()
        return tmp


class ParametersLiteral:
    logn: int
    q: list[u64]
    p: list[u64]
    logq: list[int]
    logp: list[int]
    pow2_base: int
    sigma: float
    h: int
    ring_type: int
    log_slots: int
    default_scale: float

    def __init__(self, logn, logq, logp, log_slots, default_scale):
        self.logn = logn
        self.q = list[u64]()
        self.p = list[u64]()
        self.logq = logq
        self.logp = logp
        self.log_slots = log_slots
        self.default_scale = default_scale

    def rlwe_parameters(self):
        return rlwe.ParametersLiteral(
            logn=self.logn,
            q=self.q,
            p=self.p,
            logq=self.logq,
            logp=self.logp,
            pow2_base=self.pow2_base,
            sigma=self.sigma,
            h=self.h,
            ring_type=self.ring_type)


class KeyGenerator(RLWEKeyGen):
    ckks_params: Parameters

    def __init__(self, rlwe_keygen, ckks_params):
        self.sk = rlwe_keygen.sk
        self.uniform_sampler = rlwe_keygen.uniform_sampler
        self.params = rlwe_keygen.params
        self.ckks_params = ckks_params
        self.prng = rlwe_keygen.prng
        self.gaussian_sampler = rlwe_keygen.gaussian_sampler
        self.ternary_sampler = rlwe_keygen.ternary_sampler
        self.basisextender = rlwe_keygen.basisextender
        self.buff_q = rlwe_keygen.buff_q
        self.buff_p = rlwe_keygen.buff_p
        self.buff_qp = rlwe_keygen.buff_qp
    
    def __str__(self) -> str:
        return f"""\tCKKSKeyGen:
                \t{self.ckks_params}
                \t{self.get_rlwe_keygen()}
        """
    
    def get_rlwe_keygen(self):
        return RLWEKeyGen(self.get_rlwe_skencryptor())


# Plaintext is is a Element with only one Poly.
class Plaintext(RLWEPlaintext):
    scale: float

    def __init__(self, plaintext, scale):
        self.value = plaintext.value
        self.scale = scale
    
    def __str__(self):
        return f"""\tCKKSPlaintext:
                \tScale: {self.scale}
                \t{self.get_rlwe_plaintext()}
        """
    
    def get_rlwe_plaintext(self):
        return RLWEPlaintext(value=self.value)


# Ciphertext is *ring.Poly array representing a polynomial of degree > 0 with coefficients in R_Q.
class Ciphertext(RLWECiphertext):
    scale: float

    def __init__(self, ciphertext, scale):
        self.value = ciphertext.value
        self.scale = scale
    
    def __str__(self):
        return f"""\tCKKSCiphertext:
                \tScale: {self.scale}
                \t{self.get_rlwe_ciphertext()}
        """

    def __bool__(self):
        is_valid_ct = True
        for v in self.value: is_valid_ct &= bool(v)
        return is_valid_ct

    def __eq__(self, other: Ciphertext) -> bool:
        is_equal = True

        for self_v, other_v in zip(self.value, other.value):
            is_equal &= (self_v == other_v)
        
        return is_equal and (self.scale == other.scale)
    
    def __ne__(self, other: Ciphertext) -> bool:
        return not self == other

    def get_rlwe_ciphertext(self):
        return RLWECiphertext(value=self.value)
    
    # SetScale sets the scaling factor of the ciphertext
    def set_scale(self, scale: float):
        self.scale = scale


class PkEncryptor(RLWEPkEncryptor):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buff_q = rlwe_enc.buff_q
        self.buff_p = rlwe_enc.buff_p
        self.buff_qp = rlwe_enc.buff_qp

        self.pk = rlwe_enc.pk

        self.ckks_params = params


# new_ciphertext creates a new Ciphertext parameterized by degree, level and scale.
def new_ciphertext(params: Parameters, degree: int, level: int, scale: float) -> Ciphertext:
	ciphertext = Ciphertext(
        ciphertext=rlwe.new_ciphertext(params.get_rlwe_params(), degree, level),
        scale=scale)
	for pol in ciphertext.value: pol.is_ntt = True
	return ciphertext


class SkEncryptor(RLWESkEncryptor):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buff_q = rlwe_enc.buff_q
        self.buff_p = rlwe_enc.buff_p
        self.buff_qp = rlwe_enc.buff_qp

        self.sk = rlwe_enc.sk
        self.uniform_sampler = rlwe_enc.uniform_sampler

        self.ckks_params = params
    
    # encrypt_new encrypts the input plaintext returns the result as a newly allocated ciphertext.
    # The level of the output ciphertext is min(plaintext.level(), ciphertext.level()).
    def encrypt_new(self, plaintext: Plaintext) -> Ciphertext:
        ciphertext = new_ciphertext(self.ckks_params, 1, plaintext.level(), plaintext.scale)
        self.encrypt(plaintext.get_rlwe_plaintext(), ciphertext.get_rlwe_ciphertext())
        return ciphertext


# NewPlaintext creates a new Plaintext of level level and scale scale.
def new_plaintext(params: Parameters, level: int, scale: float) -> Plaintext:
	pt = Plaintext(
        plaintext=rlwe.new_plaintext(params.get_rlwe_params(), level),
        scale=scale)
	pt.value.is_ntt = True
	return pt


class Decryptor(RLWEDecryptor):
    params: Parameters

    def __init__(self, rlwe_dec, params):
        self.ring_q = rlwe_dec.ring_q
        self.buff = rlwe_dec.buff
        self.sk = rlwe_dec.sk

        self.params = params
    
    def __str__(self):
        return f"""\tCKKSDecryptor:
                \t{self.params}
                \t{self.get_rlwe_decryptor()}
        """
    
    def get_rlwe_decryptor(self):
        return RLWEDecryptor(self.ring_q, self.buff, self.sk)
    
    # decrypt decrypts the ciphertext and write the result in ptOut.
    def decrypt_new(self, ciphertext: Ciphertext) -> Plaintext:
        pt = new_plaintext(self.params, ciphertext.level(), ciphertext.scale)
        self.decrypt(ciphertext.get_rlwe_ciphertext(), pt.get_rlwe_plaintext())
        return pt


# encoder is a struct storing the necessary parameters to encode a slice of complex number on a Plaintext.
class Encoder:
    params: Parameters
    bigint_chain: list[big_uint]
    bigint_coeffs: list[big_uint]
    q_half: big_uint
    buff: ring.Poly
    m: int
    rot_group: list[int]
    gaussian_sampler: ring.GaussianSampler


def new_parameters(rlwe_params, log_slots, default_scale):
    if not rlwe_params: raise ValueError("provided RLWE parameters are invalid")

    max_log_slots = int(rlwe_params.ring_q.nth_root.bitlen()) - 3

    if log_slots > max_log_slots or log_slots < MIN_LOG_SLOTS:
        raise ValueError(f"logSlot={log_slots} is larger than the logn-1={max_log_slots} or smaller than {MIN_LOG_SLOTS}")

    return Parameters(log_slots, default_scale).from_rlwe_params(rlwe_params)


def new_parameters_from_literal(pl):
    rlwe_params = rlwe.new_parameters_from_literal(pl.rlwe_parameters())

    if pl.log_slots == 0:
        if pl.ring_type == ring.StandardRing: pl.log_slots = pl.logn - 1
        elif pl.ring_type == ring.ConjugateInvariantRing: pl.log_slots = pl.logn

    return new_parameters(rlwe_params, pl.log_slots, pl.default_scale)


# NewKeyGenerator creates a RLWEKeyGen instance from the CKKS parameters.
def new_key_generator(params):
    return KeyGenerator(rlwe.new_key_generator(params.get_rlwe_params()), params)


# NewEncryptor instantiates a new Encryptor for the CKKS scheme. The key argument can
# be *rlwe.PublicKey, *rlwe.SecretKey or nil.
def new_encryptor(params: Parameters, key):
    if isinstance(key, rlwe.PublicKey):
        return PkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    elif isinstance(key, rlwe.SecretKey):
        return SkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    else:
	    raise ValueError("cannot NewEncryptor: key must be either *rlwe.PublicKey or *rlwe.SecretKey")


# NewDecryptor instantiates a Decryptor for the CKKS scheme.
def new_decryptor(params: Parameters, sk: rlwe.SecretKey) -> Decryptor:
	return Decryptor(rlwe.new_decryptor(params.get_rlwe_params(), sk), params)


def gen_bigint_chain(q: list[u64]) -> list[big_uint]:
    num_bits_total = 1
    for m in q: num_bits_total += int(m.bitlen())
    assert num_bits_total <= BIG_INT_LEN, (
        f"Moduli product too large for the bigint in use. Increase the bigint size."
        f" Current bigint size: {BIG_INT_LEN}. Required size: {num_bits_total}")

    bigint_chain = list[big_uint](len(q))
    bigint_chain.append(q[0].ext_to_bigint())
	
    for i in range(1, len(q)):
        bigint_chain.append(q[i].ext_to_bigint())
        bigint_chain[i] *= bigint_chain[i-1]
	
    return bigint_chain


def new_encoder(params: Parameters) -> Encoder:
	m = int(params.ring_q.nth_root)

	rot_group = list[int](m >> 1)
	five_pows = 1
	for _ in range(m >> 2):
		rot_group.append(five_pows) 
		five_pows *= GALOIS_GEN
		five_pows &= (m - 1)

	gaussian_sampler = ring.new_gaussian_sampler(utils.new_prng(), params.ring_q, params.sigma, int(6 * params.sigma))

	return Encoder(
		params=params,
		bigint_chain=gen_bigint_chain(params.q()),
		bigint_coeffs=zeros_vec(m >> 1, TP=big_uint),
		q_half=big_uint(0),
		buff=params.ring_q.new_poly(),
		m=m,
		rot_group=rot_group,
		gaussian_sampler=gaussian_sampler)


# SliceBitReverseInPlaceComplex128 applies an in-place bit-reverse permuation on the input slice.
def slice_bit_reverse_in_place_complex128(slice: list[Complex], n: int):
    j = 0

    for i in range(1, n):
        bit = n >> 1

        while j >= bit:
            j -= bit
            bit >>= 1

        j += bit

        if i < j: slice[i], slice[j] = slice[j], slice[i]


# SpecialiFFTVec performs the CKKS special inverse FFT transform in place.
def special_ifft_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                j, k = j + 1, k + 1

    for i in range(n):
        values[i] /= Complex(float(n), 0)

    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTVec performs the CKKS special FFT transform in place.
def special_fft_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    slice_bit_reverse_in_place_complex128(values, n)
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]

                j, k = j + 1, k + 1


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[Complex], scale_val: Complex):
	for i in range(len(values)): values[i] /= scale_val


# SpecialiFFTUL8Vec performs the CKKS special inverse FFT transform in place with unrolled loops of size 8.
def special_ifft_ul8_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], (values[k + 1] - values[k + lenh + 1]) * roots[(lenq - (rot_group[j + 1] & mask)) << log_gap]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], (values[k + 2] - values[k + lenh + 2]) * roots[(lenq - (rot_group[j + 2] & mask)) << log_gap]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], (values[k + 3] - values[k + lenh + 3]) * roots[(lenq - (rot_group[j + 3] & mask)) << log_gap]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], (values[k + 4] - values[k + lenh + 4]) * roots[(lenq - (rot_group[j + 4] & mask)) << log_gap]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], (values[k + 5] - values[k + lenh + 5]) * roots[(lenq - (rot_group[j + 5] & mask)) << log_gap]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], (values[k + 6] - values[k + lenh + 6]) * roots[(lenq - (rot_group[j + 6] & mask)) << log_gap]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], (values[k + 7] - values[k + lenh + 7]) * roots[(lenq - (rot_group[j + 7] & mask)) << log_gap]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]
            psi4 = roots[(lenq - (rot_group[4] & mask)) << log_gap]
            psi5 = roots[(lenq - (rot_group[5] & mask)) << log_gap]
            psi6 = roots[(lenq - (rot_group[6] & mask)) << log_gap]
            psi7 = roots[(lenq - (rot_group[7] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 8] = values[i] + values[i + 8], (values[i] - values[i + 8]) * psi0
                values[i + 1], values[i + 9] = values[i + 1] + values[i + 9], (values[i + 1] - values[i + 9]) * psi1
                values[i + 2], values[i + 10] = values[i + 2] + values[i + 10], (values[i + 2] - values[i + 10]) * psi2
                values[i + 3], values[i + 11] = values[i + 3] + values[i + 11], (values[i + 3] - values[i + 11]) * psi3
                values[i + 4], values[i + 12] = values[i + 4] + values[i + 12], (values[i + 4] - values[i + 12]) * psi4
                values[i + 5], values[i + 13] = values[i + 5] + values[i + 13], (values[i + 5] - values[i + 13]) * psi5
                values[i + 6], values[i + 14] = values[i + 6] + values[i + 14], (values[i + 6] - values[i + 14]) * psi6
                values[i + 7], values[i + 15] = values[i + 7] + values[i + 15], (values[i + 7] - values[i + 15]) * psi7

        elif lenh == 4:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 4] = values[i] + values[i + 4], (values[i] - values[i + 4]) * psi0
                values[i + 1], values[i + 5] = values[i + 1] + values[i + 5], (values[i + 1] - values[i + 5]) * psi1
                values[i + 2], values[i + 6] = values[i + 2] + values[i + 6], (values[i + 2] - values[i + 6]) * psi2
                values[i + 3], values[i + 7] = values[i + 3] + values[i + 7], (values[i + 3] - values[i + 7]) * psi3
                values[i + 8], values[i + 12] = values[i + 8] + values[i + 12], (values[i + 8] - values[i + 12]) * psi0
                values[i + 9], values[i + 13] = values[i + 9] + values[i + 13], (values[i + 9] - values[i + 13]) * psi1
                values[i + 10], values[i + 14] = values[i + 10] + values[i + 14], (values[i + 10] - values[i + 14]) * psi2
                values[i + 11], values[i + 15] = values[i + 11] + values[i + 15], (values[i + 11] - values[i + 15]) * psi3
        elif lenh == 2:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 2] = values[i] + values[i + 2], (values[i] - values[i + 2]) * psi0
                values[i + 1], values[i + 3] = values[i + 1] + values[i + 3], (values[i + 1] - values[i + 3]) * psi1
                values[i + 4], values[i + 6] = values[i + 4] + values[i + 6], (values[i + 4] - values[i + 6]) * psi0
                values[i + 5], values[i + 7] = values[i + 5] + values[i + 7], (values[i + 5] - values[i + 7]) * psi1
                values[i + 8], values[i + 10] = values[i + 8] + values[i + 10], (values[i + 8] - values[i + 10]) * psi0
                values[i + 9], values[i + 11] = values[i + 9] + values[i + 11], (values[i + 9] - values[i + 11]) * psi1
                values[i + 12], values[i + 14] = values[i + 12] + values[i + 14], (values[i + 12] - values[i + 14]) * psi0
                values[i + 13], values[i + 15] = values[i + 13] + values[i + 15], (values[i + 13] - values[i + 15]) * psi1
        elif lenh == 1:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 1] = values[i] + values[i + 1], (values[i] - values[i + 1]) * psi0
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], (values[i + 2] - values[i + 3]) * psi0
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], (values[i + 4] - values[i + 5]) * psi0
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], (values[i + 6] - values[i + 7]) * psi0
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], (values[i + 8] - values[i + 9]) * psi0
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], (values[i + 10] - values[i + 11]) * psi0
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], (values[i + 12] - values[i + 13]) * psi0
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], (values[i + 14] - values[i + 15]) * psi0

    divide_complex128_slice_vec(values, Complex(float(n), 0))
    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTUL8Vec performs the CKKS special FFT transform in place with unrolled loops of size 8.
def special_fft_ul8_vec(values: list[Complex], n: int, m: int, rot_group: list[int], roots: list[Complex]):
    slice_bit_reverse_in_place_complex128(values, n)

    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                    values[k + lenh + 1] *= roots[(rot_group[j + 1] & mask) << log_gap]
                    values[k + lenh + 2] *= roots[(rot_group[j + 2] & mask) << log_gap]
                    values[k + lenh + 3] *= roots[(rot_group[j + 3] & mask) << log_gap]
                    values[k + lenh + 4] *= roots[(rot_group[j + 4] & mask) << log_gap]
                    values[k + lenh + 5] *= roots[(rot_group[j + 5] & mask) << log_gap]
                    values[k + lenh + 6] *= roots[(rot_group[j + 6] & mask) << log_gap]
                    values[k + lenh + 7] *= roots[(rot_group[j + 7] & mask) << log_gap]

                    values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], values[k + 1] - values[k + lenh + 1]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], values[k + 2] - values[k + lenh + 2]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], values[k + 3] - values[k + lenh + 3]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], values[k + 4] - values[k + lenh + 4]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], values[k + 5] - values[k + lenh + 5]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], values[k + 6] - values[k + lenh + 6]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], values[k + 7] - values[k + lenh + 7]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]
            psi4 = roots[(rot_group[4] & mask) << log_gap]
            psi5 = roots[(rot_group[5] & mask) << log_gap]
            psi6 = roots[(rot_group[6] & mask) << log_gap]
            psi7 = roots[(rot_group[7] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 8] *= psi0
                values[i + 9] *= psi1
                values[i + 10] *= psi2
                values[i + 11] *= psi3
                values[i + 12] *= psi4
                values[i + 13] *= psi5
                values[i + 14] *= psi6
                values[i + 15] *= psi7

                values[i], values[i + 8] = values[i]+values[i + 8], values[i] - values[i + 8]
                values[i + 1], values[i + 9] = values[i + 1]+values[i + 9], values[i + 1] - values[i + 9]
                values[i + 2], values[i + 10] = values[i + 2]+values[i + 10], values[i + 2] - values[i + 10]
                values[i + 3], values[i + 11] = values[i + 3]+values[i + 11], values[i + 3] - values[i + 11]
                values[i + 4], values[i + 12] = values[i + 4]+values[i + 12], values[i + 4] - values[i + 12]
                values[i + 5], values[i + 13] = values[i + 5]+values[i + 13], values[i + 5] - values[i + 13]
                values[i + 6], values[i + 14] = values[i + 6]+values[i + 14], values[i + 6] - values[i + 14]
                values[i + 7], values[i + 15] = values[i + 7]+values[i + 15], values[i + 7] - values[i + 15]
        elif lenh == 4:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 4] *= psi0
                values[i + 5] *= psi1
                values[i + 6] *= psi2
                values[i + 7] *= psi3
                values[i + 12] *= psi0
                values[i + 13] *= psi1
                values[i + 14] *= psi2
                values[i + 15] *= psi3

                values[i], values[i + 4] = values[i]+values[i + 4], values[i] - values[i + 4]
                values[i + 1], values[i + 5] = values[i + 1]+values[i + 5], values[i + 1] - values[i + 5]
                values[i + 2], values[i + 6] = values[i + 2]+values[i + 6], values[i + 2] - values[i + 6]
                values[i + 3], values[i + 7] = values[i + 3]+values[i + 7], values[i + 3] - values[i + 7]
                values[i + 8], values[i + 12] = values[i + 8]+values[i + 12], values[i + 8] - values[i + 12]
                values[i + 9], values[i + 13] = values[i + 9]+values[i + 13], values[i + 9] - values[i + 13]
                values[i + 10], values[i + 14] = values[i + 10]+values[i + 14], values[i + 10] - values[i + 14]
                values[i + 11], values[i + 15] = values[i + 11]+values[i + 15], values[i + 11] - values[i + 15]
        elif lenh == 2:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 2] *= psi0
                values[i + 3] *= psi1
                values[i + 6] *= psi0
                values[i + 7] *= psi1
                values[i + 10] *= psi0
                values[i + 11] *= psi1
                values[i + 14] *= psi0
                values[i + 15] *= psi1

                values[i], values[i + 2] = values[i]+values[i + 2], values[i] - values[i + 2]
                values[i + 1], values[i + 3] = values[i + 1]+values[i + 3], values[i + 1] - values[i + 3]
                values[i + 4], values[i + 6] = values[i + 4]+values[i + 6], values[i + 4] - values[i + 6]
                values[i + 5], values[i + 7] = values[i + 5]+values[i + 7], values[i + 5] - values[i + 7]
                values[i + 8], values[i + 10] = values[i + 8]+values[i + 10], values[i + 8] - values[i + 10]
                values[i + 9], values[i + 11] = values[i + 9]+values[i + 11], values[i + 9] - values[i + 11]
                values[i + 12], values[i + 14] = values[i + 12]+values[i + 14], values[i + 12] - values[i + 14]
                values[i + 13], values[i + 15] = values[i + 13]+values[i + 15], values[i + 13] - values[i + 15]
        elif lenh == 1:
            psi0 = roots[(rot_group[0] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 1] *= psi0
                values[i + 3] *= psi0
                values[i + 5] *= psi0
                values[i + 7] *= psi0
                values[i + 9] *= psi0
                values[i + 11] *= psi0
                values[i + 13] *= psi0
                values[i + 15] *= psi0

                values[i], values[i + 1] = values[i] + values[i + 1], values[i] - values[i + 1]
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], values[i + 2] - values[i + 3]
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], values[i + 4] - values[i + 5]
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], values[i + 6] - values[i + 7]
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], values[i + 8] - values[i + 9]
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], values[i + 10] - values[i + 11]
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], values[i + 12] - values[i + 13]
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], values[i + 14] - values[i + 15]


def single_float_to_fixed_point_crt(level: int, i: int, value: float, scale: float, ring_q: ring.Ring, coeffs: list[list[u64]]):
    is_negative = False

    if value < 0:
        is_negative = True
        scale *= -1

    value *= scale
    moduli = ring_q.modulus

    if value > 1.8446744073709552e+19:
        # x_flo = big_float(value)
        # x_flo += big_float(0.5)
        # x_int = big_uint(x_flo)
        # for j, qi in enumerate(moduli[:level + 1]):
        #     tmp = x_int % qi
        #     if is_negative: coeffs[j][i] = qi - tmp
        #     else: coeffs[j][i] = tmp
        raise NotImplementedError()
    else:
        bred_params = ring_q.bred_params

        c = u64(int(value + 0.5))
        if is_negative:
            for j, qi in enumerate(moduli[:level + 1]):
                if c > qi: coeffs[j][i] = qi - ring.bred_add(c, qi, bred_params[j])
                else: coeffs[j][i] = qi - c
        else:
            for j, qi in enumerate(moduli[:level + 1]):
                if c > u64(0x1fffffffffffffff): coeffs[j][i] = ring.bred_add(c, qi, bred_params[j])
                else: coeffs[j][i] = c


# NttAndMontgomeryLvl takes the polynomial polIn Z[Y] outside of the NTT domain to the polynomial Z[X] in the NTT domain where Y = X^(gap).
# This method is used to accelerate the NTT of polynomials that encode sparse plaintexts.
def ntt_and_montgomery_lvl(level: int, log_slots: int, ring_q: ring.Ring, montgomery: bool, pol: ring.Poly):
    if u64(1 << log_slots) == ring_q.nth_root >> u64(2):
        ring_q.ntt_lvl(level, pol, pol)
        if montgomery: ring_q.mform_lvl(level, pol, pol)
    else:
        n = 0
        
        if ring_q.type() == ring.StandardRing:
            n = 2 << log_slots
        elif ring_q.type() == ring.ConjugateInvariantRing:
            n = 1 << log_slots
            # NTT = ring_NTTConjugateInvariant
            raise NotImplementedError()
        else: raise ValueError("Invalid ring type")

        gap = ring_q.n // n
        for i in range(level + 1):
            coeffs = pol.coeffs[i]

            # NTT in dimension n
            ring.ntt(coeffs, coeffs, n, ring_q.ntt_psi[i], ring_q.modulus[i], ring_q.mred_params[i], ring_q.bred_params[i])
            if montgomery: ring.mform_vec(coeffs, coeffs, ring_q.modulus[i], ring_q.bred_params[i])

            # Maps NTT in dimension n to NTT in dimension n
            for j in range(n - 1, -1, -1):
                c = coeffs[j]
                for w in range(gap): coeffs[j * gap + w] = c
            
    pol.update_buffer()


def complex_to_fixed_point_crt(level: int, values: list[Complex], scale: float, ring_q: ring.Ring, coeffs: list[list[u64]], is_ring_standard: bool):
    for i, v in enumerate(values):
        single_float_to_fixed_point_crt(level, i, v.r, scale, ring_q, coeffs)

    if is_ring_standard:
        slots = len(values)
        for i, v in enumerate(values):
            single_float_to_fixed_point_crt(level, i + slots, v.i, scale, ring_q, coeffs)


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[Complex], scale_val: Complex):
	for i in range(len(values)): values[i] /= scale_val


def poly_to_complex_no_crt(coeffs: list[u64], values: list[Complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring):
    slots = 1 << log_slots
    max_slots = int(ring_q.nth_root >> u64(2))
    gap = max_slots // slots
    q = ring_q.modulus[0]

    c = u64(0)
    i, idx = 0, 0
    while i < slots:
        c = coeffs[idx]
        if c >= q >> u64(1): values[i] = Complex(-float(q - c), 0)
        else: values[i] = Complex(float(c), 0)
        i, idx = i + 1, idx + gap

    if not isreal:
        i, idx = 0, max_slots
        while i < slots:
            c = coeffs[idx]
            if c >= q >> u64(1): values[i] += Complex(0, -float(q - c))
            else: values[i] += Complex(0, float(c))
            i, idx = i + 1, idx + gap

    divide_complex128_slice_vec(values, Complex(scale, 0))


# Divides x by n^2, returns a float
def scale_down(coeff: big_int, n: float) -> float:
    return coeff.to_float() / n


def poly_to_complex_crt(poly: ring.Poly, bigint_coeffs: list[big_uint], values: list[Complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring, q: big_uint):
    max_slots = int(ring_q.nth_root >> u64(2))
    slots = 1 << log_slots
    gap = max_slots // slots

    ring_q.poly_to_bigint(poly, gap, bigint_coeffs)

    q_half = q >> big_uint(1)

    for i in range(slots):
        c = bigint_coeffs[i]
        c = c.bigint_mod(q)
        c_intn = c.to_intn()
        if c >= q_half: c_intn -= q.to_intn()
        values[i] = Complex(scale_down(c_intn, scale), 0)
    
    if not isreal:
        i, j = 0, slots
        while i < slots:
            c = bigint_coeffs[j]
            c = c.bigint_mod(q)
            c_intn = c.to_intn()  # TODO: Handle edge-case where c_intn != c due to sign bit (make sure big_int is big enough)
            if c >= q_half: c_intn -= q.to_intn()
            values[i] += Complex(0, scale_down(c_intn, scale))

            i, j = i + 1, j + 1
    

# StandardDeviation computes the scaled standard deviation of the input vector.
def standard_deviation(vec: list[float], scale: float) -> float:
    # We assume that the error is centered around zero
    n = float(len(vec))
    mean = 0.0
    err = 0.0

    for c in vec: mean += c
    mean /= n

    for c in vec:
        tmp = c - mean
        err += tmp * tmp

    return math.sqrt(err / n) * scale


class EncoderComplex128(Encoder):
    values: list[Complex]
    values_float: list[float]
    roots: list[Complex]

    def __init__(self, encoder: Encoder, roots: list[Complex], values: list[Complex], values_float: list[float]):
        self.params=encoder.params
        self.bigint_chain=encoder.bigint_chain
        self.bigint_coeffs=encoder.bigint_coeffs
        self.q_half=encoder.q_half
        self.buff=encoder.buff
        self.m=encoder.m
        self.rot_group=encoder.rot_group
        self.gaussian_sampler=encoder.gaussian_sampler

        self.roots=roots
        self.values=values
        self.values_float=values_float
    
    def __str__(self):
        return f"""\tCKKSEncoderComplex:
                \tvalues[:10]: {self.values[:10]}
        """
    
    # encode encodes a set of values on the target plaintext.
    # This method is identical to "EncodeSlots".
    # Encoding is done at the level and scale of the plaintext.
    # User must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariant.
    # Returned plaintext is always in the NTT domain.
    def encode(self, values, plaintext: Plaintext, log_slots: int):
        self.embed(values, log_slots, plaintext.scale, False, plaintext.value)
    
    # embed is a generic method to encode a set of values on the target polyOut interface.
    # This method is at the core of the slot encoding.
    # values: values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariant.
    # logslots: user must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # scale: the scaling factor used do discretize float64 to fixed point integers.
    # montgomery: if True then the value written on polyOut are put in the Montgomery domain.
    # polyOut: polyOut.(type) can be either ringqp.Poly or *ring.Poly.
    # The encoding encoding is done at the level of polyOut.
    # Values written on  polyOut are always in the NTT domain.
    def embed(self, values, log_slots: int, scale: float, montgomery: bool, polyOut):
        if log_slots < MIN_LOG_SLOTS or log_slots > self.params.max_log_slots():
            raise ValueError(f"cannot embed: log_slots ({log_slots}) must be greater or equal to {MIN_LOG_SLOTS} and smaller than {self.params.max_log_slots()}\n")

        slots = 1 << log_slots
        len_values = 0

        # First checks the type of input values
        # If complex
        if isinstance(values, list[Complex]):
            # Checks that the number of values is with the possible range
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            if self.params.ring_type == ring.StandardRing:
                self.values[:len_values] = [v.copy() for v in values]
            elif self.params.ring_type == ring.ConjugateInvariantRing:
                # Discards the imaginary part
                for i, v in enumerate(values):
                    self.values[i] = Complex(v.r, 0)
            else:
                raise ValueError("cannot embed: ring_type must be ring.Standard or ring.ConjugateInvariant")
        # If floats only
        elif isinstance(values, list[float]):
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            for i, v in enumerate(values):
                self.values[i] = Complex(v, 0)
        else:
            raise ValueError(f"cannot embed: values.(type) must be []complex128 or []float64.")

        for i in range(len_values, slots):
            self.values[i] = Complex(0)

        if log_slots < 4:
            special_ifft_vec(self.values, slots, self.m, self.rot_group, self.roots)
        else:
            special_ifft_ul8_vec(self.values, slots, self.m, self.rot_group, self.roots)

        is_ring_standard = self.params.ring_type == ring.StandardRing

        if isinstance(polyOut, ringqp.Poly):
            complex_to_fixed_point_crt(polyOut.q.level(), self.values[:slots], scale, self.params.ring_q, self.q.coeffs, is_ring_standard)
            ntt_and_montgomery_lvl(polyOut.q.level(), log_slots, self.params.ring_q, montgomery, polyOut.q)

            if polyOut.p:
                complex_to_fixed_point_crt(polyOut.p.level(), self.values[:slots], scale, self.params.ring_p, polyOut.p.coeffs, is_ring_standard)
                ntt_and_montgomery_lvl(polyOut.p.level(), log_slots, self.params.ring_p, montgomery, polyOut.p)
        elif isinstance(polyOut, ring.Poly):
            complex_to_fixed_point_crt(polyOut.level(), self.values[:slots], scale, self.params.ring_q, polyOut.coeffs, is_ring_standard)
            polyOut.update_buffer()
            ntt_and_montgomery_lvl(polyOut.level(), log_slots, self.params.ring_q, montgomery, polyOut)
        else:
            raise ValueError("cannot embed: invalid polyOut.(type) must be ringqp.Poly or *ring.Poly")

    # decode decodes the input plaintext on a new slice of complex128.
    # This method is the same as .DecodeSlots(*).
    def decode(self, plaintext: Plaintext, log_slots: int):
        return self.decode_slots_public(plaintext, log_slots, 0)
    
    # decode_slots_public decodes the input plaintext on a new slice of complex128.
    # Adds, before the decoding step, an error with standard deviation sigma and bound floor(sqrt(2*pi)*sigma).
    # If the underlying ring_type is ConjugateInvariant, the imaginary part (and
    # its related error) are zero.
    def decode_slots_public(self, plaintext: Plaintext, log_slots: int, bound: float):
        return self.decode_public(plaintext, log_slots, bound)
    
    def decode_public(self, plaintext: Plaintext, log_slots: int, sigma: float):
        if log_slots > self.params.max_log_slots() or log_slots < MIN_LOG_SLOTS:
            raise ValueError(f"cannot decode: ensure that {MIN_LOG_SLOTS} <= log_slots ({log_slots}) <= {self.params.max_log_slots()}")

        if plaintext.value.is_ntt:
            self.params.ring_q.inv_ntt_lvl(plaintext.level(), plaintext.value, self.buff)
        else:
            ring.copy_values_lvl(plaintext.level(), plaintext.value, self.buff)

        # B = floor(sigma * sqrt(2*pi))
        if sigma != 0:
            self.gaussian_sampler.read_and_add_from_dist_lvl(plaintext.level(), self.buff, self.params.ring_q, sigma, int(2.5066282746310002 * sigma))
        
        self.plaintext_to_complex(plaintext.level(), plaintext.scale, log_slots, self.buff, self.values)

        if log_slots < 3:
            special_fft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else:
            special_fft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        return [v.copy() for v in self.values]
    
    def plaintext_to_complex(self, level: int, scale: float, log_slots: int, p: ring.Poly, values: list[Complex]):
        isreal = self.params.ring_type == ring.ConjugateInvariantRing
        if level == 0:
            poly_to_complex_no_crt(p.coeffs[0], values, scale, log_slots, isreal, self.params.ring_q)
        else:
            poly_to_complex_crt(p, self.bigint_coeffs, values, scale, log_slots, isreal, self.params.ring_q, self.bigint_chain[level])

        if isreal: # [X]/(X^n+1) to [X+X^-1]/(X^n+1)
            slots = 1 << log_slots
            for i in range(1, slots): self.values[i] -= Complex(0, self.values[slots-i].r)
    
    # get_err_std_slot_domain returns StandardDeviation(values_want-values_have)*scale
    # which is the scaled standard deviation of two complex vectors.
    def get_err_std_slot_domain(self, values_want: list[Complex], values_have: list[Complex], scale: float) -> float:
        for i in range(len(values_want)):
            err = values_want[i] - values_have[i]
            self.values_float[2 * i] = err.r
            self.values_float[2 * i + 1] = err.i

        return standard_deviation(self.values_float[:len(values_want) * 2], scale)
    
    # get_err_std_coeff_domain returns StandardDeviation(encode(values_want-values_have))*scale
    # which is the scaled standard deviation in the coefficient domain of the difference
    # of two complex vector in the slot domain.
    def get_err_std_coeff_domain(self, values_want: list[Complex], values_have: list[Complex], scale: float) -> float:
        for i in range(len(values_have)): self.values[i] = (values_want[i] - values_have[i])
        for i in range(len(values_have), len(self.values)): self.values[i] = Complex(0, 0)

        log_slots = int((len(values_have) - 1).bitlen())

        # Runs FFT^-1 with the smallest power of two length that is greater than the input size
        if log_slots < 3: special_ifft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else: special_ifft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        for i in range(len(values_want)):
            self.values_float[2 * i] = self.values[i].r
            self.values_float[2 * i + 1] = self.values[i].i

        return standard_deviation(self.values_float[:len(values_want) * 2], scale)


# NewEncoder creates a new Encoder that is used to encode a slice of complex values of size at most n/2 (the number of slots) on a Plaintext.
def new_encoder_complex(params: Parameters) -> EncoderComplex128:
	ecd = new_encoder(params)

	roots = list[Complex](ecd.m + 1)
	for i in range(ecd.m):
		angle = 2 * 3.141592653589793 * i / ecd.m
		roots.append(Complex(math.cos(angle), math.sin(angle)))

	roots.append(roots[0])

	return EncoderComplex128(
        encoder=ecd,
        roots=roots,
        values=zeros_vec(ecd.m >> 2, TP=Complex),
        values_float=zeros_vec(ecd.m >> 1, TP=float))


# Stats is a struct storing the real, imaginary and l2 norm (modulus)
# about the precision of a complex value.
class Stats:
    real: float
    imag: float
    l2: float


# PrecisionStats is a struct storing statistic about the precision of a CKKS plaintext
class PrecisionStats:
    max_delta: Stats
    min_delta: Stats
    max_precision: Stats
    min_precision: Stats
    mean_delta: Stats
    mean_precision: Stats
    median_delta: Stats
    median_precision: Stats
    std_freq: float
    std_time: float

    real_dist: list[dict[str, float]]
    imag_dist: list[dict[str, float]]
    l2_dist: list[dict[str, float]]

    cdf_resol: int

    def __str__(self) -> str:
        return f"""
            ┌─────────┬───────┬───────┬───────┐
            │    Log2 │ REAL  │ IMAG  │ l2    │
            ├─────────┼───────┼───────┼───────┤
            │MIN Prec │ {round(self.min_precision.real, 2)} │ {round(self.min_precision.imag, 2)} │ {round(self.min_precision.l2, 2)} │
            │MAX Prec │ {round(self.max_precision.real, 2)} │ {round(self.max_precision.imag, 2)} │ {round(self.max_precision.l2, 2)} │
            │AVG Prec │ {round(self.mean_precision.real, 2)} │ {round(self.mean_precision.imag, 2)} │ {round(self.mean_precision.l2, 2)} │
            │MED Prec │ {round(self.median_precision.real, 2)} │ {round(self.median_precision.imag, 2)} │ {round(self.median_precision.l2, 2)} │
            └─────────┴───────┴───────┴───────┘

            Err STD Slots  : {math.log2(self.std_freq)} Log2
            Err STD coeffs : {math.log2(self.std_time)} Log2
        """
    
    def calc_cdf(self, precs: list[float], res: list[dict[str, float]]):
        sorted_precs = sorted(precs)
        min_prec = sorted_precs[0]
        max_prec = sorted_precs[len(sorted_precs)-1]
        for i in range(self.cdf_resol):
            cur_prec = min_prec + float(i) * (max_prec - min_prec) / float(self.cdf_resol)
            for count_smaller, p in enumerate(sorted_precs):
                if p >= cur_prec:
                    res[i]["Prec"] = cur_prec
                    res[i]["Count"] = count_smaller
                    break


def delta_to_precision(c: Stats) -> Stats:
	return Stats(math.log2(1 / c.real), math.log2(1 / c.imag), math.log2(1 / c.l2))


def calc_median(values: list[Stats]) -> Stats:
    tmp = sorted([v.real for v in values])
    for i in range(len(values)): values[i].real = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].imag
    tmp.sort()
    for i in range(len(values)): values[i].imag = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].l2
    tmp.sort()
    for i in range(len(values)): values[i].l2 = tmp[i]
    index = len(values) // 2
    if len(values) & 1 == 1 or index + 1 == len(values):
        return Stats(values[index].real, values[index].imag, values[index].l2)

    return Stats((values[index].real + values[index+1].real) / 2,
		(values[index].imag + values[index+1].imag) / 2,
		(values[index].l2 + values[index+1].l2) / 2)


# GetPrecisionStats generates a PrecisionStats struct from the reference values and the decrypted values
# vWant.(type) must be either []complex128 or []float64
# element.(type) must be either *Plaintext, *Ciphertext, []complex128 or []float64. If not *Ciphertext, then decryptor can be nil.
def get_precision_stats(
        params: Parameters, encoder: EncoderComplex128,
        v_want: list, element, log_slots: int, sigma: float) -> PrecisionStats:
    values_test = []
    values_want = []
    
    if isinstance(element, Ciphertext):
        raise NotImplementedError()
        # values_test = encoder.decode_public(decryptor.decrypt_new(element), log_slots, sigma)
    elif isinstance(element, Plaintext):
        values_test = encoder.decode_public(element, log_slots, sigma)
    elif isinstance(element, list[Complex]):
        values_test = element
    elif isinstance(element, list[float]):
        values_test = [Complex(e, 0) for e in element]
    else: raise TypeError("Invalid type for test values")

    if isinstance(v_want, list[Complex]): values_want = v_want
    elif isinstance(v_want, list[float]): values_want = [Complex(e, 0) for e in v_want]
    else: raise TypeError("Invalid type for test values")

    slots = len(values_want)
    diff = [Stats() for _ in range(slots)]

    prec = PrecisionStats()
    prec.max_delta = Stats(0, 0, 0)
    prec.min_delta = Stats(1, 1, 1)
    prec.mean_delta = Stats(0, 0, 0)
    prec.cdf_resol = 500
    prec.real_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.imag_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.l2_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]

    prec_real = [0.0 for _ in range(len(values_want))]
    prec_imag = [0.0 for _ in range(len(values_want))]
    prec_l2 = [0.0 for _ in range(len(values_want))]

    for i in range(len(values_want)):
        delta_real = abs(values_test[i].r - values_want[i].r)
        delta_imag = abs(values_test[i].i - values_want[i].i)
        delta_l2 = math.sqrt(delta_real * delta_real + delta_imag * delta_imag)
        prec_real[i] = math.log2(1 / delta_real)
        prec_imag[i] = math.log2(1 / delta_imag)
        prec_l2[i] = math.log2(1 / delta_l2)

        diff[i].real = delta_real
        diff[i].imag = delta_imag
        diff[i].l2 = delta_l2

        prec.mean_delta.real += delta_real
        prec.mean_delta.imag += delta_imag
        prec.mean_delta.l2 += delta_l2

        if delta_real > prec.max_delta.real: prec.max_delta.real = delta_real
        if delta_imag > prec.max_delta.imag: prec.max_delta.imag = delta_imag
        if delta_l2 > prec.max_delta.l2: prec.max_delta.l2 = delta_l2
        if delta_real < prec.min_delta.real: prec.min_delta.real = delta_real
        if delta_imag < prec.min_delta.imag: prec.min_delta.imag = delta_imag
        if delta_l2 < prec.min_delta.l2: prec.min_delta.l2 = delta_l2

    prec.calc_cdf(prec_real, prec.real_dist)
    prec.calc_cdf(prec_imag, prec.imag_dist)
    prec.calc_cdf(prec_l2, prec.l2_dist)
    
    prec.min_precision = delta_to_precision(prec.max_delta)
    prec.max_precision = delta_to_precision(prec.min_delta)
    prec.mean_delta.real /= float(slots)
    prec.mean_delta.imag /= float(slots)
    prec.mean_delta.l2 /= float(slots)
    prec.mean_precision = delta_to_precision(prec.mean_delta)
    prec.median_delta = calc_median(diff)
    prec.median_precision = delta_to_precision(prec.median_delta)
    prec.std_freq = encoder.get_err_std_slot_domain(values_want[:], values_test[:], params.default_scale)
    prec.std_time = encoder.get_err_std_coeff_domain(values_want, values_test, params.default_scale)
    
    return prec


class EvaluatorBuffers:
    buff_q: list[ring.Poly]  #[3] Memory buffer in order: for MForm(c_0), MForm(c_1), c2
    buff_ct: Ciphertext  # Memory buffer for ciphertexts that need to be scaled up (to be eventually removed)


class EvaluatorBase:
	ckks_params: Parameters


def scale_up_exact(value: float, n: float, q: u64) -> u64:
    is_negative = False
    x_flo = 0.0

    if value < 0:
        is_negative = True
        x_flo = -n * value  # big.NewFloat(-n * value)
    else:
        x_flo = n * value  # big.NewFloat(n * value)

    x_flo += 0.5  # x_flo.add(x_flo, big.NewFloat(0.5))

    # x_int = new(big.Int)
    x_int = u64(x_flo)  # x_flo.Int(x_int)
    x_int = x_int.__naive_mod(q)

    res = x_int
    if is_negative: res = q - res

    return res


# evaluator is a struct that holds the necessary elements to execute the homomorphic operations between Ciphertexts and/or Plaintexts.
# It also holds a memory buffer used to store intermediate computations.
class Evaluator(EvaluatorBase, EvaluatorBuffers, RLWEEvaluator):
    def set_evaluator_base(self, eval_base: EvaluatorBase):
        self.ckks_params = eval_base.ckks_params
    
    def set_evaluator_buffers(self, eval_buffers: EvaluatorBuffers):
        self.buff_ct = eval_buffers.buff_ct
        self.buff_q = eval_buffers.buff_q
    
    def set_rlwe_evaluator(self, eval: RLWEEvaluator):
        self.ckks_params.set_rlwe_params(eval.params)
        self.params = eval.params
        
        self.buff_qp = eval.buff_qp
        self.buff_inv_ntt = eval.buff_inv_ntt
        self.buff_decomp_qp = eval.buff_decomp_qp
        self.buff_bit_decomp = eval.buff_bit_decomp

        self.rlk = eval.rlk
        self.rtks = eval.rtks
        self.permute_ntt_index = eval.permute_ntt_index

        self.basis_extender = eval.basis_extender
        self.decomposer = eval.decomposer
    
    def get_evaluator_base(self) -> EvaluatorBase:
        return EvaluatorBase(self.ckks_params)
    
    def get_const_and_scale(self, level: int, constant) -> Tuple[float, float, float]:
        # Converts to float and determines if a scaling is required
        # (which is the case if either real or imag have a rational part)
        scale = 1.0
        c_real, c_imag = 0.0, 0.0

        if isinstance(constant, Complex):
            c_real = constant.r
            c_imag = constant.i

            if c_real != 0:
                value_int = int(c_real)
                value_float = c_real - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])

            if c_imag != 0:
                value_int = int(c_imag)
                value_float = c_imag - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])
        elif isinstance(constant, float):
            c_real = constant
            c_imag = float(0)

            if c_real != 0:
                value_int = int(c_real)
                value_float = c_real - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])
        elif isinstance(constant, u64) or isinstance(constant, int):
            c_real = float(constant)
            c_imag = float(0)
        else:
            raise ValueError("Invalid constant type within ciphertext multiplication.")

        if self.params.ring_type == ring.ConjugateInvariantRing:
            c_imag = float(0)

        return c_real, c_imag, scale
    
    # mult_by_const multiplies ct_0 by the input constant and returns the result in ct_out.
    # The scale of the output element will depend on the scale of the input element and the constant (if the constant
    # needs to be scaled (its rational part is not zero)). The constant can be a u64, int, float or complex128.
    def mult_by_const(self, ct_0: Ciphertext, constant, ct_out: Ciphertext):
        level = min(ct_0.level(), ct_out.level())

        c_real, c_imag, scale = self.get_const_and_scale(int(level), constant)

        # Component wise multiplication of the following vector with the ciphertext:
        # [a + b*psi_qi^2, ....., a + b*psi_qi^2, a - b*psi_qi^2, ...., a - b*psi_qi^2] mod Qi
        # [{                  N/2                }{                N/2               }]
        # Which is equivalent outside of the NTT domain to adding a to the first coefficient of ct_0 and b to the N/2-th coefficient of ct_0.
        ring_q = self.params.ring_q
        for i in range(level + 1):
            qi = ring_q.modulus[i]
            bred_params = ring_q.bred_params[i]
            mred_params = ring_q.mred_params[i]

            scaled_const_real = u64(0)
            scaled_const_imag = u64(0)
            scaled_const = u64(0)

            if c_real != 0:
                scaled_const_real = scale_up_exact(c_real, scale, qi)
                scaled_const = scaled_const_real

            if c_imag != 0:
                scaled_const_imag = scale_up_exact(c_imag, scale, qi)
                scaled_const_imag = ring.mred(scaled_const_imag, ring_q.ntt_psi[i][1], qi, mred_params)
                scaled_const = ring.cred(scaled_const + scaled_const_imag, qi)

            scaled_const = ring.mform(scaled_const, qi, bred_params)

            for u in range(len(ct_0.value)):
                p0_tmp = ct_0.value[u].coeffs[i]
                p1_tmp = ct_out.value[u].coeffs[i]
                ring.mul_scalar_montgomery_vec(p0_tmp[:ring_q.n >> 1], p1_tmp[:ring_q.n >> 1], scaled_const, qi, mred_params)

            if c_imag != 0:
                scaled_const = ring.cred(scaled_const_real + (qi - scaled_const_imag), qi)
                scaled_const = ring.mform(scaled_const, qi, bred_params)

            for u in range(len(ct_0.value)):
                p0_tmp = ct_0.value[u].coeffs[i]
                p1_tmp = ct_out.value[u].coeffs[i]
                ring.mul_scalar_montgomery_vec(p0_tmp[ring_q.n >> 1:], p1_tmp[ring_q.n >> 1:], scaled_const, qi, mred_params)

        ct_out.scale = ct_0.scale * scale

    # drop_level reduces the level of ct_0 by levels and returns the result in ct_0.
    # No rescaling is applied during this procedure.
    def drop_level(self, ct_0: Ciphertext, levels: int):
        ct_0.resize(ct_0.degree(), ct_0.level() - levels)

    def evaluate_in_place(self, c_0, c_1, ct_out, evaluate_callable):
        level = min(min(c_0.level(), c_1.level()), ct_out.level())
        max_degree = max(c_0.degree(), c_1.degree())
        min_degree = min(c_0.degree(), c_1.degree())

        # Else resizes the receiver element
        ct_out.resize(max_degree, ct_out.level())

        c_0_scale = c_0.scale
        c_1_scale = c_1.scale
        ct_out_scale = ct_out.scale

        if ct_out.level() > level:
            self.drop_level(Ciphertext(ct_out, ct_out_scale), ct_out.level() - min(c_0.level(), c_1.level()))

        tmp_0, tmp_1 = c_0, c_1
        # Checks whether or not the receiver element is the same as one of the input elements
        # and acts accordingly to avoid unnecessary element creation or element overwriting,
        # and scales properly the element before the evaluation.
        if ct_out == c_0:
            if c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                tmp_1 = self.buff_ct
                self.mult_by_const(Ciphertext(c_1, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(tmp_1, ct_out_scale))
            elif c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                self.mult_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(c_0, c_0_scale))
                ct_out.set_scale(c_1_scale)
                tmp_1 = c_1
            else:
                tmp_1 = c_1
            tmp_0 = c_0
        elif ct_out == c_1:
            if c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                tmp_0 = self.buff_ct
                self.mult_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(tmp_0, ct_out_scale))
            elif c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                self.mult_by_const(Ciphertext(c_1, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(ct_out, ct_out_scale))
                ct_out.set_scale(c_0_scale)
                tmp_0 = c_0
            else:
                tmp_0 = c_0
            tmp_1 = c_1
        else:
            if c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                tmp_0 = self.buff_ct
                self.mult_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(tmp_0, ct_out_scale))
                tmp_1 = c_1
            elif c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                tmp_1 = self.buff_ct
                self.mult_by_const(Ciphertext(c_1, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(tmp_1, ct_out_scale))
                tmp_0 = c_0
            else:
                tmp_0 = c_0
                tmp_1 = c_1

        for i in range(min_degree + 1):
            if evaluate_callable == "ring.add_lvl":
                self.params.ring_q.add_lvl(level, tmp_0.value[i], tmp_1.value[i], ct_out.value[i])
            elif evaluate_callable == "ring.sub_lvl":
                self.params.ring_q.sub_lvl(level, tmp_0.value[i], tmp_1.value[i], ct_out.value[i])
            else:
                raise NotImplementedError("Generic evaluator supports only addition and subtraction at the moment.")

        ct_out.set_scale(max(c_0_scale, c_1_scale))

        # If the inputs degrees differ, it copies the remaining degree on the receiver.
        # Also checks that the receiver is not one of the inputs to avoid unnecessary work.
        if c_0.degree() > c_1.degree() and tmp_0 != ct_out:
            for i in range(min_degree + 1, max_degree + 1):
                ring.copy_values_lvl(level, tmp_0.value[i], ct_out.value[i])
        elif c_1.degree() > c_0.degree() and tmp_1 != ct_out:
            for i in range(min_degree + 1, max_degree + 1):
                ring.copy_values_lvl(level, tmp_1.value[i], ct_out.value[i])
    
    def new_ciphertext_binary(self, op_0, op_1) -> Ciphertext:
        max_degree = max(op_0.degree(), op_1.degree())
        max_scale = max(op_0.scale, op_1.scale)
        min_level = min(op_0.level(), op_1.level())

        return new_ciphertext(self.ckks_params, max_degree, min_level, max_scale)
    
    def check_binary(self, op_0, op_1, op_out, op_out_min_degree: int):
        if not op_0 or not op_1 or not op_out:
            raise ValueError("cannot check_binary: operands cannot be nil")

        if op_0.degree() + op_1.degree() == 0:
            raise ValueError("cannot check_binary: operands cannot be both plaintext")

        if op_out.degree() < op_out_min_degree:
            raise ValueError("cannot check_binary: receiver operand degree is too small")

        for pol in op_0.value:
            if not pol.is_ntt:
                raise ValueError("cannot check_binary: op_0 must be in NTT")

        for pol in op_1.value:
            if not pol.is_ntt:
                raise ValueError("cannot check_binary: op_1 must be in NTT")

    # neg negates the value of ct_0 and returns the result in ct_out.
    def neg(self, ct_0: Ciphertext, ct_out: Ciphertext):
        level = min(ct_0.level(), ct_out.level())

        if ct_0.degree() != ct_out.degree():
            raise ValueError("cannot Negate: invalid receiver Ciphertext does not match input Ciphertext degree")

        for i in range(len(ct_0.value)):
            self.params.ring_q.neg_lvl(level, ct_0.value[i], ct_out.value[i])

        ct_out.scale = ct_0.scale

    # neg_new negates ct_0 and returns the result in a newly created element.
    def neg_new(self, ct_0: Ciphertext) -> Ciphertext:
        ct_out = new_ciphertext(self.ckks_params, ct_0.degree(), ct_0.level(), ct_0.scale)
        self.neg(ct_0, ct_out)
        return ct_out

    # add adds op_1 to ct_in and returns the result in ct_out.
    def add(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        self.evaluate_in_place(ct_in, op_1, ct_out, "ring.add_lvl")
    
    # add_new adds op_1 to ct_in and returns the result in a newly created element.
    def add_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        ct_out = self.new_ciphertext_binary(ct_in, op_1)
        self.add(ct_in, op_1, ct_out)
        return ct_out
    
    # sub subtracts op_1 from ct_in and returns the result in ct_out.
    def sub(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        self.evaluate_in_place(ct_in, op_1, ct_out, "ring.sub_lvl")

        level = min(min(ct_in.level(), op_1.level()), ct_out.level())
        if ct_in.degree() < op_1.degree():
            for i in range(ct_in.degree() + 1, op_1.degree() + 1):
                self.params.ring_q.neg_lvl(level, ct_out.value[i], ct_out.value[i])

    # sub_new subtracts op_1 from ct_in and returns the result in a newly created element.
    def sub_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        ct_out = self.new_ciphertext_binary(ct_in, op_1)
        self.sub(ct_in, op_1, ct_out)
        return ct_out
    
    # mult_by_i multiplies ct_0 by the imaginary number i, and returns the result in ct_out.
    # It does not change the scale.
    def mult_by_i(self, ct_0: Ciphertext, ct_out: Ciphertext):
        if self.params.ring_type == ring.ConjugateInvariantRing:
            raise ValueError("cannot mult_by_i: method not supported when params.RingType() == ring.ConjugateInvariant")

        level = min(ct_0.level(), ct_out.level())
        ct_out.scale = ct_0.scale
        ring_q = self.params.ring_q

        # Equivalent to a product by the monomial x^(n/2) outside of the NTT domain
        for i in range(level + 1):
            qi = ring_q.modulus[i]
            mred_params = ring_q.mred_params[i]
            imag = ring_q.ntt_psi[i][1]  # Psi^2

            for u in range(len(ct_out.value)):
                p0_tmp = ct_0.value[u].coeffs[i]
                p1_tmp = ct_out.value[u].coeffs[i]
                ring.mul_scalar_montgomery_vec(p0_tmp[:ring_q.n >> 1], p1_tmp, imag, qi, mred_params)
                ct_0.value[u].update_buffer()
                ct_out.value[u].update_buffer()
            
            imag = qi - imag

            for u in range(len(ct_out.value)):
                p0_tmp = ct_0.value[u].coeffs[i]
                p1_tmp = ct_out.value[u].coeffs[i]
                ring.mul_scalar_montgomery_vec(p0_tmp[ring_q.n >> 1:], p1_tmp.slice_reference(ring_q.n >> 1, ring_q.n), imag, qi, mred_params)
                ct_0.value[u].update_buffer()
                ct_out.value[u].update_buffer()

    # mult_by_i_new multiplies ct_0 by the imaginary number i, and returns the result in a newly created element.
    # It does not change the scale.
    def mult_by_i_new(self, ct_0: Ciphertext) -> Ciphertext:
        if self.params.ring_type == ring.ConjugateInvariantRing:
            raise ValueError("cannot mult_by_i_new: method not supported when params.RingType() == ring.ConjugateInvariant")

        ct_out = new_ciphertext(self.ckks_params, 1, ct_0.level(), ct_0.scale)
        self.mult_by_i(ct_0, ct_out)
        return ct_out
    
    # mult_new multiplies ct_in with op_1 without relinearization and returns the result in a newly created element.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    def mult_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        ct_out = new_ciphertext(self.ckks_params, ct_in.degree() + op_1.degree(), min(ct_in.level(), op_1.level()), 0)
        self.mult_relin(ct_in, op_1, False, ct_out)
        return ct_out

    # mult multiplies ct_in with op_1 without relinearization and returns the result in ct_out.
    # The procedure will panic if either ct_in or op_1 are have a degree higher than 1.
    # The procedure will panic if ct_out.degree != ct_in.degree + op_1.degree.
    def mult(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        self.mult_relin(ct_in, op_1, False, ct_out)

    # mult_relin_new multiplies ct_in with op_1 with relinearization and returns the result in a newly created element.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    # The procedure will panic if the evaluator was not created with an relinearization key.
    def mult_relin_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        ct_out = new_ciphertext(self.ckks_params, 1, min(ct_in.level(), op_1.level()), 0)
        self.mult_relin(ct_in, op_1, True, ct_out)
        return ct_out

    # MulRelin multiplies ct_in with op_1 with relinearization and returns the result in ct_out.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    # The procedure will panic if ct_out.degree != ct_in.degree + op_1.degree.
    # The procedure will panic if the evaluator was not created with an relinearization key.
    def mult_relin(self, ct_in: Ciphertext, op_1, relin: bool, ct_out: Ciphertext):
        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        level = min(min(ct_in.level(), op_1.level()), ct_out.level())

        if ct_in.degree() + op_1.degree() > 2:
            raise ValueError("cannot MulRelin: the sum of the input elements' total degree cannot be larger than 2")

        ct_out.scale = ct_in.scale * op_1.scale
        ring_q = self.params.ring_q

        # Case Ciphertext (x) Ciphertext
        if ct_in.degree() == 1 and op_1.degree() == 1:
            c00 = self.buff_q[0]
            c01 = self.buff_q[1]

            c0 = ct_out.value[0]
            c1 = ct_out.value[1]
            c2 = self.buff_q[2]

            if not relin:
                ct_out.resize(2, level)
                c2 = ct_out.value[2]
            else: ct_out.resize(1, level)

            # TODO: Daouble-check the eq check below: Avoid overwriting if the second input is the output
            tmp0, tmp1 = ct_in, op_1
            if op_1 == ct_out:
                tmp0, tmp1 = op_1, ct_in

            ring_q.mform_lvl(level, tmp0.value[0], c00)
            ring_q.mform_lvl(level, tmp0.value[1], c01)

            if ct_in == op_1:  # squaring case
                ring_q.mul_coeffs_montgomery_lvl(level, c00, tmp1.value[0], c0) # c0 = c[0]*c[0]
                ring_q.mul_coeffs_montgomery_lvl(level, c01, tmp1.value[1], c2) # c2 = c[1]*c[1]
                ring_q.mul_coeffs_montgomery_lvl(level, c00, tmp1.value[1], c1) # c1 = 2*c[0]*c[1]
                ring_q.add_lvl(level, c1, c1, c1)
            else:  # regular case
                ring_q.mul_coeffs_montgomery_lvl(level, c00, tmp1.value[0], c0)  # c0 = c0[0]*c0[0]
                ring_q.mul_coeffs_montgomery_lvl(level, c01, tmp1.value[1], c2)  # c2 = c0[1]*c1[1]
                ring_q.mul_coeffs_montgomery_lvl(level, c00, tmp1.value[1], c1)
                ring_q.mul_coeffs_montgomery_and_add_lvl(level, c01, tmp1.value[0], c1)  # c1 = c0[0]*c1[1] + c0[1]*c1[0]

            if relin:
                c2.is_ntt = True
                self.gadget_product(level, c2, self.rlk.keys[0].gadget_ciphertext(), self.buff_qp[1].q, self.buff_qp[2].q)
                ring_q.add_lvl(level, c0, self.buff_qp[1].q, ct_out.value[0])
                ring_q.add_lvl(level, c1, self.buff_qp[2].q, ct_out.value[1])
            # Case Plaintext (x) Ciphertext or Ciphertext (x) Plaintext
        else:
            if ct_out.degree() < ct_in.degree():
                ct_out.resize(ct_in.degree(), level)
            else:
                ct_out.resize(ct_out.degree(), level)

            c00 = self.buff_q[0]

            ring_q.mform_lvl(level, op_1.value[0], c00)
            for i in range(len(ct_in.value)):
                ring_q.mul_coeffs_montgomery_lvl(level, ct_in.value[i], c00, ct_out.value[i])

    # RotateNew rotates the columns of ct_0 by k positions to the left, and returns the result in a newly created element.
    # If the provided element is a Ciphertext, a key-switching operation is necessary and a rotation key for the specific rotation needs to be provided.
    def rotate_new(self, ct_0: Ciphertext, k: int) -> Ciphertext:
        ct_out = new_ciphertext(self.ckks_params, ct_0.degree(), ct_0.level(), ct_0.scale)
        self.rotate(ct_0, k, ct_out)
        return ct_out
    
    # Rotate rotates the columns of ct_0 by k positions to the left and returns the result in ct_out.
    # If the provided element is a Ciphertext, a key-switching operation is necessary and a rotation key for the specific rotation needs to be provided.
    def rotate(self, ct_0: Ciphertext, k: int, ct_out: Ciphertext):
        self.automorphism(ct_0.get_rlwe_ciphertext(), self.params.galois_element_for_column_rotation_by(k), ct_out.get_rlwe_ciphertext())
        ct_out.scale = ct_0.scale


def new_evaluator_buffers(eval_base: EvaluatorBase) -> EvaluatorBuffers:
	buff = EvaluatorBuffers()
	params = eval_base.ckks_params
	ring_q = params.ring_q
	buff.buff_q = [ring_q.new_poly() for _ in range(3)]
	buff.buff_ct = new_ciphertext(params, 2, params.max_level(), params.default_scale)
	return buff


def new_evaluator_base(params: Parameters) -> EvaluatorBase:
	ev = EvaluatorBase()
	ev.ckks_params = params
	return ev


# NewEvaluator creates a new Evaluator, that can be used to do homomorphic
# operations on the Ciphertexts and/or Plaintexts. It stores a memory buffer
# and Ciphertexts that will be used for intermediate values.
def new_evaluator(params: Parameters, evaluation_key: rlwe.EvaluationKey) -> Evaluator:
    eval = Evaluator()
    eval.set_evaluator_base(new_evaluator_base(params))
    eval.set_evaluator_buffers(new_evaluator_buffers(eval.get_evaluator_base()))
    eval.set_rlwe_evaluator(rlwe.new_evaluator(params.get_rlwe_params(), evaluation_key))
    return eval
