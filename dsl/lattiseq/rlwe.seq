"""
Ported from https://github.com/tuneinsight/lattigo/tree/master/rlwe
"""

import random

import ring, ringqp, utils

from common import big_uint


MAX_LOGN: Static[int] = 17
MIN_LOGN: Static[int] = 4
MAX_MODULI_COUNT: Static[int] = 34
DEFAULT_SIGMA: float = 3.2
MAX_MODULI_SIZE: Static[int] = 60


class Parameters:
    logn: int
    qi: list[u64]
    pi: list[u64]
    pow2_base: int
    sigma: float
    h: int
    ring_q: ring.Ring
    ring_p: ring.Ring
    ring_type: int

    def __init__(self, logn, qi, pi, pow2_base, sigma, h, ring_q, ring_p, ring_type):
        self.logn = logn
        self.qi = qi
        self.pi = pi
        self.pow2_base = pow2_base
        self.sigma = sigma
        self.h = h
        self.ring_q = ring_q
        self.ring_p = ring_p
        self.ring_type = ring_type
    
    def __init__(self, logn, qi, pi, pow2_base, h, sigma, ring_type):
        self.logn = logn
        self.qi = qi
        self.pi = pi
        self.pow2_base = pow2_base
        self.h = h
        self.sigma = sigma
        self.ring_type = ring_type
    
    def __bool__(self):
        return self.logn != 0
    
    def __str__(self):
        return f"""\tRLWEParams:
                \tLog n: {self.logn}
                \tQi: {self.qi}
                \tPi: {self.pi}
                \tPow2 base: {self.pow2_base}
                \tSigma: {self.sigma}
                \tH: {self.h}
                \tRing q: {self.ring_q}
                \tRing p: {self.ring_p}
                \tRing type: {self.ring_type}
        """

    def init_rings(self):
        self.ring_q = ring.new_ring_from_type(1 << self.logn, self.qi, self.ring_type)

        if len(self.pi) != 0:
            self.ring_p = ring.new_ring_from_type(1 << self.logn, self.pi, self.ring_type)
        
    # Checks two Parameter structs for equality.
    def equals(self, other):
        res = self.logn == other.logn
        res &= self.qi == other.qi
        res &= self.pi == other.pi
        res &= (self.h == other.h)
        res &= (self.sigma == other.sigma)
        res &= (self.ring_type == other.ring_type)
        return res
    
    # Returns a pointer to ring_qp
    def ring_qp(self):
        return ringqp.Ring(ring_q=self.ring_q, ring_p=self.ring_p)
    
    # Returns the number of factors of the ciphertext modulus extension q
    def q_count(self):
        return len(self.qi)
    
    # p_count returns the number of factors of the ciphertext modulus extension p
    def p_count(self):
        return len(self.pi)
    
    # Returns the ring degree
    def n(self):
        return 1 << self.logn
    
    # decomp_rns returns the number of element in the RNS decomposition basis: Ceil(lenQi / lenPi)
    def decomp_rns(self, levelq, levelp):
        if levelp == -1: return levelq + 1
        return (levelq + levelp + 1) // (levelp + 1)
    
    # decomp_pw2 returns ceil(p.MaxBitQ(level_q, level_p)/bitDecomp).
    def decomp_pw2(self, levelq, levelp):
        if self.pow2_base == 0: return 1
        return (self.max_bit(levelq, levelp) + self.pow2_base - 1) // self.pow2_base
    
    # MaxBit returns max(max(bitLen(q[:level_q+1])), max(bitLen(p[:level_p+1])).
    def max_bit(self, levelq, levelp):
        c = 0

        for qi in self.q()[:levelq + 1]: c = max(c, int(qi.bitlen()))
        for pi in self.q()[:levelp + 1]: c = max(c, int(pi.bitlen()))

        return c
    
    # q returns a new slice with the factors of the ciphertext modulus q
    def q(self):
        return [e for e in self.qi]
    
    # p returns a new slice with the factors of the ciphertext modulus extension p
    def p(self):
        return [e for e in self.pi]
    
    # LogQP returns the size of the extended modulus QP in bits
    def log_qp(self) -> int:
        tmp = big_uint(1)
        for qi in self.qi: tmp *= qi.ext_to_bigint()
        for pi in self.pi: tmp *= pi.ext_to_bigint()

        return int(tmp.bitlen())


# ParametersLiteral is a literal representation of BFV parameters.  It has public
# fields and is used to express unchecked user-defined parameters literally into
# Go programs. The NewParametersFromLiteral function is used to generate the actual
# checked parameters from the literal representation.
#
# Users must set the polynomial degree (logn) and the coefficient modulus, by either setting
# the q and p fields to the desired moduli chain, or by setting the logq and logp fields to
# the desired moduli sizes.
#
# Optionally, users may specify
# - the base 2 decomposition for the gadget ciphertexts
# - the error variance (sigma) and secrets' density (h) and the ring
# type (ring_type). If left unset, standard default values for these field are substituted at
# parameter creation (see NewParametersFromLiteral).
class ParametersLiteral:
    logn: int
    q: list[u64]
    p: list[u64]
    logq: list[int]
    logp: list[int]
    pow2_base: int
    sigma: float
    h: int
    ring_type: int

    def __init__(self, logn, q, p, logq, logp, pow2_base, sigma, h, ring_type):
        self.logn = logn
        self.q = q
        self.p = p
        self.logq = logq
        self.logp = logp
        self.pow2_base = pow2_base
        self.sigma = sigma
        self.h = h
        self.ring_type = ring_type


class EncryptorBuffers:
    buffq: list[ring.Poly]  # (2)
    buffp: list[ring.Poly]  # (3)
    buffqp: ringqp.Poly

    def __init__(self, buffq, buffp, buffqp):
        self.buffq = buffq
        self.buffp = buffp
        self.buffqp = buffqp
    
    def __str__(self) -> str:
        return f"""\tRLWEEncryptorBuffers:
                \tBuffQ: {self.buffq}
                \tBuffP: {self.buffp}
                \tBuffQP: {self.buffqp}
        """


# SecretKey is a type for generic RLWE secret keys.
class SecretKey:
    value: ringqp.Poly

    def __init__(self, value):
        self.value = value
    
    def __str__(self):
        return f"""\tRLWESecretKey:
                \t{self.value}
        """
    
    # level_q returns the level of the modulus q of the target.
    def level_q(self):
        return self.value.q.level()
    
    # level_p returns the level of the modulus p of the target.
    # Returns -1 if p is absent.
    def level_p(self):
        if self.value.p:
            return self.value.p.level()

        return -1


class EncryptorBase(EncryptorBuffers):
    params: Parameters
    prng: random.Random
    gaussian_sampler: ring.GaussianSampler
    ternary_sampler: ring.TernarySampler
    basisextender: ring.BasisExtender

    def __init__(self, params, prng, gaussian_sampler, ternary_sampler, encryptor_buffers, basisextender):
        self.params = params
        self.prng = prng
        self.gaussian_sampler = gaussian_sampler
        self.ternary_sampler = ternary_sampler
        self.basisextender = basisextender
        self.buffq = encryptor_buffers.buffq
        self.buffp = encryptor_buffers.buffp
        self.buffqp = encryptor_buffers.buffqp
    
    def __str__(self) -> str:
        return f"""\tRLWEEncryptorBase:
                \t{self.params}
                \t{self.gaussian_sampler}
                \t{self.ternary_sampler}
                \t{self.basisextender}
                \t{self.get_rlwe_encryptor_buffers()}
        """
    
    def get_rlwe_encryptor_buffers(self):
        return EncryptorBuffers(self.buffq, self.buffp, self.buffqp)
    
    # check_sk checks that a given sk is correct for the parameters.
    def check_sk(self, key):
        assert isinstance(key, SecretKey), f"key is not a valid public key type {key}"

        if key.value.q.n() != self.params.n():
            raise ValueError("cannot check_sk: sk ring degree does not match params ring degree")


def new_encryptor_buffers(params):
    ring_q = params.ring_q
    ring_p = params.ring_p

    buffp = list[ring.Poly](3)
    if params.p_count() != 0:
        for _ in range(3): buffp.append(ring_p.new_poly())

    return EncryptorBuffers(
        buffq=[ring_q.new_poly(), ring_q.new_poly()],
        buffp=buffp,
        buffqp=params.ring_qp().new_poly())


def new_encryptor_base(params):
    prng = utils.new_prng()
	
    bc = None
    if params.p_count() != 0:
        bc = ring.new_basis_extender(params.ring_q, params.ring_p)
    
    return EncryptorBase(
        params=params,
        prng=prng,
        gaussian_sampler=ring.new_gaussian_sampler(prng, params.ring_q, params.sigma, int(6 * params.sigma)),
        ternary_sampler=ring.new_ternary_sampler_with_hamming_weight(prng, params.ring_q, params.h, False),
        encryptor_buffers=new_encryptor_buffers(params),
        basisextender=bc)


# Ciphertext is a generic type for RLWE ciphertexts.
class Ciphertext:
    value: list[ring.Poly]

    def __str__(self) -> str:
        return f"""\tRLWECipherText:
                \t{self.value}
        """

    # level returns the level of the target element.
    def level(self):
        return len(self.value[0].coeffs) - 1

    # degree returns the degree of the target element.
    def degree(self):
        return len(self.value) - 1


# CiphertextQP is a generic type for RLWE ciphertexts in R_qp.
class CiphertextQP:
    value: list[ringqp.Poly]  # [2]

    def __init__(self, rqp_1, rqp_2):
        self.value = list[ringqp.Poly](2)
        self.value.append(rqp_1)
        self.value.append(rqp_2)


# Plaintext is a common base type for RLWE plaintexts.
class Plaintext:
    value: ring.Poly

    def __init__(self, value=ring.Poly):
        self.value = value
    
    def __bool__(self):
        return bool(self.value)
    
    def __str__(self) -> str:
        return f"""\tRLWEPlaintext:
                \t{self.value}
        """
    
    # level returns the level of the target element.
    def level(self):
        return len(self.value.coeffs) - 1


class SkEncryptor(EncryptorBase):
    sk: SecretKey
    uniform_sampler: ringqp.UniformSampler

    def __init__(self, encryptor_base, sk, uniform_sampler):
        self.params = encryptor_base.params
        self.prng = encryptor_base.prng
        self.gaussian_sampler = encryptor_base.gaussian_sampler
        self.ternary_sampler = encryptor_base.ternary_sampler
        self.basisextender = encryptor_base.basisextender
        self.buffq = encryptor_base.buffq
        self.buffp = encryptor_base.buffp
        self.buffqp = encryptor_base.buffqp

        self.sk = sk
        self.uniform_sampler = uniform_sampler
    
    def __str__(self) -> str:
        return f"""\tRLWESkEncryptor:
                \t{self.sk}
                \t{self.uniform_sampler}
                \t{self.get_rlwe_encryptorbase()}
        """
    
    def get_rlwe_encryptorbase(self):
        return EncryptorBase(
            self.params, self.prng, self.gaussian_sampler, self.ternary_sampler,
            self.get_rlwe_encryptor_buffers(), self.basisextender)
    
    # EncryptZeroSeeded generates en encryption of zero under sk.
    # level_q : level of the modulus q
    # level_p : level of the modulus p
    # sk     : secret key
    # sampler: uniform sampler; if `sampler` is nil, then will sample using the internal sampler.
    # montgomery: returns the result in the Montgomery domain.
    def encrypt_zero_qp(self, ct):
        c0, c1 = ct.value[0], ct.value[1]

        level_q, level_p = c0.level_q(), c1.level_p()
        ring_qp = self.params.ring_qp()

        # ct = (e, 0)
        self.gaussian_sampler.read_lvl(level_q, c0.q)
        if level_p != -1:
            ring_qp.extend_basis_small_norm_and_center(c0.q, level_p, None, c0.p)

        ring_qp.ntt_lvl(level_q, level_p, c0, c0)
        # ct[1] is assumed to be sampled in of the Montgomery domain,
        # thus -as will also be in the Montgomery domain (s is by default), therefore 'e'
        # must be switched to the Montgomery domain.
        ring_qp.mform_lvl(level_q, level_p, c0, c0)

        # ct = (e, a)
        self.uniform_sampler.read_lvl(level_q, level_p, c1)

        # (-a*sk + e, a)
        ring_qp.mul_coeffs_montgomery_and_sub_lvl(level_q, level_p, c1, self.sk.value, c0)

        if not ct.value[0].q.is_ntt:
            ring_qp.inv_ntt_lvl(level_q, level_p, c0, c0)
            ring_qp.inv_ntt_lvl(level_q, level_p, c1, c1)
    
    # encrypt_zero generates an encryption of zero using the stored secret-key and writes the result on ct.
    # The method accepts only *rlwe.Ciphertext, *CiphertextC0 or *rgsw.Ciphertext as input and will panic otherwise.
    def encrypt_zero(self, ct):
        if isinstance(ct, Ciphertext):
            self.uniform_sampler.read_lvl(ct.level(), -1, ringqp.Poly(q=ct.value[1]))
            self.encrypt_zero_ring(ct.value[0], ct.value[1])
        elif isinstance(ct, ring.Poly):
            self.uniform_sampler.read_lvl(ct.level(), -1, ringqp.Poly(q=self.buffq[1]))
            self.encrypt_zero_ring(ct, self.buffq[1])
        elif isinstance(ct, CiphertextQP):
            self.encrypt_zero_qp(ct)
        else:
            raise ValueError("cannot encrypt_zero: input ciphertext type unsupported")
    
    def encrypt_zero_ring(self, c0: ring.Poly, c1: ring.Poly):
        ring_q = self.params.ring_q
        level_q = c0.level()

        ring_q.mul_coeffs_montgomery_lvl(level_q, c1, self.sk.value.q, c0) # c0 = NTT(sc1)
        ring_q.neg_lvl(level_q, c0, c0)                                  # c0 = NTT(-sc1)

        if c0.is_ntt:
            self.gaussian_sampler.read_lvl(level_q, self.buffq[0]) # e
            ring_q.ntt_lvl(level_q, self.buffq[0], self.buffq[0])  # NTT(e)
            ring_q.add_lvl(level_q, c0, self.buffq[0], c0)         # c0 = NTT(-sc1 + e)
        else:
            ring_q.inv_ntt_lvl(level_q, c0, c0)                # c0 = -sc1
            ring_q.inv_ntt_lvl(level_q, c1, c1)                # c1 = c1
            self.gaussian_sampler.read_and_add_lvl(level_q, c0) # c0 = -sc1 + e

    def encryptor_base(self):
        return EncryptorBase(
            params=self.params,
            prng=self.prng,
            gaussian_sampler=self.gaussian_sampler,
            ternary_sampler=self.ternary_sampler,
            encryptor_buffers=EncryptorBuffers(
                buffq=self.buffq,
                buffp=self.buffp,
                buffqp=self.buffqp),
            basisextender=self.basisextender)

    # with_key returns this encryptor with a new key.
    def with_key(self, key):
        self.check_sk(key)
        return SkEncryptor(self.encryptor_base(), key, self.uniform_sampler)
    
    # encrypt encrypts the input plaintext using the stored secret-key and writes the result on ct.
    # The method accepts only *rlwe.Ciphertext, *CiphertextC0 or *rgsw.Ciphertext as input and will panic otherwise.
    def encrypt(self, pt: Plaintext, ct):
        if not pt: self.encrypt_zero(ct)
        else:
            if isinstance(ct, Ciphertext):
                self.uniform_sampler.read_lvl(min(pt.level(), ct.level()), -1, ringqp.Poly(q=ct.value[1]))
                self.encrypt_rlwe(pt, ct.value[0], ct.value[1])
            elif isinstance(ct, ring.Poly):
                self.uniform_sampler.read_lvl(min(pt.level(), ct.level()), -1, ringqp.Poly(q=self.buffq[1]))
                self.encrypt_rlwe(pt, ct, self.buffq[1])
            else: raise ValueError("cannot encrypt: input ciphertext type unsuported (must be *rlwe.Ciphertext or *rgsw.Ciphertext)")
    
    def encrypt_rlwe(self, pt: Plaintext, c0: ring.Poly, c1: ring.Poly):
        ring_q = self.params.ring_q
        level_q = min(pt.level(), c0.level())
        ct_ntt = c0.is_ntt

        ring_q.mul_coeffs_montgomery_lvl(level_q, c1, self.sk.value.q, c0)
        ring_q.neg_lvl(level_q, c0, c0)

        self.add_pt_error_c0(pt, c0)

        if not ct_ntt and c1 != self.buffq[0]: ring_q.inv_ntt_lvl(level_q, c1, c1)
    
    def add_pt_error_c0(self, pt: Plaintext, c0: ring.Poly):
        ring_q = self.params.ring_q
        level_q = min(pt.level(), c0.level())
        ct_ntt = c0.is_ntt
        pt_ntt = pt.value.is_ntt
        buffq0 = self.buffq[0]

        if ct_ntt and pt_ntt:
            self.gaussian_sampler.read_lvl(level_q, buffq0)
            ring_q.ntt_lvl(level_q, buffq0, buffq0)
            ring_q.add_lvl(level_q, c0, buffq0, c0)
            ring_q.add_lvl(level_q, c0, pt.value, c0)
        elif ct_ntt and not pt_ntt:
            self.gaussian_sampler.read_lvl(level_q, buffq0)
            ring_q.add_lvl(level_q, buffq0, pt.value, buffq0)
            ring_q.ntt_lvl(level_q, buffq0, buffq0)
            ring_q.add_lvl(level_q, c0, buffq0, c0)
        elif not ct_ntt and pt_ntt:
            ring_q.add_lvl(level_q, c0, pt.value, c0)
            ring_q.inv_ntt_lvl(level_q, c0, c0)
            self.gaussian_sampler.read_and_add_lvl(c0.level(), c0)
        elif not ct_ntt and not pt_ntt:
            ring_q.inv_ntt_lvl(level_q, c0, c0)
            ring_q.add_lvl(level_q, c0, pt.value, c0)
            self.gaussian_sampler.read_and_add_lvl(c0.level(), c0)


def new_sk_encryptor(params, key):
    prng = utils.new_prng()
    enc = SkEncryptor(new_encryptor_base(params), key, ringqp.new_uniform_sampler(prng, params.ring_qp()))
    enc.check_sk(key)
    return enc


# gadget_ciphertext is a struct for storing an encrypted
# plaintext times the gadget power matrix.
class gadget_ciphertext:
    value: list[list[CiphertextQP]]

    # level_q returns the level of the modulus q of the target Ciphertext.
    def level_q(self):
        return self.value[0][0].value[0].q.level()
    
    # level_p returns the level of the modulus p of the target Ciphertext.
    def level_p(self):
        if self.value[0][0].value[0].p:
            return self.value[0][0].value[0].p.level()

        return -1


# SwitchingKey is a type for generic RLWE public switching keys.
class SwitchingKey(gadget_ciphertext):
    def __init__(self, gadget_ciphertext):
        self.value = gadget_ciphertext.value
    
    def gadget_ciphertext(self):
        return gadget_ciphertext(self.value)


# NewCiphertext returns a new Element with zero values.
def new_ciphertext(params: Parameters, degree: int, level: int) -> Ciphertext:
	el = Ciphertext()
	el.value = list[ring.Poly](degree + 1)
	for _ in range(degree + 1): el.value.append(ring.new_poly(params.n(), level))
	return el


# RelinearizationKey is a type for generic RLWE public relinearization keys. It stores a slice with a
# switching key per relinearizable degree. The switching key at index i is used to relinearize a degree
# i+2 ciphertexts back to a degree i + 1 one.
class RelinearizationKey:
	keys: list[SwitchingKey]


# NewGadgetCiphertext returns a new Ciphertext key with pre-allocated zero-value.
# Ciphertext is always in the NTT domain.
def new_gadget_ciphertext(level_q, level_p, decomp_rns, decomp_bit, ring_qp):
    ct = gadget_ciphertext()
    ct.value = list[list[CiphertextQP]](decomp_rns)
	
    for _ in range(decomp_rns):
        ct_value = list[CiphertextQP](decomp_bit)
		
        for _ in range(decomp_bit):
            ct_value_poly_0 = ring_qp.new_poly_lvl(level_q, level_p)
            ct_value_poly_1 = ring_qp.new_poly_lvl(level_q, level_p)
            ct_value_poly_0.q.is_ntt = True
            ct_value_poly_1.q.is_ntt = True
            
            if level_p != -1:
                ct_value_poly_0.p.is_ntt = True
                ct_value_poly_1.p.is_ntt = True

            ct_value.append(CiphertextQP(ct_value_poly_0, ct_value_poly_1))
            
        ct.value.append(ct_value)

    return ct


def check_size_params(logn, len_q, len_p):
	if logn > MAX_LOGN:
		raise ValueError(f"logn={logn} is larger than MaxLogN={MAX_LOGN}")
	if logn < MIN_LOGN:
		raise ValueError(f"logn={logn} is smaller than MinLogN={MIN_LOGN}")
	if len_q > MAX_MODULI_COUNT:
		raise ValueError(f"len_q={len_q} is larger than MaxModuliCount={MAX_MODULI_COUNT}")
	if len_p > MAX_MODULI_COUNT:
		raise ValueError(f"len_p={len_p} is larger than MaxModuliCount={MAX_MODULI_COUNT}")


def check_moduli(q, p):
    if len(q) > MAX_MODULI_COUNT:
        raise ValueError("#Qi is larger than {MAX_MODULI_COUNT}")

    for i, qi in enumerate(q):
        if u64(int(qi.bitlen()) - 1) > u64(MAX_MODULI_SIZE + 1):
            raise ValueError(f"a Qi bit-size (i={i}) is larger than {MAX_MODULI_SIZE}")

    for i, qi in enumerate(q):
        if not utils.is_prime(qi):
            raise ValueError(f"a Qi (i={i}) is not a prime")
        
    if p:
        if len(p) > MAX_MODULI_COUNT:
            raise ValueError(f"#Pi is larger than {MAX_MODULI_COUNT}")

        for i, pi in enumerate(p):
            if u64(int(pi.bitlen()) - 1) > u64(MAX_MODULI_SIZE + 2):
                raise ValueError(f"a Pi bit-size (i={i}) is larger than {MAX_MODULI_SIZE}")
        
        for i, pi in enumerate(p):
            if not utils.is_prime(pi):
                raise ValueError(f"a Pi (i={i}) is not a prime")


def new_parameters(logn, q, p, pow2_base, h, sigma, ring_type):
    if pow2_base != 0 and len(p) > 1:
        raise ValueError("rlwe.NewParameters: invalid parameters, cannot have pow2_base > 0 if len(p) > 1")

    check_size_params(logn, len(q), len(p))

    params = Parameters(
        logn=logn,
		qi=list[u64](len(q)),
		pi=list[u64](len(p)),
		pow2_base=pow2_base,
		h=h,
		sigma=sigma,
		ring_type=ring_type)

	# pre-check that moduli chain is of valid size and that all factors are prime.
	# note: the Ring instantiation checks that the moduli are valid NTT-friendly primes.
    check_moduli(q, p)

    for e in q: params.qi.append(e)
    for e in p: params.pi.append(e)

    params.init_rings()

    return params


def check_moduli_log_size(log_q, log_p):
    for i, qi in enumerate(log_q):
        if qi <= 0 or qi > MAX_MODULI_SIZE:
            raise ValueError(f"log_q[{i}]={qi} is not in ]0, {MAX_MODULI_SIZE}]")

    for i, pi in enumerate(log_p):
        if pi <= 0 or pi > MAX_MODULI_SIZE + 1:
            raise ValueError(f"log_p[{i}]={pi} is not in ]0,{MAX_MODULI_SIZE + 1}]")


def gen_moduli(logn, log_q, log_p):
    check_size_params(logn, len(log_q), len(log_p))
    check_moduli_log_size(log_q, log_p)

	# Extracts all the different primes bit size and maps their number
    primesbitlen = {}
    for qi in log_q: primesbitlen[qi] = 0
    for pj in log_p: primesbitlen[pj] = 0
    for qi in log_q: primesbitlen[qi] += 1
    for pj in log_p: primesbitlen[pj] += 1

	# For each bit-size, finds that many primes
    primes = {}
    for key, value in primesbitlen.items():
        primes[key] = ring.generate_ntt_primes(int(key), 2 << logn, int(value))

    q, p = [], []
	
    # Assigns the primes to the moduli chain
    for qi in log_q:
        q.append(primes[qi][0])
        primes[qi] = primes[qi][1:]

    # Assigns the primes to the special primes list for the extended ring
    for pj in log_p:
        p.append(primes[pj][0])
        primes[pj] = primes[pj][1:]

    return q, p


def new_parameters_from_literal(param_def):
    if param_def.h == 0:
        param_def.h = 1 << (param_def.logn - 1)

    if param_def.sigma == 0:
        # prevents the zero value of ParameterLiteral to result in a noise-less parameter instance.
        # Users should use the NewParameters method to explicitely create noiseless instances.
        param_def.sigma = DEFAULT_SIGMA

    if param_def.q and not param_def.logq:
        return new_parameters(param_def.logn, param_def.q, param_def.p, param_def.pow2_base, param_def.h, param_def.sigma, param_def.ring_type)

    if param_def.logq and not param_def.q:
        log_n = param_def.logn
        if param_def.ring_type == ring.ConjugateInvariantRing: log_n += 1

        q, p = gen_moduli(param_def.logn, param_def.logq, param_def.logp)

        return new_parameters(param_def.logn, q, p, param_def.pow2_base, param_def.h, param_def.sigma, param_def.ring_type)

    raise ValueError("rlwe.NewParametersFromLiteral: invalid parameter literal")


# AddPolyTimesGadgetVectorToGadgetCiphertext takes a plaintext polynomial and a list of Ciphertexts and adds the
# plaintext times the RNS and BIT decomposition to the i-th element of the i-th Ciphertexts. This method panics if
# len(cts) > 2.
def add_poly_times_gadget_vector_to_gadget_ciphertext(pt, cts, ring_qp, logbase2, buff):
    ring_q = ring_qp.ring_q
    level_q = cts[0].level_q()
    level_p = cts[0].level_p()

    if len(cts) > 2:
        raise ValueError("cannot AddPolyTimesGadgetVectorToGadgetCiphertext: len(cts) should be <= 2")

    if level_p != -1:
        ring_q.mul_scalar_bigint_lvl(level_q, pt, ring_qp.ring_p.modulus_at_level[level_p], buff)  # p * pt
    else:
        level_p = 0
        if pt != buff:
            ring.copy_lvl(level_q, pt, buff)  # 1 * pt

    rns_decomp = len(cts[0].value)
    bit_decomp = len(cts[0].value[0])

    for j in range(bit_decomp):
        for i in range(rns_decomp):
            # e + (m * p * w^2j) * (q_star * q_tild) mod QP
            # q_prod = prod(q[i*#Pi+j])
            # q_star = q/qprod
            # q_tild = q_star^-1 mod q_prod
            # Therefore : (pt * p * w^2j) * (q_star * q_tild) = pt*p*w^2j mod q[i*#Pi+j], else 0
            for k in range(level_p + 1):
                index = i * (level_p + 1) + k

				# Handle cases where #pj does not divide #qi
                if index >= level_q + 1: break

                qi = ring_q.modulus[index]
                p0tmp = buff.coeffs[index]

                for u, ct in enumerate(cts):
                    p1tmp = ct.value[i][j].value[u].q.coeffs[index]
                    for w in range(ring_q.n):
                        p1tmp[w] = ring.cred(p1tmp[w] + p0tmp[w], qi)
		# w^2j
        ring_q.mul_scalar(buff, 1 << logbase2, buff)
    
    buff.update_buffer()


# NewSwitchingKey returns a new public switching key with pre-allocated zero-value
def new_switching_key(params, level_q, level_p):
	return SwitchingKey(
        gadget_ciphertext=new_gadget_ciphertext(
            level_q,
            level_p,
            params.decomp_rns(level_q, level_p),
            params.decomp_pw2(level_q, level_p),
            params.ring_qp()))


# KeyGenerator is a structure that stores the elements required to create new keys,
# as well as a memory buffer for intermediate values.
class KeyGenerator(SkEncryptor):
    def __init__(self, sk_encryptor):
        self.params = sk_encryptor.params
        self.prng = sk_encryptor.prng
        self.gaussian_sampler = sk_encryptor.gaussian_sampler
        self.ternary_sampler = sk_encryptor.ternary_sampler
        self.basisextender = sk_encryptor.basisextender
        self.buffq = sk_encryptor.buffq
        self.buffp = sk_encryptor.buffp
        self.buffqp = sk_encryptor.buffqp

        self.sk = sk_encryptor.sk
        self.uniform_sampler = sk_encryptor.uniform_sampler
    
    def __str__(self) -> str:
        return f"""\tRLWEKeyGen:
                \t{self.get_rlwe_skencryptor()}
        """
    
    def get_rlwe_skencryptor(self):
        return SkEncryptor(self.get_rlwe_encryptorbase(), self.sk, self.uniform_sampler)
    
    # gen_secret_key generates a new SecretKey with the distribution [1/3, 1/3, 1/3].
    def gen_secret_key(self):
        return self.gen_secret_key_from_sampler(self.ternary_sampler)

    # gen_secret_key_from_sampler generates a new SecretKey sampled from the provided Sampler.
    def gen_secret_key_from_sampler(self, sampler):
        ring_qp = self.params.ring_qp()
        sk = SecretKey(value=ring_qp.new_poly())
        level_q, level_p = sk.level_q(), sk.level_p()
        sampler.read(sk.value.q)

        if level_p > -1:
            ring_qp.extend_basis_small_norm_and_center(sk.value.q, level_p, None, sk.value.p)

        ring_qp.ntt_lvl(level_q, level_p, sk.value, sk.value)
        ring_qp.mform_lvl(level_q, level_p, sk.value, sk.value)

        return sk
    
    # GenRelinKey generates a new EvaluationKey that will be used to relinearize Ciphertexts during multiplication.
    def gen_relinearization_key(self, sk, maxDegree):
        level_q = self.params.q_count() - 1
        level_p = self.params.p_count() - 1

        evk = RelinearizationKey()
        evk.keys = list[SwitchingKey](maxDegree)
        for _ in range(maxDegree): evk.keys.append(new_switching_key(self.params, level_q, level_p))

        self.buffqp.q.copy_values(sk.value.q)
        ring_q = self.params.ring_q
        for i in range(maxDegree):
            ring_q.mul_coeffs_montgomery(self.buffqp.q, sk.value.q, self.buffqp.q)
            self.gen_switching_key(self.buffqp.q, sk.value, evk.keys[i])
        
        return evk
    
    def gen_switching_key(self, skIn, skOut, swk):
        enc = self.with_key(SecretKey(skOut))
        # Samples an encryption of zero for each element of the switching-key.
        
        for row in swk.value:
            for elem in row:
                enc.encrypt_zero(elem)

        # Adds the plaintext (input-key) to the switching-key.
        add_poly_times_gadget_vector_to_gadget_ciphertext(
            skIn, [swk.gadget_ciphertext()],
            self.params.ring_qp(), self.params.pow2_base, self.buffq[0])


# NewSecretKey generates a new SecretKey with zero values.
def new_secret_key(params):
    return SecretKey(value=params.ring_qp().new_poly())


# NewKeyGenerator creates a new KeyGenerator, from which the secret and public keys, as well as the evaluation,
# rotation and switching keys can be generated.
def new_key_generator(params):
    return KeyGenerator(sk_encryptor=new_sk_encryptor(params, new_secret_key(params)))


# PublicKey is a type for generic RLWE public keys.
class PublicKey:
    value: ringqp.Poly  # [2]

    def __init__(self):
        raise NotImplementedError()


class PkEncryptor(EncryptorBase):
    pk: PublicKey

    def __init__(self, encryptor_base, pk):
        self.params = encryptor_base.params
        self.prng = encryptor_base.prng
        self.gaussian_sampler = encryptor_base.gaussian_sampler
        self.ternary_sampler = encryptor_base.ternary_sampler
        self.basisextender = encryptor_base.basisextender
        self.buffq = encryptor_base.buffq
        self.buffp = encryptor_base.buffp
        self.buffqp = encryptor_base.buffqp

        self.pk = pk
    
    # check_pk checks that a given pk is correct for the parameters.
    def check_pk(self, key: PublicKey):
        if key.value[0].q.n() != self.params.n() or key.value[1].q.n() != self.params.n():
            raise ValueError("pk ring degree does not match params ring degree")


def new_pk_encryptor(params: Parameters, key):
	enc = PkEncryptor(new_encryptor_base(params), key)
	enc.check_pk(key)
	return enc


# NewEncryptor creates a new Encryptor
# Accepts either a secret-key or a public-key.
def new_encryptor(params: Parameters, key):
	if isinstance(key, PublicKey):
		return new_pk_encryptor(params, key)
	elif isinstance(key, SecretKey):
		return new_sk_encryptor(params, key)
	else:
		raise ValueError("cannot NewEncryptor: key must be either *rlwe.PublicKey or *rlwe.SecretKey")


# NewPlaintext creates a new Plaintext at level `level` from the parameters.
def new_plaintext(params: Parameters, level: int) -> Plaintext:
	return Plaintext(value=ring.new_poly(params.n(), level))


# decryptor is a structure used to decrypt ciphertext. It stores the secret-key.
class Decryptor:
    ring_q: ring.Ring
    buff: ring.Poly
    sk: SecretKey

    def __str__(self) -> str:
        return f"""\tRLWEDecryptor:
                \tringQ: {self.ring_q}
                \tbuff: {self.buff}
                \tsk: {self.sk}
        """

    # decrypt decrypts the ciphertext and write the result in ptOut.
    # The level of the output plaintext is min(ciphertext.level(), plaintext.level())
    # Output domain will match plaintext.value.is_ntt value.
    def decrypt(self, ciphertext: Ciphertext, plaintext: Plaintext):
        ring_q = self.ring_q
        level = min(ciphertext.level(), plaintext.level())

        plaintext.value.resize(level)

        if ciphertext.value[0].is_ntt:
            ring.copy_values_lvl(level, ciphertext.value[ciphertext.degree()], plaintext.value)
        else:
            ring_q.ntt_lazy_lvl(level, ciphertext.value[ciphertext.degree()], plaintext.value)

        for i in range(ciphertext.degree(), 0, -1):
            ring_q.mul_coeffs_montgomery_lvl(level, plaintext.value, self.sk.value.q, plaintext.value)

            if not ciphertext.value[0].is_ntt:
                ring_q.ntt_lazy_lvl(level, ciphertext.value[i - 1], self.buff)
                ring_q.add_lvl(level, plaintext.value, self.buff, plaintext.value)
            else: ring_q.add_lvl(level, plaintext.value, ciphertext.value[i - 1], plaintext.value)

            if i & 7 == 7: ring_q.reduce_lvl(level, plaintext.value, plaintext.value)

        if ciphertext.degree() & 7 != 7: ring_q.reduce_lvl(level, plaintext.value, plaintext.value)

        if not plaintext.value.is_ntt: ring_q.inv_ntt_lvl(level, plaintext.value, plaintext.value)


# NewDecryptor instantiates a new generic RLWE Decryptor.
def new_decryptor(params, sk):
	if sk.value.q.n() != params.n():
		raise ValueError("secret_key is invalid for the provided parameters")

	return Decryptor(
        ring_q=params.ring_q,
        buff=params.ring_q.new_poly(),
        sk=sk)
