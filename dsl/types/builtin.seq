from ..utils.param import \
    int_t, MOD_CONST, FIELD_SIZE, RING_SIZE, RING_MASK, \
    SECOND_FIELD_SIZE, SECOND_MOD_CONST, THIRD_FIELD_SIZE, \
    THIRD_MOD_CONST, MODULUS_OPT, MATRIX_OPT, MODULUS_BITS, IS_MERSENNE_FIELD
from ..utils.utils import __rand_int, __rand_vec, __rand_mat, __rand_bits, __rand_vec_bits, __rand_mat_bits
from ..utils.primitives import mod_pow, strassen
from shared_tensor import SharedTensor
from utils import double_to_fp


@tuple
class sockaddr_un:
    sun_family: int
    sun_path: ptr[byte]


@extend
class bool:
    def to_int_t(self) -> int_t:
        return int_t(self)


@extend
class str:
    def __getitem__(self, indices: list[int]):
        substr_ptr = Ptr[byte](len(indices))
        for i, ind in enumerate(indices):
            str.memcpy(substr_ptr + i, self.ptr + ind, 1)
        return str(substr_ptr, len(indices))
    def to_int_t(self) -> int_t:
        return int(self).to_int_t()


@extend
class float:
    def __init__(self: float, other: int_t):
        self = float(int(other))
    
    def __add__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return other + self
    
    def __sub__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return -other + self
    
    def __mul__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return other * self
    
    def to_fp(self, modulus) -> int_t:
        return double_to_fp(self, modulus)
    
    def to_int(self) -> int:
        return int(self)


@extend
class int:
    def __add__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return other + self
    def __sub__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return -other + self
    def __mul__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        return other * self
    def __truediv__[TP](self, other: SharedTensor[TP]) -> SharedTensor[TP]:
        raise NotImplementedError("Cannot divide by secure value without IR passes enabled.")
    def __mod__(self: int, other: int) -> int:
        # TODO: #138 Check why performance gets worsened with the fast modulus enabled (Note: naive_mod includes ring check)OND_FIELD_SIZE, SECOND_MOD_CONST)
        return self.__naive_mod(other)
    @llvm
    def get_mod_const(field_size: int) -> UInt[128]:
        %fs_ext = zext i64 %field_size to i128
        %0 = udiv i128 -1, %fs_ext
        %1 = add i128 %0, 1
        ret i128 %1
    @llvm
    def __naive_mod(self: int, other: int) -> int:
        declare i64 @llvm.ctpop.i64(i64)
        %popcount = call i64 @llvm.ctpop.i64(i64 %other)
        %0 = srem i64 %self, %other
        %1 = icmp slt i64 %0, 0
        %2 = add i64 %0, %other
        %3 = select i1 %1, i64 %2, i64 %0
        %4 = icmp eq i64 %popcount, 1
        %other_1 = sub i64 %other, 1
        %5 = and i64 %self, %other_1
        %6 = select i1 %4, i64 %5, i64 %3
        ret i64 %6
    @llvm
    def __fast_mod_field(self: int, field_size: int, mod_const: UInt[128]) -> int:
        %0 = lshr i64 %self, 63
        %1 = trunc i64 %0 to i1
        %2 = xor i64 %self, -1
        %3 = add i64 %2, 1
        %4 = select i1 %1, i64 %3, i64 %self
        %5 = zext i64 %4 to i128
        %6 = mul i128 %mod_const, %5
        %7 = zext i64 %field_size to i128
        %8 = zext i64 -1 to i128
        %9 = and i128 %6, %8
        %10 = mul i128 %9, %7
        %11 = lshr i128 %10, 64
        %12 = lshr i128 %6, 64
        %13 = mul i128 %12, %7
        %14 = add i128 %11, %13
        %15 = lshr i128 %14, 64
        %16 = trunc i128 %15 to i64
        %17 = sub i64 %field_size, %16
        %18 = select i1 %1, i64 %17, i64 %16
        ret i64 %18
    def to_fp(self, modulus) -> int_t:
        return double_to_fp(float(self), modulus)
    def to_bytes(self):
        for _ in range(1): yield self
    def to_int_t(self) -> int_t:
        return int_t(self)
    def elem_count(self) -> int:
        return 1
    def rand(self, base: int) -> int:
        return __rand_int(base)
    def zeros(self) -> int:
        return 0
    def to_float(self) -> float:
        return float(self)
    def copy(self: int) -> int:
        return int(self)
    def zeros(self: int) -> int:
        return 0
    def zeros_float(self: int) -> float:
        return 0.0
    def ones(self: int) -> int:
        return 1
    def shape(self: int) -> list[int]:
        return []
    def has_zero(self: int) -> bool:
        return self == 0
    def to_float(self: int) -> float:
        return float(int(self))


@extend
class UInt[N]:
    @llvm
    def __new__(other: UInt[128]) -> UInt[N]:
        %0 = zext i{=N//2} %other to i{=N}
        ret i{=N} %0
    @llvm
    def __new__(other: bool) -> UInt[N]:
        %0 = zext i8 %other to i{=N}
        ret i{=N} %0
    def __eq__(self: UInt[N], other: int) -> bool:
        return self == UInt[N](other)
    def __ne__(self: UInt[N], other: int) -> bool:
        return self != UInt[N](other)
    def __gt__(self: UInt[N], other: int) -> bool:
        return self > UInt[N](other)
    def __add__(self: UInt[N], other: int) -> UInt[N]:
        return self + UInt[N](other)
    def __mul__(self: UInt[N], other: int) -> UInt[N]:
        return self * UInt[N](other)
    def __sub__(self: UInt[N], other: int) -> UInt[N]:
        return self - UInt[N](other)
    def __truediv__(self: UInt[N], other: int) -> UInt[N]:
        return self / UInt[N](other)
    def __floordiv__(self: UInt[N], other: int) -> UInt[N]:
        return self // UInt[N](other)
    def __mod__(self: UInt[N], other: UInt[N]) -> UInt[N]:
        if other == RING_SIZE: return self.__fast_mod_ring()
        if not MODULUS_OPT: return self.__naive_mod(other)
        if other == FIELD_SIZE: return self.__fast_mod_field()
        return self.__naive_mod(other)
    @llvm
    def get_mod_const(field_size: UInt[N]) -> UInt[N*2]:
        %fs_ext = zext i{=N} %field_size to i{=N*2}
        %0 = udiv i{=N*2} -1, %fs_ext
        %1 = add i{=N*2} %0, 1
        ret i{=N*2} %1
    @llvm
    def __naive_mod(self: UInt[N], other: UInt[N]) -> UInt[N]:  # TODO: Naive mod is not accurate for mods longer than 64bit
        %0 = trunc i{=N} %self to i{=N//2}
        %1 = trunc i{=N} %other to i{=N//2}
        %2 = urem i{=N//2} %0, %1
        %3 = zext i{=N//2} %2 to i{=N}
        ret i{=N} %3
    @llvm
    def __fast_mod_const_field(self: UInt[N], field_size: UInt[N] = FIELD_SIZE, mod_const: UInt[N*2] = MOD_CONST) -> UInt[N]:
        %0 = zext i{=N} %self to i{=N*2}
        %1 = mul i{=N*2} %mod_const, %0
        %2 = zext i{=N} %field_size to i{=N*2}
        %3 = zext i{=N} -1 to i{=N*2}
        %4 = and i{=N*2} %1, %3
        %5 = mul i{=N*2} %4, %2
        %6 = lshr i{=N*2} %5, {=N}
        %7 = lshr i{=N*2} %1, {=N}
        %8 = mul i{=N*2} %7, %2
        %9 = add i{=N*2} %6, %8
        %10 = lshr i{=N*2} %9, {=N}
        %11 = trunc i{=N*2} %10 to i{=N}
        ret i{=N} %11
    def __fast_mod_mersenne(self: UInt[N], field_size: UInt[N] = FIELD_SIZE):
        """
        Bit-hack for computing modulus with the field size of the form 2^k - 1 (Mersenne form of a prime).
        There is no explicit check for the shape of the field,
        so please make sure that the field_size is a Mersenne prime if you use this method.
        """
        n = self
        m = n
        while n > field_size:
            m = UInt[N](0)
            while n:
                m += (n & field_size)
                n >>= MODULUS_BITS
            n = m
        if m == field_size: m = UInt[N](0)
        return m
    def __fast_mod_mersenne_fixed(self: UInt[N], field_size: UInt[N] = FIELD_SIZE):
        """
        Bit-hack for computing modulus with the field size equal to 2^127 - 1.
        There is no explicit check for the shape of the field,
        so please make sure that the field_size is equal to 2^127 - 1.
        """
        n = self
        if n < field_size: return n
        if n == field_size: return UInt[N](0)

        m = (n & field_size)
        n >>= UInt[N](127)
        m += n
        m = (m & field_size) + (m >> UInt[N](127))
        
        if m == field_size: return UInt[N](0)
        return m
    def __fast_mod_field(self: UInt[N]):
        if IS_MERSENNE_FIELD: return self.__fast_mod_mersenne_fixed()
        return self.__fast_mod_const_field()
    def __fast_mod_ring(self: UInt[N]) -> UInt[N]:
        return self & RING_MASK
    def __or__(self: UInt[N], other: int) -> UInt[N]:
        return self | UInt[N](other)
    def __pow__(self: UInt[N], other: UInt[N]) -> UInt[N]:
        number = UInt[N](1)
        value = self
        while other:
            if other & 1:
                number = number * value
            other >>= 1
            value = value * value
        return number
    def __pow__(self: UInt[N], other: int) -> UInt[N]:
        return self ** UInt[N](other)
    def __and__(self: UInt[N], other: int) -> UInt[N]:
        return self & UInt[N](other)
    def __lshift__(self: UInt[N], other: int) -> UInt[N]:
        return self << UInt[N](other)
    def __rshift__(self: UInt[N], other: int) -> UInt[N]:
        return self >> UInt[N](other)
    def __str__(self: UInt[N]) -> str:
        # TODO: Fix the ineficient string manipulation in the printing algorithm below.
        self_cp = self
        int_str = ''
        while self_cp:
            remainder = 0
            quotient = UInt[N](0)
            # Euclidean division
            for bit_idx in range(MODULUS_BITS, -1, -1):
                remainder = (remainder << 1) + int((self_cp & (UInt[N](1) << bit_idx)) != 0)
                if remainder >= 10:
                    quotient = (quotient << 1) + 1
                    remainder -= 10
                else: quotient = quotient << 1
            int_str = str(remainder) + int_str
            self_cp = quotient
        return int_str if int_str else '0'
    def to_bytes(self: UInt[N]):
        for _ in range(1): yield self
    def elem_count(self: UInt[N]) -> int:
        return 1
    def rand(self: UInt[N], base: UInt[N]) -> UInt[N]:
        return __rand_int(base)
    def rand_bits(self: UInt[N], bitlen: int) -> UInt[N]:
        return __rand_bits(bitlen)
    def zeros(self: UInt[N]) -> UInt[N]:
        return UInt[N](0)
    def zeros_float(self: UInt[N]) -> float:
        return 0.0
    def ones(self: UInt[N]) -> UInt[N]:
        return UInt[N](1)
    def copy(self: UInt[N]) -> UInt[N]:
        return UInt[N](self)
    def shape(self: UInt[N]) -> list[int]:
        return []
    def has_zero(self: UInt[N]) -> bool:
        return self == UInt[N](0)
    def to_float(self: UInt[N]) -> float:
        return float(int(self))
    def to_int(self: UInt[N]) -> int:
        return int(self)
    def fixed_value(self: UInt[N], value) -> UInt[N]:
        return UInt[N](value)


@extend
class list[T]:
    def __getitem__(self: list[T], s: tuple[slice, slice]) -> list[T]:
        rs, cs = s
        sliced_arr = self[rs]
        new_arr = list[T](len(sliced_arr))
        for i in range(len(sliced_arr)): new_arr.append(sliced_arr[i][cs])
        return new_arr
    
    def __setitem__(self: list[T], s: tuple[slice, slice], other: generator[T]):
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(len(self))
        for i in range(start, stop):
            self[i][cs] = next(other)

    def __getitem__(self: list[list[int_t]], s: tuple[slice, int]) -> list[int_t]:
        rs, cs = s
        sliced_arr = self[rs]
        new_arr = list[int_t](len(sliced_arr))
        for i in range(len(sliced_arr)): new_arr.append(sliced_arr[i][cs])
        return new_arr

    def __setitem__(self: list[list[int_t]], s: tuple[slice, int], other: generator[int_t]):
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(len(self))
        for i in range(start, stop):
            self[i][cs] = next(other)
    
    def __getitem__(self: list[list[int_t]], s: tuple[int, slice]) -> list[int_t]:
        ri, cs = s
        return self[ri][cs]

    def __setitem__(self: list[list[int_t]], s: tuple[int, slice], other: generator[int_t]):
        ri, cs = s
        start, stop, _, _ = cs.adjust_indices(len(self))
        for j in range(start, stop):
            self[ri][j] = next(other)
    
    def __getitem__(self: list[list[int_t]], s: tuple[int, int]) -> int_t:
        i, j = s
        return self[i][j]

    def __setitem__(self: list[list[int_t]], s: tuple[int, int], other: int_t):
        i, j = s
        self[i][j] = other

    def __setitem__(self: list[T], s: tuple[slice, slice], other: int_t):
        rs, cs = s
        start_row, stop_row, _, _ = rs.adjust_indices(len(self))
        start_col, stop_col, _, _ = cs.adjust_indices(len(self[0]))
        for i in range(start_row, stop_row):
            for j in range(start_col, stop_col):
                self[i][j] = other

    def __neg__(self: list[T]) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(-s)
        return l

    def __iadd__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] += o
        return self

    def __add__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s + o)
        return l
    
    def __iadd__(self: list[list[int_t]], other: list[int_t]) -> list[list[int_t]]:
        self_shape = self.shape()
        if self_shape[1] != len(other):
            raise ValueError(f"Unsupported dimensions. Trying to add shapes {self_shape} and [{len(other)},]")

        for i in range(self_shape[0]): self[i] += other
        return self

    def __add__(self: list[list[int_t]], other: list[int_t]) -> list[list[int_t]]:
        l = list[list[int_t]](len(self))
        self_shape = self.shape()
        if self_shape[1] != len(other):
            raise ValueError(f"Unsupported dimensions. Trying to add shapes {self_shape} and [{len(other)},]")

        for s in self: l.append(s + other)
        return l
    
    def __iadd__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l
    
    def __iadd__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __iadd__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] += scalar
        return self

    def __add__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s + scalar)
        return l

    def __isub__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] -= o
        return self

    def __sub__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s - o)
        return l

    def __isub__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __isub__(self: list[T], scalar: float) -> list[T]:
        for i in range(len(self)):
            self[i] -= scalar
        return self

    def __sub__(self: list[T], scalar: float) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s - scalar)
        return l

    def __imul__(self: list[T], other: list[T]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[T], other: list[T]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], other: T) -> list[T]:
        for i in range(len(self)):
            self[i] *= other
        return self

    def __mul__(self: list[T], other: T) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * other)
        return l

    def __imul__(self: list[int_t], other: list[int]) -> list[T]:
        for i, o in enumerate(other):
            self[i] *= o
        return self

    def __mul__(self: list[int_t], other: list[int]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s * o)
        return l
    
    def __imul__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __imul__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] *= scalar
        return self

    def __mul__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s * scalar)
        return l
    
    def __imul__(self: list[T], scalar: float) -> list[T]:
        raise ValueError("MPC lists should not be multiplied by floats")

    def __mul__(self: list[T], scalar: float) -> list[T]:
        raise ValueError("MPC lists should not be multiplied by floats")
    
    def __itruediv__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l
    
    def __itruediv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] /= scalar
        return self

    def __truediv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s / scalar)
        return l

    def __ifloordiv__(self: list[T], other: list[int]) -> list[T]:
        for i in range(len(self)):
            self[i] //= other[i]
        return self

    def __floordiv__(self: list[T], other: list[int]) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s // o)
        return l
    
    def __ifloordiv__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l
    
    def __ifloordiv__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] //= scalar
        return self

    def __floordiv__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s // scalar)
        return l

    def __imod__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] %= scalar
        return self

    def __mod__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s % scalar)
        return l
    
    def __imod__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] %= scalar
        return self

    def __mod__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s % scalar)
        return l

    def __ipow__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __ipow__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] **= scalar
        return self

    def __pow__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s ** scalar)
        return l
    
    def __iand__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l
    
    def __iand__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] &= scalar
        return self

    def __and__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s & scalar)
        return l

    def __ilshift__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l

    def __irshift__(self: list[T], scalar: int_t) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: int_t) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __ilshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] <<= scalar
        return self

    def __lshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s << scalar)
        return l
    
    def __irshift__(self: list[T], scalar: int) -> list[T]:
        for i in range(len(self)):
            self[i] >>= scalar
        return self

    def __rshift__(self: list[T], scalar: int) -> list[T]:
        l = list[T](len(self))
        for s in self: l.append(s >> scalar)
        return l
    
    def __lt__(self: list[T], other: list[T]) -> bool:
        # TODO: Change to reflect numpy's behavior
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s < o: continue
            else: return False

        return True

    def __gt__(self: list[T], other: list[T]) -> bool:
        # TODO: Change to reflect numpy's behavior
        assert len(self) == len(other), 'Comparing lists of different sizes'
        
        for s, o in zip(self, other):
            if s > o: continue
            else: return False

        return True

    def __ge__(self: list[T], other: list[T]) -> bool:
        # TODO: Change to reflect numpy's behavior
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s >= o: continue
            else: return False

        return True

    def __le__(self: list[T], other: list[T]) -> bool:
        # TODO: Change to reflect numpy's behavior
        assert len(self) == len(other), 'Comparing lists of different sizes'

        for s, o in zip(self, other):
            if s <= o: continue
            else: return False

        return True
    
    def numpy_eq(self: list[T], other: list[T]) -> list[T]:
        #TODO: Make this a native __eq__ of list
        #TODO: Make it work for all shapes.
        return [T(s == o) for s, o in zip(self, other)]

    def powers(self: list[T], other, modulus: int_t) -> int_t:
        result = int_t(1)
        for s, o in zip(self, other):
            result *= mod_pow(s, int_t(o), modulus)
            result %= modulus
        return result

    def naive_mult_transposed(self: list[T], other: list[T], modulus) -> list[T]:
        self_shape = self.shape()
        other_shape = other.shape()
        assert self_shape[1] == other_shape[0], f"Not aligned shapes {self_shape} and {other_shape} for matmul"

        new_mat = list[T](self_shape[0])
        other_t = other.transpose()

        for i in range(self_shape[0]):
            new_row = list[typeof(modulus)](other_shape[1])
            for j in range(other_shape[1]):
                cell_value = typeof(modulus)(0)
                for k in range(self_shape[1]):
                    cell_value += (self[i][k] * other_t[j][k]) % modulus
                    cell_value %= modulus
                new_row.append(cell_value)
            new_mat.append(new_row)

        return new_mat
    
    def naive_mult(self: list[T], other: list[T], modulus) -> list[T]:
        self_shape = self.shape()
        other_shape = other.shape()
        assert self_shape[1] == other_shape[0], f"Not aligned shapes {self_shape} and {other_shape} for matmul"

        new_mat = list[T](self_shape[0])

        for i in range(self_shape[0]):
            new_row = list[typeof(modulus)](other_shape[1])
            for j in range(other_shape[1]):
                cell_value = typeof(modulus)(0)
                for k in range(self_shape[1]):
                    cell_value += (self[i][k] * other[k][j]) % modulus
                    cell_value %= modulus
                new_row.append(cell_value)
            new_mat.append(new_row)

        return new_mat
    
    def mult(self: list[T], other: list[T], modulus) -> list[T]:
        if not MATRIX_OPT: return self.naive_mult(other, modulus)
        else: return self.naive_mult_transposed(other, modulus)

    def shape(self: list[T]):
        if isinstance(T, int) or isinstance(T, int_t):
            return [len(self)]
        
        return [len(self), len(self[0])]

    def transpose(self: list[T]) -> list[T]:
        if not self:
            return self
        
        rows, cols = self.shape()
        new_mat = list[T](cols)
        t = typeof(self[0][0])

        for i in range(cols):
            row = list[t](rows)
            for j in range(rows):
                row.append(self[j][i])
            new_mat.append(row)

        return new_mat

    def flatten(self: list[T]) -> list[int_t]:
        return [e for row in self for e in row]

    def reshape(self: list[T], shape) -> list[T]:
        rows, cols = shape
        _, old_cols = self.shape()
        new_mat = list[T](rows)
        position: int = 0
        first_elem = self[0][0]

        for _ in range(rows):
            row = list[typeof(first_elem)](cols)
            for _ in range(cols):
                old_i = position // old_cols
                old_j = position % old_cols
                row.append(self[old_i][old_j])
                position += 1
            new_mat.append(row)

        return new_mat

    def to_bytes(self: list[T]):
        for v in self:
            for b in v.to_bytes():
                yield b
    
    def to_int_t(self: list[T]):
        return [e.to_int_t() for e in self]
    
    def pad_vec(self: list[T], length: int) -> list[T]:
        new_vec = list[T](length)
        for _ in range(length): new_vec.append(T(0))
        for i in range(min(len(self), length)): new_vec[i] = self[i]

        return new_vec

    def pad(self: list[T], rows: int, cols: int) -> list[T]:
        new_mat = list[T](rows)

        for _ in range(rows):
            row = list[int_t](cols)
            for _ in range(cols): row.append(int_t(0))
            new_mat.append(row)

        m, n = self.shape()

        for i in range(min(m, rows)):
            for j in range(min(n, cols)):
                new_mat[i][j] = self[i][j]

        return new_mat
    
    def elem_count(self: list[T]) -> int:
        if isinstance(T, list[list]):
            raise TypeError("Sequre does not support dimensions higher than 2.")
        
        if isinstance(T, list):
            return len(self) * len(self[0])
        
        return len(self)
    
    def rand(self: list[T], base):
        if isinstance(self, list[list[list]]):
            raise TypeError("Sequre does not support dimensions higher than 2.")

        if isinstance(self, list[list]):
            return __rand_mat(self.shape(), base)
        else:
            return __rand_vec(len(self), base)
    
    def rand_bits(self: list[T], bitlen: int):
        if isinstance(self, list[list[list]]):
            raise TypeError("Sequre does not support dimensions higher than 2.")

        if isinstance(self, list[list]):
            return __rand_mat_bits(self.shape(), bitlen)
        else:
            return __rand_vec_bits(len(self), bitlen)
    
    def get_identity(self: list[T]) -> list[T]:
        identity = self.zeros()
        for i in range(len(self)):
            identity[i][i] = int_t(1)
        return identity
    
    def fixed_value(self: list[T], value) -> list[T]:
        if isinstance(self, list[int_t]) and isinstance(value, int_t):
            return [int_t(value) for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]) and isinstance(value, int_t):
            return [[int_t(value) for _ in range(len(self[0]))] for _ in range(len(self))]
        if isinstance(self, list[int]) and isinstance(value, int):
            return [value for _ in range(len(self))]
        if isinstance(self, list[list[int]]) and isinstance(value, int):
            return [[value for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type within a fixed value method: {self}')
    
    def zeros(self: list[T]) -> list[T]:
        if isinstance(self, list[int_t]):
            return [int_t(0) for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]):
            return [[int_t(0) for _ in range(len(self[0]))] for _ in range(len(self))]
        if isinstance(self, list[int]):
            return [0 for _ in range(len(self))]
        if isinstance(self, list[list[int]]):
            return [[0 for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type within zeros method: {self}')
    
    def zeros_float(self: list[T]):
        if isinstance(self, list[list[list]]):
            raise TypeError("Sequre does not support dimensions higher than 2.")
        
        if isinstance(self, list[list]):
            return [[0.0 for _ in range(len(self[0]))] for _ in range(len(self))]
        else:
            return [0.0 for _ in range(len(self))]
    
    def ones(self: list[T]) -> list[T]:
        if isinstance(self, list[int_t]):
            return [int_t(1) for _ in range(len(self))]
        if isinstance(self, list[list[int_t]]):
            return [[int_t(1) for _ in range(len(self[0]))] for _ in range(len(self))]
        if isinstance(self, list[int]):
            return [1 for _ in range(len(self))]
        if isinstance(self, list[list[int]]):
            return [[1 for _ in range(len(self[0]))] for _ in range(len(self))]
        
        raise TypeError(f'Invalid type within ones method: {self}')
    
    def copy(self: list[T]):
        new_list = list[T](len(self))

        for e in self:
            new_list.append(e.copy())
        
        return new_list
    
    def has_zero(self: list[T]) -> bool:
        for e in self:
            if e.has_zero(): return True
        return False
    
    def to_float(self: list[T]):
        return [e.to_float() for e in self]
    
    def to_int(self: list[T]):
        return [e.to_int() for e in self]
    
    def parallel_add(self: list[T], other) -> list[T]:
        l = list[T](len(self))
        for s, o in zip(self, other): l.append(s + o)
        return l

    def broadcast_add(self: list[T], other) -> list[T]:
        l = list[list[int_t]](len(self))
        self_shape = self.shape()
        if self_shape[1] != len(other):
            raise ValueError(f"Unsupported dimensions. Trying to add shapes {self_shape} and [{len(other)},]")

        for s in self: l.append(s + other)
        return l
    
    def sum(self: list[T]) -> T:
        s = self[0]
        for i in range(1, len(self)): s += self[i]
        return s
    
    def floor_mean(self: list[T]) -> T:
        return self.sum() // len(self)
    
    def mean(self: list[T]):
        return self.sum() / len(self)
