from pickle import pickle, unpickle

from ..lattiseq.rlwe import \
    SecretKey, \
    PublicKey, \
    RelinearizationKey, \
    RotationKeySet, \
    EvaluationKey
from ..lattiseq.ckks import \
    Parameters, \
    EncoderComplex128, \
    PkEncryptor, \
    Decryptor, \
    Evaluator, \
    Ciphertext, \
    new_evaluator, \
    new_encoder_complex, \
    new_encryptor, \
    new_decryptor
from ..lattiseq.rlwe import Ciphertext as RLWECiphertext
from ..lattiseq.ring import Poly
from ..lattiseq.ringqp import Poly as QPPoly


@extend
class Poly:
    def __pickle__(self, jar: Jar):
        pickle(self.buff, jar)
        pickle(self.is_ntt, jar)
        pickle(self.is_mform, jar)
    
    def __unpickle__(jar: Jar) -> Poly:
        buff = unpickle(jar, list[u64])
        is_ntt = unpickle(jar, bool)
        is_mform = unpickle(jar, bool)
        pol = Poly(
            buff=buff,
            is_ntt=is_ntt,
            is_mform=is_mform)
        pol.update_coeffs()
        
        return pol
    
    def pickle_size(self) -> int:
        return self.buff.pickle_size() + \
            self.is_ntt.pickle_size() + \
            self.is_mform.pickle_size()


@extend
class QPPoly:
    def __pickle__(self, jar: Jar):
        pickle(self.q, jar)
        pickle(self.p, jar)
    
    def __unpickle__(jar: Jar) -> QPPoly:
        q = unpickle(jar, Poly)
        p = unpickle(jar, Poly)
        qp_pol = QPPoly(q=q, p=p)
        return qp_pol
    
    def pickle_size(self) -> int:
        return self.q.pickle_size() + self.p.pickle_size()


@extend
class Ciphertext:
    def __pickle__(self, jar: Jar):
        pickle(self.scale, jar)
        pickle(self.value, jar)
    
    def __unpickle__(jar: Jar) -> Ciphertext:
        scale = unpickle(jar, float)
        value = unpickle(jar, list[Poly])

        return Ciphertext(RLWECiphertext(value), scale)
    
    def pickle_size(self) -> int:
        return self.scale.pickle_size() + self.value.pickle_size()



# CryptoParams aggregates all ckks scheme information
class CryptoParams:
    sk: SecretKey
    aggregate_sk: SecretKey
    pk: PublicKey
    rlk: RelinearizationKey
    rotks: RotationKeySet
    params: Parameters

    encoder: EncoderComplex128
    encryptor: PkEncryptor
    decryptor: Decryptor
    evaluator: Evaluator

    prec: u64

    def __init__(
            self, params: Parameters, sk: SecretKey,
            aggregate_sk: SecretKey, pk: PublicKey,
            rlk: RelinearizationKey, prec: u64):
        
        self.evaluator = new_evaluator(params, EvaluationKey(rlk=rlk))
        self.encoder = new_encoder_complex(params)  # TODO: #218 Replace with big encoder
        self.encryptor = new_encryptor(params, pk)
        self.decryptor = new_decryptor(params, aggregate_sk)

        self.params = params
        self.sk = sk
        self.aggregate_sk = aggregate_sk
        self.pk = pk
        self.rlk = rlk
        self.prec = prec  # TODO: #218 Replace with big encoder


# NewCryptoParams initializes CryptoParams with the given values
def new_crypto_params(
        params: Parameters, sk: SecretKey, aggregate_sk: SecretKey,
        pk: PublicKey, rlk: RelinearizationKey, prec: u64) -> CryptoParams:
    return CryptoParams(
        params=params, sk=sk, aggregate_sk=aggregate_sk,
        pk=pk, rlk=rlk, prec=prec)
