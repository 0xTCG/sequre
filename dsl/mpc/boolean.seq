import math

from ..utils.param import *
from ..utils.utils import zeros
from ..types.utils import num_to_bits

from prg import MPCPRG
from comms import MPCComms
from arithmetic import MPCArithmetic
from polynomial import MPCPolynomial


class MPCBoolean[TP]:
    or_lagrange_cache: dict[tuple[int, TP], list[TP]]
    or_lagrange_cache_small: dict[tuple[int, int], list[int]]
    primes_bits: dict[int, int]
    primes_bytes: dict[int, int]
    pid: int
    prg: MPCPRG
    comms: MPCComms[TP]
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]

    def __init__(self, pid: int, prg: MPCPRG, comms: MPCComms[TP], arithmetic: MPCArithmetic[TP], polynomial: MPCPolynomial[TP]):
        self.pid = pid
        self.prg = prg
        self.comms = comms
        self.arithmetic = arithmetic
        self.polynomial = polynomial

        self.or_lagrange_cache = dict[tuple[int, TP], list[TP]]()
        self.or_lagrange_cache_small = dict[tuple[int, int], list[int]]()
        self.primes_bits = {0: 63, 1: 5, 2: 5}  # TODO: #56 Fix. {k: int(math.ceil(math.log2(float(v)))) for k, v in self.primes.items()}
        self.primes_bytes = {k: (v + 7) // 8 for k, v in self.primes_bits.items()}
    
    def in_lagrange_cache(self, key):
        if isinstance(key[1], TP):
            return key in self.or_lagrange_cache
        elif isinstance(key[1], int):
            return key in self.or_lagrange_cache_small
        raise TypeError(f"Invalid type of {key}")
    
    def from_lagrange_cache(self, key):
        if isinstance(key[1], TP):
            return self.or_lagrange_cache[key]
        elif isinstance(key[1], int):
            return self.or_lagrange_cache_small[key]
        raise TypeError(f"Invalid type of {key}")
    
    def to_lagrange_cache(self, key, lagrange_list):
        if isinstance(key[1], TP):
            self.or_lagrange_cache[key] = lagrange_list
        elif isinstance(key[1], int):
            self.or_lagrange_cache_small[key] = lagrange_list
        else:
            raise TypeError(f"Invalid type {key}")
    
    def carries(self, a_bits, b_bits, public, modulus):
        """
        Computes the carry-overs when adding the two provided secret-shared bit representations.
        See chapter 6.3 in
            Unconditionally Secure Constant-Rounds MPC for Equality, Comparison, Bits and Exponentiation
            by Damgard et al.
        """
        s = (a_bits * b_bits) if public else self.arithmetic.multiply(a_bits, b_bits, modulus)
        intermediate_s = self.arithmetic.add_public(a_bits, b_bits, modulus) if public else (a_bits + b_bits)
        p = (intermediate_s - s * 2) % modulus
        k = self.arithmetic.add_public(-s - p, 1, modulus)

        return self.__prefix_carry(s, p, k, modulus)
    
    def bit_add(self, a_bits, b_bits, public, modulus):
        """
        Performs the bitwise addition of the inputs -- the secret-shared bit-decompositions.
        See chapter 6.2 in
            Unconditionally Secure Constant-Rounds MPC for Equality, Comparison, Bits and Exponentiation
            by Damgard et al.
        """
        c = self.carries(a_bits, b_bits, public, modulus)
        c_t = c.transpose()
        s_1 = self.arithmetic.add_public(a_bits, b_bits, modulus) if public else (a_bits + b_bits)
        d_t = (s_1 - c * 2).transpose() % modulus
        d_t[1:] = (d_t[1:] + c_t[:-1]) % modulus
        add_1 = [row[0] for row in a_bits]
        add_2 = [row[0] for row in b_bits]
        s_2 = self.arithmetic.add_public(add_1, add_2, modulus) if public else (add_1 + add_2)
        d_t[0] = (s_2 - c_t[0] * 2) % modulus
        d_t.append(c_t[-1])

        return d_t.transpose()
    
    def bit_decomposition(self, a, bitlen, small_modulus, modulus):
        """
        Secure bit decomposition algorithm.
        See chapter 3 in
            Unconditionally Secure Constant-Rounds MPC for Equality, Comparison, Bits and Exponentiation
            by Damgard et al.
        """
        assert bitlen <= MODULUS_BITS, "Cannot cut off more bits than the size of field"

        r, rbits = self.__share_random_bits(MODULUS_BITS, len(a), True, small_modulus, modulus)
        
        c = self.comms.reveal(a - r, modulus)
        cbits = num_to_bits(c, MODULUS_BITS, True)

        dbits = self.bit_add(rbits, cbits, public=True, modulus=small_modulus)

        field_bits = num_to_bits([modulus], MODULUS_BITS + 1, True)
        field_bits_spanned = [field_bits[0] for _ in range(len(a))]

        q = self.flip_bit(self.less_than_bits_public(
            list(reversed(dbits.transpose())).transpose(),
            list(reversed(field_bits_spanned.transpose())).transpose(), small_modulus), small_modulus)
        fbits = num_to_bits([((TP(1) << MODULUS_BITS) - modulus)], MODULUS_BITS + 1, True)
        fbits_spanned = [fbits[0] for _ in range(len(a))]

        for i in range(len(fbits_spanned)): fbits_spanned[i] = (fbits_spanned[i] * q[i]) % small_modulus

        hbits = self.bit_add(dbits, fbits_spanned, public=False, modulus=small_modulus)
        cutoff = MODULUS_BITS - bitlen
        
        return hbits.transpose()[:-2 - cutoff].transpose()
    
    def demultiplexer(self, bits_matrix, modulus):
        demuxi = []
        rows, bits_len = bits_matrix.shape()

        mask_list = list(range(1 << bits_len))
        bits_pair = [self.flip_bit(bits_matrix, modulus), bits_matrix]

        for i in range(rows):
            demuxi.append(
                self.__demux(bits_pair, mask_list, i, bits_len, modulus))
        
        return demuxi

    def fan_in_or(self, a, modulus):
        n, d = a.shape()
        a_sum = [typeof(modulus)(0) for _ in range(n)]

        # TODO: #16 Vectorize a_sum calculation below
        if self.pid > 0:
            for i in range(n):
                a_sum[i] = typeof(modulus)(self.pid == 1)
                for j in range(d):
                    a_sum[i] += a[i][j]
        
        a_sum %= modulus

        key: tuple[int, typeof(modulus)] = (d + 1, modulus)
        if not self.in_lagrange_cache(key):
            y = [typeof(modulus)(i != 0) for i in range(d + 1)]
            coeff_param = self.polynomial.lagrange_interp_simple(y, modulus) # OR function
            self.to_lagrange_cache(key, coeff_param)
        
        coeff = [self.from_lagrange_cache(key)]
        bmat = self.polynomial.evaluate_poly(a_sum, coeff, modulus)

        return bmat[0]
        
    def prefix_or(self, a, modulus):
        # TODO: #57 Performance warning. Allocation/assignment is redundant in this method.
        n, m = a.shape()

        # Find next largest squared integer
        L: int = int(math.ceil(math.sqrt(float(m))))
        L2: int = L * L

        # Zero-pad to L2 bits
        a_padded = list[list[typeof(modulus)]](n)  # zeros((n, L2))
        
        if self.pid > 0:
            for i in range(n):
                row = list[typeof(modulus)](L2)
                for j in range(L2):
                    if j >= L2 - m: row.append(a[i][j - L2 + m])
                    else: row.append(typeof(modulus)(0))
                a_padded.append(row)
        else:
            for i in range(n):
                a_padded.append([typeof(modulus)(0) for _ in range(L2)])
        
        a_padded = a_padded.reshape([n * L, L])
        
        x = self.fan_in_or(a_padded, modulus)        
        xpre = [[typeof(modulus)(0) for _ in range(L)] for _ in range(n * L)]  # zeros((n * L, L))
        
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    xpi: int = L * i + j
                    for k in range(L):
                        xpre[xpi][k] = x[L * i + k] * int(k <= j)
        
        y = self.fan_in_or(xpre, modulus)

        # TODO: #16 Make it parallel
        f = [[[typeof(modulus)(0) for _ in range(L)]] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    if j == 0:
                        f[i][0][j] = x[L * i]
                    else:
                        f[i][0][j] = y[L * i + j] - y[L * i + j - 1]
                f[i] %= modulus

        # TODO: #16 Make it parallel
        tmp = [[[typeof(modulus)(0) for _ in range(L)] for _ in range(L)] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    tmp[i][j][:] = a_padded[L * i + j]
                tmp[i] %= modulus

        c = self.arithmetic.multiply_mat_bulk(f, tmp, modulus)  # c is a concatenation of n 1-by-L matrices

        cpre = [[typeof(modulus)(0) for _ in range(L)] for _ in range(n * L)]  # zeros((n * L, L))
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    cpi: int = L * i + j
                    for k in range(L):
                        cpre[cpi][k] = c[i][0][k] * int(k <= j)
        
        bdot_vec = self.fan_in_or(cpre, modulus)

        bdot = [[[typeof(modulus)(0) for _ in range(L)]] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    bdot[i][0][j] = bdot_vec[L * i + j]
        
        for i in range(n):
            f[i] = f[i].reshape([L, 1])

        s = self.arithmetic.multiply_mat_bulk(f, bdot, modulus)

        b = list[list[typeof(modulus)]](n)  # zeros(a.shape)
        if self.pid > 0:
            for i in range(n):
                row = list[typeof(modulus)](m)
                for j in range(m):
                    j_pad: int = L2 - m + j

                    il: int = j_pad // L
                    jl: int = j_pad - il * L

                    row.append(((s[i][il][jl] + y[L * i + il]) % modulus - f[i][il][0]) % modulus)
                b.append(row)
        else:
            for i in range(n):
                b.append([typeof(modulus)(0) for _ in range(m)])

        return b
    
    def fan_in_and(self, a, modulus):
        """
        We combine De Morgan identities with fan-in-or to compute fan-in-and:
            fan_in_and(a) = neg(fan_in_or(neg(a)))
        """
        return self.flip_bit(self.fan_in_or(self.flip_bit(a, modulus), modulus), modulus)
    
    def prefix_and(self, a, modulus):
        """
        We combine De Morgan identities with prefix-or to compute prefix-and:
            prefix_and(a) = neg(prefix_or(neg(a)))
        """
        return self.flip_bit(self.prefix_or(self.flip_bit(a, modulus), modulus), modulus)

    def less_than_bits_public(self, a, b_pub, modulus):
        return self.less_than_bits_aux(a, b_pub, 2, modulus)

    def less_than_bits(self, a, b, modulus):
        return self.less_than_bits_aux(a, b, 0, modulus)
    
    def less_than_bits_aux(self, a, b, public_flag, modulus):
        assert a.shape() == b.shape(), f"Unaligned bits shapes at CP{self.pid}: {a.shape()} and {b.shape()}"

        n, L = a.shape()

        # TODO: #57 Performance warning. Redundant allocation/assignment of x bellow.
        # Calculate XOR
        x = a.zeros()

        if public_flag == 0:
            x = self.arithmetic.multiply(a, b, modulus)
            if self.pid > 0:
                x = ((a + b) % modulus - (x + x) % modulus) % modulus
        elif self.pid > 0:
            x = (a * b) % modulus
            x = ((a + b) % modulus - (x + x) % modulus) % modulus
            if self.pid == 2:
                x = (x - (a if public_flag == 1 else b)) % modulus

        f = self.prefix_or(x, modulus)

        if self.pid > 0:
            for i in range(n):
                for j in range(L - 1, 0, -1):
                    f[i][j] = (f[i][j] - f[i][j - 1]) % modulus
        
        if public_flag == 2:
            c = [typeof(modulus)(0) for _ in range(n)]  # zeros(n)
            if self.pid > 0:
                fb: list[list[typeof(modulus)]] = (f * b) % modulus
                for i in range(n):
                    for e in fb[i]:
                        c[i] = (c[i] + e) % modulus
            
            return c

        # TODO: #16 Optimize
        f_arr = [[[typeof(modulus)(0) for _ in range(L)]] for _ in range(n)]
        b_arr = [[[typeof(modulus)(0)] for _ in range(L)] for _ in range(n)]

        if self.pid > 0:
            for i in range(n):
                f_arr[i][0][:] = f[i]
                for j in range(L):
                    b_arr[i][j][0] = b[i][j]
        
        c_arr = self.arithmetic.multiply_mat_bulk(f_arr, b_arr, modulus)

        return [c_arr[i][0][0] if self.pid > 0 else typeof(modulus)(0) for i in range(n)]
    
    def is_positive(self, a, modulus):
        if modulus.popcnt() == 1:
            return self.arithmetic.field_to_ring(
                self.__is_positive(a, FIELD_SIZE))
        return self.__is_positive(a, modulus)
    
    def less_than_public(self, a, bpub, modulus):
        if isinstance(a, int_t):
            return self.__less_than_public([a], bpub, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__less_than_public(a, bpub, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__less_than_public(row, bpub, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def less_than(self, a, b, modulus):
        if isinstance(a, int_t):
            return self.__less_than([a], b, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__less_than(a, b, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__less_than(row, b, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def not_less_than(self, a, b, modulus):
        if isinstance(a, int_t):
            return self.__not_less_than([a], b, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__not_less_than(a, b, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__not_less_than(row, b, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def not_less_than_public(self, a, bpub, modulus):
        if isinstance(a, int_t):
            return self.__not_less_than_public([a], bpub, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__not_less_than_public(a, bpub, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__not_less_than_public(row, bpub, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def greater_than_public(self, a, bpub, modulus):
        if isinstance(a, int_t):
            return self.__greater_than_public([a], bpub, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__greater_than_public(a, bpub, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__greater_than_public(row, bpub, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def greater_than(self, a, b, modulus):
        if isinstance(a, int_t):
            return self.__greater_than([a], b, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__greater_than(a, b, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__greater_than(row, b, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def not_greater_than(self, a, b, modulus):
        if isinstance(a, int_t):
            return self.__not_greater_than([a], b, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__not_greater_than(a, b, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__not_greater_than(row, b, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def not_greater_than_public(self, a, bpub, modulus):
        if isinstance(a, int_t):
            return self.__not_greater_than_public([a], bpub, modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__not_greater_than_public(a, bpub, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__not_greater_than_public(row, bpub, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def flip_bit(self, a, modulus):
        b = a.zeros() if self.pid == 0 else -a
        return self.arithmetic.add_public(b, 1, modulus)
    
    def beaver_flip_bit(self, a, a_mask, modulus):
        if self.pid > 0:
            a *= -1
            for i in range(len(a)): a[i] += 1
        a_mask *= -1
        a %= modulus
        a_mask %= modulus

    def __is_positive(self, a, modulus):
        if isinstance(a, int_t):
            return self.__is_positive_aux([a], modulus)[0]
        elif isinstance(a, list[int_t]):
            return self.__is_positive_aux(a, modulus)
        elif isinstance(a, list[list[int_t]]):
            return [self.__is_positive_aux(row, modulus) for row in a]
        else:
            raise TypeError(f'Invalid type of {a}')
    
    def __is_positive_aux(self, a, modulus):
        n = len(a)
        nbits = self.primes_bits[0]
        small_modulus = THIRD_FIELD_SIZE

        r = [TP(0) for _ in range(n)]
        r_bits = [[typeof(small_modulus)(0) for _ in range(nbits)] for _ in range(n)]
        if self.pid == 0:
            r = a.rand(modulus)
            r_bits = num_to_bits(r, nbits)

            self.prg.switch_seed(1)
            r_mask = r.rand(modulus)
            r_bits_mask = r_bits.rand(small_modulus)
            self.prg.restore_seed(1)

            r -= r_mask
            r_bits -= r_bits_mask
            r %= modulus
            r_bits %= small_modulus

            self.comms.send(r, 2)
            self.comms.send(r_bits, 2)
        elif self.pid == 2:
            r = self.comms.receive[TP](0, n)
            r_bits = self.comms.receive[typeof(small_modulus)](0, shape=[n, nbits])
        else:
            self.prg.switch_seed(0)
            r = r.rand(modulus)
            r_bits = r_bits.rand(small_modulus)
            self.prg.restore_seed(0)

        c = (((a + a) % modulus) + r) % modulus if self.pid != 0 else [TP(0)]
        c = self.comms.reveal(c, modulus=modulus)

        c_bits = num_to_bits(c, nbits) if self.pid != 0 else [[typeof(small_modulus)(0) for _ in range(nbits)] for _ in range(n)]  # zeros((n, nbits))

        # Incorrect result if r = 0, which happens with probaility 1 / modulus
        no_overflow = self.less_than_bits_public(r_bits, c_bits, modulus=small_modulus)

        c_xor_r = list[typeof(small_modulus)](n)  # zeros(n)
        if self.pid > 0:
            # Warning: Overflow might occur below.
            for i in range(n):
                v = r_bits[i][nbits - 1] - typeof(small_modulus)(2) * c_bits[i][nbits - 1] * r_bits[i][nbits - 1]
                if self.pid == 1:
                    v += c_bits[i][nbits - 1]
                c_xor_r.append(v)
            c_xor_r %= small_modulus
        else:
            for _ in range(n):
                c_xor_r.append(typeof(small_modulus)(0))
        
        lsb = self.arithmetic.multiply(c_xor_r, no_overflow, small_modulus)
        if self.pid > 0:
            lsb = (lsb + lsb) % small_modulus
            lsb -= (no_overflow + c_xor_r) % small_modulus
            if self.pid == 1:
                lsb = (lsb + 1) % small_modulus
        lsb %= small_modulus

        # 0, 1 -> 1, 2
        if self.pid == 1:
            lsb = (lsb + 1) % small_modulus
        
        b_mat = self.polynomial.table_lookup([TP(e) for e in lsb], 0, modulus)

        return b_mat[0]

    def __less_than_public(self, a, bpub, modulus):
        b_a = self.arithmetic.add_public(-a, bpub, modulus) if self.pid != 0 else a.zeros()

        return self.is_positive(b_a, modulus)
    
    def __less_than(self, a, b, modulus):
        b_a = ((b - a) % modulus) if self.pid != 0 else a.zeros()

        return self.is_positive(b_a, modulus)

    def __not_less_than(self, a, b, modulus):
        c = self.__less_than(a, b, modulus)
        c = self.flip_bit(c, modulus)

        return c
    
    def __not_less_than_public(self, a, bpub, modulus):
        c = self.__less_than_public(a, bpub, modulus)
        c = self.flip_bit(c, modulus)

        return c

    def __greater_than_public(self, a, bpub, modulus):
        a_b = self.arithmetic.add_public(a, -bpub, modulus) if self.pid != 0 else a.zeros()

        return self.is_positive(a_b, modulus)
    
    def __greater_than(self, a, b, modulus):
        a_b = ((a - b) % modulus) if self.pid != 0 else a.zeros()

        return self.is_positive(a_b, modulus)

    def __not_greater_than(self, a, b, modulus):
        c = self.__greater_than(a, b, modulus)
        c = self.flip_bit(c, modulus)

        return c
    
    def __not_greater_than_public(self, a, bpub, modulus):
        c = self.__greater_than_public(a, bpub, modulus)
        c = self.flip_bit(c, modulus)

        return c
    
    def __spk_convolve(self, e_1, s, p_r, r_p, k, modulus):
        """
        Carry set/propagate/bit convolution of the two (s, p, k) triplets.
        (s_1, p_1, k_1) Ëš (s_2, p_2, k_2) = (s_2 + p_2 * s_1, p_2 * p_1, k_2 + p_2 * k_1)
        See chapter 6.3 in
            Unconditionally Secure Constant-Rounds MPC for Equality, Comparison, Bits and Exponentiation
            by Damgard et al.
        """
        e_1_r, r_e_1 = self.arithmetic.__beaver_partition(e_1, modulus)
        propagate = self.arithmetic.__beaver_mult(e_1_r, r_e_1, p_r, r_p, modulus)
        propagate = self.arithmetic.__beaver_reconstruct(propagate, modulus)
        
        propagate[0] += s
        propagate[2] += k

        return propagate % modulus
    
    def __prefix_carry(self, s, p, k, modulus):
        """
        TODO: #143 Solution bellow is can be improved.
        See chapters 6.1 and 6.4 in
            Unconditionally Secure Constant-Rounds MPC for Equality, Comparison, Bits and Exponentiation
            by Damgard et al.
        """
        s_t = s.transpose()
        p_t = p.transpose()
        k_t = k.transpose()

        p_t_r, r_p_t = self.arithmetic.__beaver_partition(p_t, modulus)
        
        prefix_convolutions = [[s_t[0], p_t[0], k_t[0]]]
        
        for i in range(len(s_t) - 1):
            prefix_convolutions.append(
                self.__spk_convolve(
                    prefix_convolutions[-1],
                    s_t[i + 1], p_t_r[i + 1], r_p_t[i + 1], k_t[i + 1],
                    modulus))
        
        return [e[0] for e in prefix_convolutions].transpose()

    def __demux(self, bits_pair, mask_list, idx, bits_len, modulus):
        resolved_bits = zeros[typeof(modulus)](len(mask_list), bits_len)

        for i in range(len(mask_list)):
            for j in range(bits_len):
                resolved_bits[i][j] = bits_pair[int((mask_list[i] & (1 << j)) != 0)][idx][j]
        
        return self.fan_in_and(resolved_bits, modulus)
    
    def __share_random_bits(
            self, k: int, n: int, little_endian: bool, small_modulus: int, large_modulus: TP) -> tuple[list[TP], list[list[int]]]:
        r = [TP(0) for _ in range(n)]
        rbits = [[0 for _ in range(k)] for _ in range(n)]
        
        if self.pid == 0:
            r = r.rand(large_modulus)
            rbits = num_to_bits(r, k, little_endian)

            self.prg.switch_seed(1)
            r_mask = r.rand(large_modulus)
            rbits_mask = rbits.rand(small_modulus)
            self.prg.restore_seed(1)

            r = (r - r_mask) % large_modulus
            rbits = (rbits - rbits_mask) % small_modulus

            self.comms.send(r, 2)
            self.comms.send(rbits, 2)
            return r, rbits
        elif self.pid == 2:
            r = self.comms.receive[TP](0, n)
            rbits = self.comms.receive[int](0, [n, k])
            return r, rbits
        else:
            self.prg.switch_seed(0)
            r = r.rand(large_modulus)
            rbits = rbits.rand(small_modulus)
            self.prg.restore_seed(0)
            return r, rbits
