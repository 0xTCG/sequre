import math

from ..utils.param import *
from ..types.utils import double_to_fp

from comms import MPCComms
from arithmetic import MPCArithmetic
from fp import MPCFP
from boolean import MPCBoolean


class MPCLinAlg[TP]:
    pid: int
    arithmetic: MPCArithmetic[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]

    def __init__(self: MPCLinAlg[TP], pid: int, arithmetic: MPCArithmetic[TP], boolean: MPCBoolean[TP], fp: MPCFP[TP]):
        self.pid = pid
        self.arithmetic = arithmetic
        self.boolean = boolean
        self.fp = fp

    def householder(self: MPCLinAlg[TP], x: list[TP], modulus: TP) -> list[TP]:
        xr, xm = self.arithmetic.__beaver_partition(x, modulus)

        xdot = [self.arithmetic.beaver_inner_prod(xr, xm, modulus)]
        xdot = self.arithmetic.__beaver_reconstruct(xdot, modulus)
        xdot = self.fp.trunc(xdot, modulus)

        # Bottleneck
        xnorm, _ = self.fp.fp_sqrt(xdot, modulus)

        x1 = [x[0]]
        x1sign = self.boolean.is_positive(x1, modulus)

        x1sign = (x1sign + x1sign) % modulus
        if self.pid == 1:
            x1sign[0] = (x1sign[0] + modulus - 1) % modulus

        shift = self.arithmetic.multiply(xnorm, x1sign, modulus)
        sr, sm = self.arithmetic.__beaver_partition(shift[0], modulus)

        xr_0 = [xr[0]]
        xm_0 = [xm[0]]
        dot_shift = self.arithmetic.__beaver_mult(xr_0, xm_0, sr, sm, modulus)
        dot_shift = self.arithmetic.__beaver_reconstruct(dot_shift, modulus)
        dot_shift = self.fp.trunc(dot_shift, modulus)

        vdot = (((xdot + dot_shift) % modulus) << 1) % modulus if self.pid > 0 else [TP(0)]

        # Bottleneck
        _, vnorm_inv = self.fp.fp_sqrt(vdot, modulus)

        invr, invm = self.arithmetic.__beaver_partition(vnorm_inv[0], modulus)

        if self.pid > 0:
            xr[0] = (xr[0] + sr) % modulus
        xm[0] = (xm[0] + sm) % modulus

        v = self.arithmetic.__beaver_mult(xr, xm, invr, invm, modulus)
        v = self.arithmetic.__beaver_reconstruct(v, modulus)
        v = self.fp.trunc(v, modulus)

        return v
    
    def qr_fact_square(self: MPCLinAlg[TP], A: list[list[TP]], modulus: TP) -> tuple[list[list[TP]], list[list[TP]]]:
        shape = A.shape()
        assert shape[0] == shape[1]

        n = shape[0]

        R = [[TP(0) for _ in range(n)] for _ in range(n)]
        Q = [[TP(0) for _ in range(n)] for _ in range(n)]

        Ap = A if self.pid != 0 else [[TP(0) for _ in range(n)] for _ in range(n)]
        one = double_to_fp(1.0, modulus)

        for i in range(n - 1):
            v = [self.householder(Ap[0], modulus)]
            vt = v.transpose() if self.pid != 0 else [[TP(0)] for _ in range(len(Ap[0]))]

            # Note: vt partitions should be reused here from v instead of recalculating them within multiply_matmul
            P = self.arithmetic.multiply_matmul(vt, v, modulus)
            P = self.fp.trunc(P, modulus)

            if self.pid > 0:
                P = ((P.fixed_value(modulus) - P) << 1) % modulus
                if self.pid == 1:
                    for i in range(P.shape()[1]):
                        P[i][i] += one
                        P[i][i] %= modulus
            
            B = [[TP(0) for _ in range(n - i)] for _ in range(n - i)]
            if i == 0:
                Q = P
                B = self.arithmetic.multiply_matmul(Ap, P, modulus)
                B = self.fp.trunc(B, modulus)
            else:
                Qsub = [[TP(0) for _ in range(n)] for _ in range(n - i)]
                if self.pid > 0:
                    Qsub[:n - i] = Q[i:n]

                # TODO: #16 Parallelize following two multiplications
                left = self.arithmetic.multiply_matmul(P, Qsub, modulus)
                right = self.arithmetic.multiply_matmul(Ap, P, modulus)

                # TODO: #16 Parallelize Trunc
                left = self.fp.trunc(left, modulus)
                right = self.fp.trunc(right, modulus)

                if self.pid > 0:
                    Q[i:n] = left
                    B = right
            
            Ap = [[TP(0) for _ in range(n - i - 1)] for _ in range(n - i - 1)]
            if self.pid > 0:
                # R[i:n, i] = B[:n-i, 0]
                for j in range(n - i):
                    R[j + i][i] = B[j][0]
                if i == n - 2: R[n - 1][n - 1] = B[1][1]
                # Ap[:n - i - 1, :n - i - 1] = B[1:n - i, 1:n - i]
                for j in range(n - i - 1):
                    for k in range(n - i - 1):
                        Ap[j][k] = B[j + 1][k + 1]
            
        return Q, R

    def tridiag(self: MPCLinAlg[TP], A: list[list[TP]], modulus: TP) -> tuple[list[list[TP]], list[list[TP]]]:
        shape = A.shape()
        assert shape[0] == shape[1]
        assert shape[0] > 2

        n = shape[0]
        one = double_to_fp(1.0, modulus)

        Q = [[TP(0) for _ in range(n)] for _ in range(n)]  # zeros((n, n))
        T = [[TP(0) for _ in range(n)] for _ in range(n)]  # zeros((n, n))
        if self.pid > 0:
            if self.pid == 1:
                for i in range(n):
                    Q[i][i] = one

        Ap = A if self.pid != 0 else [[TP(0) for _ in range(n)] for _ in range(n)]

        for i in range(n - 2):
            ap_shape = Ap.shape()

            x = [TP(0) for _ in range(ap_shape[1] - 1)]
            if self.pid > 0:
                x[:] = Ap[0][1:]
            
            v = [self.householder(x, modulus)]
            vt = v.transpose()

            vv = self.arithmetic.multiply_matmul(vt, v, modulus)
            vv = self.fp.trunc(vv, modulus)

            P = [[TP(0) for _ in range(ap_shape[1])] for _ in range(ap_shape[0])]
            if self.pid > 0:
                cols_no = ap_shape[1]
                vv_part = vv[:cols_no-1, :cols_no-1]
                P[1:, 1:] = vv_part.fixed_value(modulus) - ((vv_part << 1) % modulus)
                if self.pid == 1:
                    for i in range(len(P)):
                        P[i][i] = (P[i][i] + one) % modulus

            # TODO: #16 parallelize? (minor improvement)
            PAp = self.arithmetic.multiply_matmul(P, Ap, modulus)
            PAp = self.fp.trunc(PAp, modulus)
            B = self.arithmetic.multiply_matmul(PAp, P, modulus)
            B = self.fp.trunc(B, modulus)

            Qsub = [[TP(0) for _ in range(n - i)] for _ in range(n)]
            if self.pid > 0:
                # Qsub[:, :n - i] = Q[:, i:n] TODO: Implement support for advanced slicing.
                for j in range(n):
                    for k in range(n - i):
                        Qsub[j][k] = Q[j][i + k]

            Qsub = self.arithmetic.multiply_matmul(Qsub, P, modulus)
            Qsub = self.fp.trunc(Qsub, modulus)
            if self.pid > 0:
                # Q[:, i:n] = Qsub[:, :n - i] TODO: Implement support for advanced slicing.
                for j in range(n):
                    for k in range(n - i):
                        Q[j][k + i] = Qsub[j][k]
            
            if self.pid > 0:
                T[i][i] = B[0][0]
                T[i + 1][i] = B[1][0]
                T[i][i + 1] = B[0][1]
                if i == n - 3:
                    T[i + 1][i + 1] = B[1][1]
                    T[i + 1][i + 2] = B[1][2]
                    T[i + 2][i + 1] = B[2][1]
                    T[i + 2][i + 2] = B[2][2]

            b_shape = B.shape()
            Ap = [[TP(0) for _ in range(b_shape[1] - 1)] for _ in range(b_shape[0] - 1)]
            if self.pid > 0:
                # Ap[:b_shape[0] - 1, :b_shape[1] - 1] = B[1:b_shape[0], 1:b_shape[1]]
                for j in range(b_shape[0] - 1):
                    for k in range(b_shape[1] - 1):
                        Ap[j][k] = B[j + 1][k + 1]
            
        return T, Q

    def eigen_decomp(self: MPCLinAlg[TP], A: list[list[TP]], modulus: TP) -> tuple[list[list[TP]], list[TP]]:
        a_shape = A.shape()
        assert a_shape[0] == a_shape[1]
        n = a_shape[0]

        L = [TP(0) for _ in range(n)]  # zeros(n)

        Ap, Q = self.tridiag(A, modulus)
        V = Q.transpose()

        for i in range(n - 1, 0, -1):
            for _ in range(ITER_PER_EVAL):
                shift = Ap[i][i]
                if self.pid > 0:
                    for j in range(len(Ap[0])):
                        Ap[j][j] = (Ap[j][j] + modulus - shift) % modulus

                Q, R = self.qr_fact_square(Ap, modulus)

                Ap = self.arithmetic.multiply_matmul(Q, R, modulus)
                Ap = self.fp.trunc(Ap, modulus)

                if self.pid > 0:
                    for i in range(len(Ap)):
                        Ap[i][i] = (Ap[i][i] + shift) % modulus
                
                Vsub: list[list[TP]] = [[TP(0) for _ in range(n)] for _ in range(i + 1)]  # zeros((i + 1, n))
                if self.pid > 0:
                    Vsub[:i + 1] = V[:i + 1]

                Vsub = self.arithmetic.multiply_matmul(Q, Vsub, modulus)
                Vsub = self.fp.trunc(Vsub, modulus)

                if self.pid > 0:
                    V[:i + 1] = Vsub[:i + 1]
                
            L[i] = Ap[i][i]
            if i == 1:
                L[0] = Ap[0][0]

            Ap_copy = copy(Ap)
            Ap = [[TP(0) for _ in range(i)] for _ in range(i)]
            if self.pid > 0:
                #Ap = Ap_copy[:i, :i] TODO: Implement support for advanced slicing.
                for j in range(i):
                    for k in range(i):
                        Ap[j][k] = Ap_copy[j][k]
            
        return V, L

    def orthonormal_basis(self: MPCLinAlg[TP], A: list[list[TP]], modulus: TP) -> list[list[TP]]:
        a_shape: list[int] = A.shape()
        assert a_shape[1] >= a_shape[0]

        c: int = a_shape[0]
        n: int = a_shape[1]

        v_list = list[list[TP]](c)

        Ap = A if self.pid != 0 else [[TP(0) for _ in range(n)] for _ in range(c)]
        one = double_to_fp(1.0, modulus)

        for i in range(c):
            ap_shape: list[int] = Ap.shape()
            v = [self.householder(Ap[0], modulus)]

            if self.pid == 0:
                v_list.append([TP(0) for _ in range(ap_shape[1])])
            else:
                v_list.append(v[0])

            vt = v.transpose() if self.pid != 0 else [[TP(0)] for _ in range(ap_shape[1])]

            Apv = self.arithmetic.multiply_matmul(Ap, vt, modulus)
            Apv = self.fp.trunc(Apv, modulus)
            
            B = self.arithmetic.multiply_matmul(Apv, v, modulus)
            B = self.fp.trunc(B, modulus)
            
            if self.pid > 0:
                B = B.fixed_value(modulus) - B
                B = (B << 1) % modulus
                B = (B + Ap) % modulus

            b_shape = B.shape()
            Ap = list[list[TP]](b_shape[0] - 1)
            is_cp = int(self.pid != 0)
            for i in range(b_shape[0] - 1):
                row = list[TP](b_shape[1] - 1)
                for j in range(b_shape[1] - 1):
                    row.append(B[i + 1][j + 1] * is_cp)
                Ap.append(row)
            
        Q = [[TP(0) for _ in range(n)] for _ in range(c)]
        if self.pid == 1:
            for i in range(c):
                Q[i][i] = one

        for i in range(c - 1, -1, -1):
            v = [v_list[i]] if self.pid > 0 else [[TP(0) for _ in range(len(v_list[i]))]]
            vt = v.transpose() if self.pid != 0 else [[TP(0)] for _ in range(len(v_list[i]))]

            Qsub = [[TP(0) for _ in range(n - i)] for _ in range(c)]
            if self.pid > 0:
                for j in range(c):
                    for k in range(n - i):
                        Qsub[j][k] = Q[j][k + i]

            Qv = self.arithmetic.multiply_matmul(Qsub, vt, modulus)
            Qv = self.fp.trunc(Qv, modulus)

            Qvv = self.arithmetic.multiply_matmul(Qv, v, modulus)
            Qvv = self.fp.trunc(Qvv, modulus)
            if self.pid > 0:
                Qvv = Qvv.fixed_value(modulus) - Qvv
                Qvv = (Qvv << 1) % modulus
            
            if self.pid > 0:
                for j in range(c):
                    for k in range(n - i):
                        Q[j][k + i] = (Q[j][k + i] + Qvv[j][k]) % modulus

        return Q
