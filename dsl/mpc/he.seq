import random
import logger

from ..lattiseq.rlwe import \
    SecretKey, \
    PublicKey, \
    RelinearizationKey
from ..lattiseq.ckks import \
    Parameters, \
    Ciphertext, \
    PrecisionStats, \
    Plaintext, \
    new_key_generator, \
    evaluate_precision, \
    new_plaintext, \
    new_public_key, \
    new_ciphertext, \
    new_relinearization_key
from ..lattiseq.ringqp import \
    UniformSampler, \
    Poly, \
    new_uniform_sampler
from ..lattiseq.dckks import \
    new_pcks_protocol, \
    new_ckg_protocol, \
    new_rkg_protocol
from ..lattiseq.drlwe import \
    PCKSShare, \
    CKGShare, \
    RKGShare
from ..lattiseq.utils import new_prng
from ..types.mhe import CryptoParams
from ..types.builtin import Complex

from prg import MPCPRG
from comms import MPCComms


class MPCHE[TP]:
    pid: int
    prg: MPCPRG
    comms: MPCComms[TP]

    crp_gen: UniformSampler
    crypto_params: CryptoParams
    
    def __init__(self, pid: int, prg: MPCPRG, comms: MPCComms[TP]):
        self.pid = pid
        self.prg = prg
        self.comms = comms

    def set_params(self, params: Parameters):
        self.prg.switch_seed(-1)
        seed = u32(random.getrandbits(32))
        self.prg.restore_seed(-1)

        ring_qp = params.ring_qp()
        crp_gen = new_uniform_sampler(new_prng(seed), ring_qp)

        p = ring_qp.new_poly()
        crp_gen.read(p)
        logger.log(f"Debugging output: crp_gen initial state for CP{self.pid}:", p.q.coeffs[0][0], p.q.coeffs[1][1], p.q.coeffs[2][2])

        self.crp_gen = crp_gen
    
    def aggregate_pub_key_shares(self, poly: CKGShare) -> CKGShare:
        out = CKGShare()
        ring_qp = self.crypto_params.params.ring_qp()

        pid = self.pid
        if pid > 0:
            if pid == self.comms.hub_pid:
                out.value = ring_qp.new_poly()
                
                for p in range(1, self.comms.number_of_parties):
                    new_poly = poly.value
                    if p != pid: new_poly = self.comms.receive_qp_poly(p)
                    ring_qp.add(new_poly, out.value, out.value)

                for p in range(1, self.comms.number_of_parties):
                    if p != pid: self.comms.send_qp_poly(out.value, p)

            else:
                self.comms.send_qp_poly(poly.value, self.comms.hub_pid)
                out.value = self.comms.receive_qp_poly(self.comms.hub_pid)
        
        return out
    
    def collective_pub_key_gen(self, parameters: Parameters, sh_shard: SecretKey, crp_gen: UniformSampler) -> PublicKey:
        sk = sh_shard

        ckg_protocol = new_ckg_protocol(parameters)

        pk_share = ckg_protocol.allocate_share()

        crp = parameters.ring_qp().new_poly()
        crp_gen.read(crp)
        ckg_protocol.gen_share(sk, crp, pk_share)

        pk_agg = self.aggregate_pub_key_shares(pk_share)

        hub_pid = self.comms.hub_pid
        if self.pid == 0: pk_agg.value = self.comms.receive_qp_poly(hub_pid)
        elif self.pid == hub_pid: self.comms.send_qp_poly(pk_agg.value, 0)

        pk = new_public_key(parameters)
        ckg_protocol.gen_public_key(pk_agg, crp, pk)

        return pk

    def aggregate_relin_key_share(self, share: RKGShare, second_slot: bool) -> RKGShare:
        pid = self.pid
        context_qp = self.crypto_params.params.ring_qp()
        rns_decomp = len(share.value)
        bit_decomp = len(share.value[0])

        share_out = RKGShare()
        share_out.value = list[list[list[Poly]]](rns_decomp)

        if pid > 0:
            if pid == self.comms.hub_pid:
                # Initialize
                for i in range(rns_decomp):
                    mat = list[list[Poly]](bit_decomp)
                    for j in range(bit_decomp):
                        row = list[Poly](2)
                        row.append(context_qp.new_poly())
                        if second_slot: row.append(context_qp.new_poly())
                        mat.append(row)
                    share_out.value.append(mat)

                # Aggregate
                for p in range(1, self.comms.number_of_parties):
                    for i in range(rns_decomp):
                        for j in range(bit_decomp):
                            other0, other1 = Poly(), Poly()
                            
                            if p != pid:
                                other0 = self.comms.receive_qp_poly(p)
                                if second_slot: other1 = self.comms.receive_qp_poly(p)
                            else:
                                other0 = share.value[i][j][0]
                                if second_slot: other1 = share.value[i][j][1]

                            context_qp.add(other0, share_out.value[i][j][0], share_out.value[i][j][0])
                            if second_slot: context_qp.add(other1, share_out.value[i][j][1], share_out.value[i][j][1])

                # Broadcast
                for p in range(1, self.comms.number_of_parties):
                    if p != pid:
                        for i in range(rns_decomp):
                            for j in range(bit_decomp):
                                self.comms.send_qp_poly(share_out.value[i][j][0], p)
                                if second_slot: self.comms.send_qp_poly(share_out.value[i][j][1], p)
            else:
                # Send share
                for i in range(rns_decomp):
                    for j in range(bit_decomp):
                        self.comms.send_qp_poly(share.value[i][j][0], self.comms.hub_pid)
                        if second_slot: self.comms.send_qp_poly(share.value[i][j][1], self.comms.hub_pid)

                # Receive result
                for i in range(rns_decomp):
                    for j in range(bit_decomp):
                        share_out.value[i][j][0] = self.comms.receive_qp_poly(self.comms.hub_pid)
                        if second_slot: share_out.value[i][j][1] = self.comms.receive_qp_poly(self.comms.hub_pid)

        return share_out
    
    def collective_relin_key_gen(self, params: Parameters, sk_shard: SecretKey, crp_gen: UniformSampler) -> RelinearizationKey:
        sk = sk_shard
        ring_qp = params.ring_qp()

        prot = new_rkg_protocol(params)
        eph_sk, share_1, share_2 = prot.allocate_share()

        rns_decomp = len(share_1.value)
        bit_decomp = len(share_1.value[0])

        assert len(share_1.value) == len(share_2.value)
        assert len(share_1.value[0]) == len(share_2.value[0])

        crp = list[list[Poly]](rns_decomp)
        for _ in range(rns_decomp):
            row = list[Poly](bit_decomp)
            for _ in range(bit_decomp):
                p = ring_qp.new_poly()
                crp_gen.read(p)
                row.append(p)
            crp.append(row)

        evk = new_relinearization_key(params)

        if self.pid > 0:
            prot.gen_share_round_one(sk, crp, eph_sk, share_1)
            out_round_1 = self.aggregate_relin_key_share(share_1, True)

            prot.gen_share_round_two(eph_sk, sk, out_round_1, share_2)
            outRound2 = self.aggregate_relin_key_share(share_2, True)

            prot.gen_relinearization_key(out_round_1, outRound2, evk)

        return evk

    def collective_init(self, params: Parameters, prec: u64):
        print(f"CP{self.pid}: MHE collective initialization ...")

        kgen = new_key_generator(params)
        ring_qp = params.ring_qp()

        sk_shard = SecretKey()
        if self.pid == 0: sk_shard.value = ring_qp.new_poly()
        else: sk_shard = kgen.gen_secret_key()

        # TODO: DEBUG Globally shared key
        p = ring_qp.new_poly()
        self.crp_gen.read(p)
        logger.log(f"CP{self.pid}: Crp gen check", p.q.coeffs[0][0], p.q.coeffs[1][1], p.q.coeffs[2][2])

        print(f"CP{self.pid}: MHE generating public key ...")
        pk = self.collective_pub_key_gen(params, sk_shard, self.crp_gen)

        # TODO: DEBUG
        logger.log(f"CP{self.pid}: PubKey check", pk.value[0].q.coeffs[0][0], pk.value[0].q.coeffs[1][1], pk.value[0].q.coeffs[2][2])
        logger.log(f"CP{self.pid}: PubKey check", pk.value[1].q.coeffs[0][0], pk.value[1].q.coeffs[1][1], pk.value[1].q.coeffs[2][2])

        print(f"CP{self.pid}: MHE generating relinearization key ...")
        rlk = self.collective_relin_key_gen(params, sk_shard, self.crp_gen)

        d = rlk.keys[0].value[0][0].value
        logger.log(f"CP{self.pid}: RelinKeyGen check", d[0].q.buff[0], d[1].q.buff[1], d[2].q.buff[2])

        cps = CryptoParams(params, sk_shard, sk_shard, pk, rlk, prec)

        # TODO Setup rotation keys
        # print("MHE generating rotation keys ... ")
        # if self.pid > 0:
        #     rotks = self.collective_rot_key_gen(params, sk_shard, self.crp_gen, libspindle.GenerateRotKeys(cps.GetSlots(), 20, True))
        #     cps.RotKs = rotks
        #     cps.SetEvaluators(cps.Params, rlk, cps.RotKs)

        self.crypto_params = cps
        print(f"CP{self.pid}: MHE setup complete.")
    
    def precision_stats(self, result: list, expected: list) -> PrecisionStats:
        print(f"CP{self.pid}: Values computed [0:4]: {result[:4]} ...\n")
        print(f"CP{self.pid}: Values expected [0:4]: {expected[:4]} ...\n")

        precision_stats = evaluate_precision(result.to_complex(), expected.to_complex())
        print(precision_stats)

        return precision_stats
    
    # encrypt_vector encrypts a list of values in multiple batched ciphertexts.
    # and return the number of encrypted elements.
    def encrypt_vector(self, values: list) -> Tuple[list[Ciphertext], int]:
        nbr_max_coef = self.crypto_params.params.slots()
        length = len(values)

        cipher_arr = list[Ciphertext]((length + nbr_max_coef - 1) // nbr_max_coef)
        elements_encrypted = 0
        
        while elements_encrypted < length:
            start = elements_encrypted
            end = elements_encrypted + nbr_max_coef
            if end > length: end = length

            # Encoding values
            plaintext = new_plaintext(
                self.crypto_params.params,
                self.crypto_params.params.max_level(),
                self.crypto_params.params.default_scale)
            self.crypto_params.encoder.encode(
                values[start:end].pad_vec(nbr_max_coef).to_complex(),
                plaintext,
                self.crypto_params.params.log_slots)
            
            # Encrypting plaintext
            cipher_arr.append(self.crypto_params.encryptor.encrypt_new(plaintext))
            elements_encrypted = elements_encrypted + (end - start)

        return cipher_arr, elements_encrypted
    
    # level = uint64(len(share_1[0].coeffs)) - 1
    # pcks.params.ring_q.add_lvl(level, share_1[0], share_2[0], share_out[0])
    # pcks.params.ring_q.add_lvl(level, share_1[1], share_2[1], share_out[1])
    def aggregate_decrypt_shares(self, poly: PCKSShare, out_level: int) -> PCKSShare:
        out = PCKSShare()

        pid = self.pid
        if pid > 0:
            if pid == self.comms.hub_pid:
                for i in range(len(poly.value)):
                    out[i] = self.crypto_params.params.ring_q.new_poly_lvl(out_level)

                for p in range(1, self.comms.number_of_parties):
                    for i in range(len(poly.value)):
                        new_poly = poly[i]
                        if p != pid: new_poly = self.comms.receive_poly(p)
                        level = len(new_poly.coeffs) - 1
                        self.crypto_params.params.ring_q.add_lvl(level, new_poly, out[i], out[i])

                for p in range(1, self.comms.number_of_parties):
                    if p != pid:
                        for i in range(len(poly.value)):
                            self.comms.send_poly(out[i], p)
            else:
                for i in range(len(poly.value)):
                    self.comms.send_poly(poly[i], self.comms.hub_pid)
                for i in range(len(poly.value)):
                    out[i] = self.comms.receive_poly(self.comms.hub_pid)

        return out


    def collective_decrypt(self, cps: CryptoParams, ct: Ciphertext, source_pid: int) -> Plaintext:
        tmp = ct

        # source_pid broadcasts ct to other parties for collective decryption
        if self.pid == source_pid:
            for p in range(1, self.comms.number_of_parties):
                if p != source_pid: self.comms.send_ciphertext(ct, p)
        elif self.pid > 0:
            tmp = self.comms.receive_ciphertext(source_pid)
        else:  # pid == 0
            return Plaintext()

        parameters = cps.params

        zero_pk = new_public_key(parameters)

        pcks_protocol = new_pcks_protocol(parameters, 6.36)
        dec_share = pcks_protocol.allocate_share(tmp.level())

        pcks_protocol.gen_share(cps.sk, zero_pk, tmp.value[1], dec_share)
        dec_agg = self.aggregate_decrypt_shares(dec_share, tmp.level())

        ciphertext_switched = new_ciphertext(parameters, 1, tmp.level(), tmp.scale)
        pcks_protocol.key_switch(tmp, dec_agg, ciphertext_switched)

        return ciphertext_switched.plaintext()
    
    def decode_vector[DTP=Complex](self, cps: CryptoParams, fenc: list[Plaintext]) -> list[DTP]:
        data_decoded = []

        for plaintext in fenc:
            val = cps.encoder.decode(plaintext, cps.params.log_slots)
            data_decoded.extend([(c.r if isinstance(DTP, float) else c) for c in val])

        return data_decoded
