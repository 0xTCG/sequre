import secure_operator
from functools import partial
from itertools import permutations


def argmin(arr):
    """    Return the index of smallest element in the array
    """
    if staticlen(arr) == 0:
        raise ValueError("empty sequence")
    else:
        m = arr[0]
        m_idx = 0
        for idx, i in enumerate(arr):
            if i < m:
                m = i
                m_idx = idx
        return m_idx


def argmax(arr):
    """    Return the index of largest element in the array
    """
    if staticlen(arr) == 0:
        raise ValueError("empty sequence")
    else:
        m = arr[0]
        m_idx = 0
        for idx, i in enumerate(arr):
            if i > m:
                m = i
                m_idx = idx
        return m_idx


def min_by_key(iterable, key):
    x = iterable.__iter__()
    if not x.done():
        s = x.next()
        k = key(s)
        while not x.done():
            i = x.next()
            ki = key(i)
            if ki < k:
                s = i
                k = ki
        x.destroy()
        return s
    else:
        x.destroy()
    raise ValueError("empty sequence")


def max_by_key(iterable, key):
    x = iterable.__iter__()
    if not x.done():
        s = x.next()
        k = key(s)
        while not x.done():
            i = x.next()
            ki = key(i)
            if ki > k:
                s = i
                k = ki
        x.destroy()
        return s
    else:
        x.destroy()
    raise ValueError("empty sequence")


def _matmul_cost_by_order(shapes, order):
    total_cost = 0
    shapes_copy = [e for e in shapes]
    
    for i in range(len(order)):
        o = order[i]
        total_cost += (shapes_copy[o][0] * shapes_copy[o][1] * shapes_copy[o + 1][0])
        shapes_copy[o] = (shapes_copy[o][0], shapes_copy[o + 1][1])
        del shapes_copy[o + 1]
        
        for j in range(len(order)):
            if o < order[j]:
                order[j] -= 1
    
    return total_cost


def evaluate_by_order(mpc, mats, order, _op):
    for i in range(len(order)):
        o = order[i]
        mats[o] = _op(mpc, mats[o], mats[o + 1])
        del mats[o + 1]
        
        for j in range(len(order)):
            if o < order[j]:
                order[j] -= 1
    
    return mats[0]


def matmul_reordering(mpc, mats):
    assert len(mats) <= 10, f"Unable to calculate min ordering of matmul for {len(mats)} (too many permutations)"
    
    shapes = [m.shape for m in mats]
    min_permutation = min_by_key(
        iterable=permutations(range(len(mats) - 1)),
        key=partial(_matmul_cost_by_order, shapes))
    
    return evaluate_by_order(mpc, [m for m in mats], min_permutation, secure_operator.matmul)
