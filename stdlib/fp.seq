import math

from sequre import sequre_beaver

from ..utils.custom_types import SecureValue
from ..utils.param import NBIT_K, NBIT_F


def normalizer_even_exponent(mpc, a):
    s_val, s_sqrt_val = mpc.fp.__nee_wrapper(a.share)
    s = SecureValue(s_val)
    s_sqrt = SecureValue(s_sqrt_val)
    s.fp = True
    s_sqrt.fp = True
    return s, s_sqrt


@sequre_beaver
def fp_sqrt(mpc, a):
    niter = int(2 * math.ceil(math.log2((NBIT_K) / 3.5)))
    s, s_sqrt = normalizer_even_exponent(mpc, a)

    # TODO: #67 Have Sequre calculate truncation sizes. Below code should be just: a_scaled = a * s
    if not a.is_partitioned(): a.set_partitions(mpc.arithmetic.__beaver_partition(a.share))
    if not s.is_partitioned(): s.set_partitions(mpc.arithmetic.__beaver_partition(s.share))
    a_scaled_val = mpc.arithmetic.__beaver_mult(a.x_r, a.r, s.x_r, s.r)
    a_scaled_val = mpc.arithmetic.__beaver_reconstruct(a_scaled_val)
    a_scaled_val = mpc.fp.trunc(a_scaled_val, NBIT_K, NBIT_K - NBIT_F)
    a_scaled = SecureValue(a_scaled_val)
    a_scaled.fp = True

    scaled_est = a_scaled * a_scaled * 2 - a_scaled * 4 + 2.9581

    # TODO: #67 Have Sequre calculate truncation sizes. Below code should be just: h = scaled_est * s_sqrt
    if not scaled_est.is_partitioned(): scaled_est.set_partitions(mpc.arithmetic.__beaver_partition(scaled_est.share))
    if not s_sqrt.is_partitioned(): s_sqrt.set_partitions(mpc.arithmetic.__beaver_partition(s_sqrt.share))
    h_val = mpc.arithmetic.__beaver_mult(scaled_est.x_r, scaled_est.r, s_sqrt.x_r, s_sqrt.r)
    h_val = mpc.arithmetic.__beaver_reconstruct(h_val)
    h_val = mpc.fp.trunc(h_val, NBIT_K // 2 + NBIT_F + 2, (NBIT_K - NBIT_F) // 2 + 1)
    h = SecureValue(h_val)
    h.fp = True

    g = h * a * 2
    for _ in range(niter):
        r = 1.5 - h * g
        # TODO: #16 Calculate h and g in parallel
        h = h * r
        g = g * r
    
    return g, h * 2
