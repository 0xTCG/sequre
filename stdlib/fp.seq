import math

from sequre import sequre_beaver

from ..utils.custom_types import SecureValue
from ..utils.param import NBIT_K, NBIT_F


def normalizer_even_exponent(mpc, a):
    # TODO: #66 Port fp.__normalizer_even_exp to Sequre
    s_val, s_sqrt_val = mpc.fp.__normalizer_even_exp(a.share, mpc.primes[1])
    s = SecureValue(s_val)
    s_sqrt = SecureValue(s_sqrt_val)
    s.fp = True
    s_sqrt.fp = True
    return s, s_sqrt


@sequre_beaver
def fp_sqrt(mpc, a):
    niter = int(2 * math.ceil(math.log2((NBIT_K) / 3.5)))
    s, s_sqrt = normalizer_even_exponent(mpc, a)

    a_scaled = a * s
    scaled_est = a_scaled * a_scaled * 2 - a_scaled * 4 + 2.9581

    # TODO: #67 Have Sequre calculate truncation sizes. Below code should be just: h = scaled_est * s_sqrt
    scaled_est_x_r, scaled_est_r = mpc.arithmetic.__beaver_partition(scaled_est.share)
    s_sqrt_x_r, s_sqrt_r = mpc.arithmetic.__beaver_partition(s_sqrt.share)
    h_val = mpc.arithmetic.__beaver_mult(scaled_est_x_r, scaled_est_r, s_sqrt_x_r, s_sqrt_r)
    h_val = mpc.arithmetic.__beaver_reconstruct(h_val)
    h_val = mpc.fp.trunc(h_val, NBIT_K // 2 + NBIT_F + 2, (NBIT_K - NBIT_F) // 2 + 1)
    h = SecureValue(h_val)
    h.fp = True

    g = h * a * 2
    for _ in range(niter):
        r = 1.5 - h * g
        # TODO: #16 Calculate h and g in parallel
        h = h * r
        g = g * r
    
    return g, h * 2
