"""
Ported from https://github.com/tuneinsight/lattigo/tree/master/ckks
"""
import math
from numpy.create import array

from pickler import pickle, unpickle

from ..types.builtin import u64xN, f64xN
from ..utils.utils import zeros_vec
from ..utils.constants import NUM_THREADS

import rlwe, ring, ringqp, utils

from common import BIG_INT_LEN, big_uint, big_int, GALOIS_GEN, MIN_LOG_SLOTS, biguint_mod


class Parameters(Static[rlwe.Parameters]):
    log_slots: int
    default_scale: float

    def __init__(self, log_slots, default_scale):
        self.log_slots = log_slots
        self.default_scale = default_scale
    
    def __repr__(self) -> str:
        return f"""\tCKKSParams:
                \tLog slots: {self.log_slots}
                \tDefault scale: {self.default_scale}
                \t{self.get_rlwe_params()}
        """
    
    def get_rlwe_params(self) -> rlwe.Parameters:
        return rlwe.Parameters(
            self.logn,
            self.qi,
            self.pi,
            self.pow2_base,
            self.sigma,
            self.h,
            self.ring_q,
            self.ring_p,
            self.ring_type)

    def set_rlwe_params(self, rlwe_params):
        self.logn = rlwe_params.logn
        self.qi =  rlwe_params.qi
        self.pi = rlwe_params.pi
        self.pow2_base = rlwe_params.pow2_base
        self.sigma = rlwe_params.sigma
        self.h = rlwe_params.h
        self.ring_q = rlwe_params.ring_q
        self.ring_p = rlwe_params.ring_p
        self.ring_type = rlwe_params.ring_type
    
    def from_rlwe_params(self, rlwe_params) -> Parameters:
        self.set_rlwe_params(rlwe_params)
        return self
    
    # Returns the maximum ciphertext level
    def max_level(self) -> int:
        return self.q_count() - 1
    
    # Returns number of available plaintext slots
    def slots(self):
        return 1 << self.log_slots
    
    # Returns the log of the maximum number of slots enabled by the parameters
    def max_log_slots(self):
        if self.ring_type == ring.StandardRing:
            return self.logn - 1
        elif self.ring_type == ring.ConjugateInvariantRing:
            return self.logn
        else: raise ValueError("Invalid ring type")
    
    # Returns the theoretical maximum of plaintext slots allowed by the ring degree
    def max_slots(self):
        if self.ring_type == ring.StandardRing: return self.n() >> 1
        elif self.ring_type == ring.ConjugateInvariantRing: return self.n()
        else: raise ValueError("invalid ring type")
    
    # Returns the size of the modulus q in bits at a specific level
    def logq_lvl(self, level: int) -> int:
        return int(self.q_lvl(level).bitlen())
    
    # Returns the product of the moduli at the given level as a big.Int
    def q_lvl(self, level: int) -> big_uint:
        tmp = big_uint(1)
        for qi in self.q().slice_reference(0, level + 1): tmp *= qi.ext_to_bigint()
        return tmp


class ParametersLiteral:
    logn: int
    q: list[u64]
    p: list[u64]
    logq: list[int]
    logp: list[int]
    pow2_base: int
    sigma: float
    h: int
    ring_type: int
    log_slots: int
    default_scale: float

    def __init__(self: ParametersLiteral, logn: int, log_slots: int, default_scale: float):
        self.logn = logn
        self.log_slots = log_slots
        self.default_scale = default_scale
        self.q = list[u64]()
        self.p = list[u64]()
        self.logq = list[int]()
        self.logp = list[int]()

    def __init__(self: ParametersLiteral, logn: int, logq: list[int], logp: list[int], log_slots: int, default_scale: float):
        self.__init__(logn, log_slots, default_scale)
        self.logq = logq
        self.logp = logp
    
    def __init__(self, logn: int, q: list[u64], p: list[u64], log_slots: int, default_scale: float):
        self.__init__(logn, log_slots, default_scale)
        self.q = q
        self.p = p
    
    def __init__(self, logn: int, q: list[u64], p: list[u64], ring_type: int, log_slots: int, default_scale: float):
        self.__init__(logn, q, p, log_slots, default_scale)
        self.ring_type = ring_type

    def rlwe_parameters(self):
        return rlwe.ParametersLiteral(
            logn=self.logn,
            q=self.q,
            p=self.p,
            logq=self.logq,
            logp=self.logp,
            pow2_base=self.pow2_base,
            sigma=self.sigma,
            h=self.h,
            ring_type=self.ring_type)


def new_parameters(rlwe_params, log_slots, default_scale):
    if not rlwe_params: raise ValueError("provided RLWE parameters are invalid")

    max_log_slots = int(rlwe_params.ring_q.nth_root.bitlen()) - 3

    if log_slots > max_log_slots or log_slots < MIN_LOG_SLOTS:
        raise ValueError(f"logSlot={log_slots} is larger than the logn-1={max_log_slots} or smaller than {MIN_LOG_SLOTS}")

    return Parameters(log_slots, default_scale).from_rlwe_params(rlwe_params)


def new_parameters_from_literal(pl):
    rlwe_params = rlwe.new_parameters_from_literal(pl.rlwe_parameters())

    if pl.log_slots == 0:
        if pl.ring_type == ring.StandardRing: pl.log_slots = pl.logn - 1
        elif pl.ring_type == ring.ConjugateInvariantRing: pl.log_slots = pl.logn

    return new_parameters(rlwe_params, pl.log_slots, pl.default_scale)


# PN12QP109 is a default parameter set for logN=12 and logQP=109
PN12QP109 = ParametersLiteral(
    logn=12,
    q=[  # 37 + 32
        u64(0x200000e001),
        u64(0x100006001)],
    p=[  # 38
        u64(0x3ffffea001)],
    log_slots=11,
    default_scale=float(1 << 32))


# PN13QP218 is a default parameter set for logN=13 and logQP=218
PN13QP218 = ParametersLiteral(
    logn=13,
    q=[  # 33 + 5 x 30
        u64(0x1fffec001),
        u64(0x3fff4001),
        u64(0x3ffe8001),
        u64(0x40020001),
        u64(0x40038001),
        u64(0x3ffc0001)],
    p=[  # 35
        u64(0x800004001)],
    log_slots=12,
    default_scale=float(1 << 30))


# PN14QP438 is a default parameter set for logN=14 and logQP=438
PN14QP438 = ParametersLiteral(
    logn=14,
    q=[  # 45 + 9 x 34
        u64(0x200000008001), u64(0x400018001),
        u64(0x3fffd0001), u64(0x400060001),
        u64(0x400068001), u64(0x3fff90001),
        u64(0x400080001), u64(0x4000a8001),
        u64(0x400108001), u64(0x3ffeb8001)],
    p=[u64(0x7fffffd8001), u64(0x7fffffc8001)],  # 43, 43
    log_slots=13,
    default_scale=float(1 << 34))


# PN15QP880 is a default parameter set for logN=15 and logQP=880
PN15QP880 = ParametersLiteral(
    logn=15,
    q=[  # 50 + 17 x 40
        u64(0x4000000120001), u64(0x10000140001), u64(0xffffe80001),
        u64(0x10000290001), u64(0xffffc40001), u64(0x100003e0001),
        u64(0x10000470001), u64(0x100004b0001), u64(0xffffb20001),
        u64(0x10000500001), u64(0x10000650001), u64(0xffff940001),
        u64(0xffff8a0001), u64(0xffff820001), u64(0xffff780001),
        u64(0x10000890001), u64(0xffff750001), u64(0x10000960001)],
    p=[u64(0x40000001b0001), u64(0x3ffffffdf0001), u64(0x4000000270001)],  # 50, 50, 50
    log_slots=14,
    default_scale=float(1 << 40))


# PN16QP1761 is a default parameter set for logN=16 and logQP = 1761
PN16QP1761 = ParametersLiteral(
    logn=16,
    q=[  # 55 + 33 x 45
        u64(0x80000000080001), u64(0x2000000a0001), u64(0x2000000e0001), u64(0x1fffffc20001),
        u64(0x200000440001), u64(0x200000500001), u64(0x200000620001), u64(0x1fffff980001),
        u64(0x2000006a0001), u64(0x1fffff7e0001), u64(0x200000860001), u64(0x200000a60001),
        u64(0x200000aa0001), u64(0x200000b20001), u64(0x200000c80001), u64(0x1fffff360001),
        u64(0x200000e20001), u64(0x1fffff060001), u64(0x200000fe0001), u64(0x1ffffede0001),
        u64(0x1ffffeca0001), u64(0x1ffffeb40001), u64(0x200001520001), u64(0x1ffffe760001),
        u64(0x2000019a0001), u64(0x1ffffe640001), u64(0x200001a00001), u64(0x1ffffe520001),
        u64(0x200001e80001), u64(0x1ffffe0c0001), u64(0x1ffffdee0001), u64(0x200002480001),
        u64(0x1ffffdb60001), u64(0x200002560001)],
    p=[u64(0x80000000440001), u64(0x7fffffffba0001), u64(0x80000000500001), u64(0x7fffffffaa0001)],  # 4 x 55
    log_slots=15,
    default_scale=float(1 << 45))


# PN12QP109CI is a default parameter set for logN=12 and logQP=109
PN12QP109CI = ParametersLiteral(
    logn=12,
    q=[u64(0x1ffffe0001), u64(0x100014001)],  # 37 + 32
    p=[u64(0x4000038001)],  # 38
    ring_type=ring.ConjugateInvariantRing,
    log_slots=12,
    default_scale=float(1 << 32))


# PN13QP218CI is a default parameter set for logN=13 and logQP=218
PN13QP218CI = ParametersLiteral(
    logn=13,
    q=[  # 33 + 5 x 30
        u64(0x200038001),
        u64(0x3ffe8001),
        u64(0x40020001),
        u64(0x40038001),
        u64(0x3ffc0001),
        u64(0x40080001)],
    p=[u64(0x800008001)],  # 35
    ring_type=ring.ConjugateInvariantRing,
    log_slots=13,
    default_scale=float(1 << 30))


# PN14QP438CI is a default parameter set for logN=14 and logQP=438
PN14QP438CI = ParametersLiteral(
    logn=14,
    q=[  # 45 + 9*34
        u64(0x2000000a0001), u64(0x3fffd0001),
        u64(0x400060001), u64(0x3fff90001),
        u64(0x400080001), u64(0x400180001),
        u64(0x3ffd20001), u64(0x400300001),
        u64(0x400360001), u64(0x4003e0001)],
    p=[u64(0x80000050001), u64(0x7ffffdb0001)],  # 43, 43
    ring_type=ring.ConjugateInvariantRing,
    log_slots=14,
    default_scale=float(1 << 34))


class KeyGenerator(Static[rlwe.KeyGenerator]):
    ckks_params: Parameters

    def __init__(self, rlwe_keygen, ckks_params):
        self.sk = rlwe_keygen.sk
        self.uniform_sampler = rlwe_keygen.uniform_sampler
        self.params = rlwe_keygen.params
        self.ckks_params = ckks_params
        self.prng = rlwe_keygen.prng
        self.gaussian_sampler = rlwe_keygen.gaussian_sampler
        self.ternary_sampler = rlwe_keygen.ternary_sampler
        self.basisextender = rlwe_keygen.basisextender
        self.buff_q = rlwe_keygen.buff_q
        self.buff_p = rlwe_keygen.buff_p
        self.buff_qp = rlwe_keygen.buff_qp
    
    def __repr__(self) -> str:
        return f"""\tCKKSKeyGen:
                \t{self.ckks_params}
                \t{self.get_rlwe_keygen()}
        """
    
    def get_rlwe_keygen(self):
        return rlwe.KeyGenerator(self.get_rlwe_skencryptor())


# Plaintext is is a Element with only one Poly.
class Plaintext(Static[rlwe.Plaintext]):
    scale: float
    _nil_ideal: bool

    def __init__(self, poly: ring.Poly, scale: float, _nil_ideal: bool):
        self.value = poly
        self.scale = scale
        self._nil_ideal = _nil_ideal
    
    def __init__(self, poly: ring.Poly, scale: float):
        self.value = poly
        self.scale = scale
    
    def __init__(self, plaintext: rlwe.Plaintext, scale: float):
        self.value = plaintext.value
        self.scale = scale

    def __init__(self, plaintext: Plaintext, scale: float):
        self.value = plaintext.value
        self.scale = scale
    
    def __repr__(self):
        return f"""\tCKKSPlaintext:
                \tNil-ideal: {self._nil_ideal}
                \tScale: {self.scale}
                \t{self.get_rlwe_plaintext()}
        """
    
    def __pickle__(self, jar: Jar, pasteurized: bool):
        pickle(self._nil_ideal, jar, pasteurized)
        if not pasteurized: jar += self._nil_ideal._pickle_size()
        pickle(self.scale, jar, pasteurized)
        if not pasteurized: jar += self.scale._pickle_size()
        pickle(self.value, jar, pasteurized)
    
    def __unpickle__(jar: Jar, pasteurized: bool) -> Plaintext:
        _nil_ideal = unpickle(jar, pasteurized, bool)
        if not pasteurized: jar += _nil_ideal._pickle_size()
        scale = unpickle(jar, pasteurized, float)
        if not pasteurized: jar += scale._pickle_size()
        value = unpickle(jar, pasteurized, ring.Poly)

        return Plaintext(value, scale, _nil_ideal)

    def get_rlwe_plaintext(self):
        return rlwe.Plaintext(value=self.value)
    
    def copy(self):
        return Plaintext(self.value.copy(), self.scale, self._nil_ideal)
    
    def _pickle_size(self) -> int:
        return self._nil_ideal._pickle_size() + self.scale._pickle_size() + self.value._pickle_size()


# Ciphertext is *ring.Poly array representing a polynomial of degree > 0 with coefficients in R_Q.
class Ciphertext(Static[rlwe.Ciphertext]):
    scale: float
    _nil_ideal: bool

    def __init__(self, poly: ring.Poly, scale: float, _nil_ideal: bool):
        self.value = poly
        self.scale = scale
        self._nil_ideal = _nil_ideal
    
    def __init__(self, poly: ring.Poly, scale: float):
        self.value = poly
        self.scale = scale
    
    def __init__(self, ciphertext: rlwe.Ciphertext, scale: float):
        self.value = ciphertext.value
        self.scale = scale

    def __init__(self, ciphertext: Ciphertext, scale: float):
        self.value = ciphertext.value
        self.scale = scale
    
    def __repr__(self):
        return f"""\tCKKSCiphertext:
                \tNil-ideal: {self._nil_ideal}
                \tScale: {self.scale}
                \t{self.get_rlwe_ciphertext()}
        """
    
    def __bool__(self):
        return super().__bool__() or self._nil_ideal

    def __eq__(self, other: Ciphertext) -> bool:
        if self._nil_ideal != other._nil_ideal: return False
        if self.scale != other.scale: return False
        return self.value == other.value
    
    def __ne__(self, other: Ciphertext) -> bool:
        return not self == other
    
    def __pickle__(self, jar: Jar, pasteurized: bool):
        pickle(self._nil_ideal, jar, pasteurized)
        if not pasteurized: jar += self._nil_ideal._pickle_size()
        pickle(self.scale, jar, pasteurized)
        if not pasteurized: jar += self.scale._pickle_size()
        pickle(self.value, jar, pasteurized)
    
    def __unpickle__(jar: Jar, pasteurized: bool) -> Ciphertext:
        _nil_ideal = unpickle(jar, pasteurized, bool)
        if not pasteurized: jar += _nil_ideal._pickle_size()
        scale = unpickle(jar, pasteurized, float)
        if not pasteurized: jar += scale._pickle_size()
        value = unpickle(jar, pasteurized, list[ring.Poly])

        return Ciphertext(value, scale, _nil_ideal)

    def _pickle_size(self) -> int:
        return self._nil_ideal._pickle_size() + self.scale._pickle_size() + self.value._pickle_size()

    def get_rlwe_ciphertext(self):
        return rlwe.Ciphertext(value=self.value)
    
    # SetScale sets the scaling factor of the ciphertext
    def set_scale(self, scale: float):
        self.scale = scale
    
    def set(self, other):
        if isinstance(other, Plaintext):
            other_cipher = other.ciphertext()
        elif isinstance(other, Ciphertext):
            other_cipher = other
        else:
            compile_error("CKKS.Ciphertext.set: invalid input type")
        
        self.value = other_cipher.value
        self.scale = other_cipher.scale
        self._nil_ideal = other_cipher._nil_ideal
    
    def plaintext(self) -> Plaintext:
        if self._nil_ideal:
            return Plaintext.nil_ideal()
        return Plaintext(
            plaintext=rlwe.Plaintext(value=self.value[0]),
            scale=self.scale)
    
    def ciphertext(self) -> Ciphertext:
        return self
    
    def copy(self) -> Ciphertext:
        return Ciphertext(self.value.copy(), self.scale, self._nil_ideal)

    def requires_bootstrap(self, min_level: int):
        if self._nil_ideal: return False
        return self.level() <= min_level
    
    def to_nil_ideal(self):
        self.value.clear()
        self.scale = 0.0
        self._nil_ideal = True


NIL_IDEAL_PLAINTEXT = Plaintext(_nil_ideal=True)
NIL_IDEAL_CIPHERTEXT = Ciphertext(_nil_ideal=True)


# Extending Plaintext to add Ciphertext related methods.
@extend
class Plaintext:
    def ciphertext(self) -> Ciphertext:
        return Ciphertext(scale=self.scale, value=[self.value], _nil_ideal=self._nil_ideal)
    
    @staticmethod
    def nil_ideal() -> Plaintext:
        return NIL_IDEAL_PLAINTEXT


@extend
class Ciphertext:
    @staticmethod
    def nil_ideal() -> Ciphertext:
        return NIL_IDEAL_CIPHERTEXT


# new_ciphertext creates a new Ciphertext parameterized by degree, level and scale.
def new_ciphertext(params: Parameters, degree: int, level: int, scale: float) -> Ciphertext:
	ciphertext = Ciphertext(
        ciphertext=rlwe.new_ciphertext(params.get_rlwe_params(), degree, level),
        scale=scale)
	for pol in ciphertext.value: pol.is_ntt = True
	return ciphertext


class PkEncryptor(Static[rlwe.PkEncryptor]):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buff_q = rlwe_enc.buff_q
        self.buff_p = rlwe_enc.buff_p
        self.buff_qp = rlwe_enc.buff_qp

        self.pk = rlwe_enc.pk

        self.ckks_params = params
    
    # EncryptNew encrypts the input plaintext returns the result as a newly allocated ciphertext.
    # The level of the output ciphertext is min(plaintext.level(), ciphertext.level()).
    def encrypt_new(self, plaintext: Plaintext) -> Ciphertext:
        ciphertext = new_ciphertext(self.ckks_params, 1, plaintext.level(), plaintext.scale)
        self._mm_encrypt(plaintext.get_rlwe_plaintext(), ciphertext.get_rlwe_ciphertext())
        return ciphertext


class SkEncryptor(Static[rlwe.SkEncryptor]):
    ckks_params: Parameters

    def __init__(self, rlwe_enc, params):
        self.params = rlwe_enc.params
        self.prng = rlwe_enc.prng
        self.gaussian_sampler = rlwe_enc.gaussian_sampler
        self.ternary_sampler = rlwe_enc.ternary_sampler
        self.basisextender = rlwe_enc.basisextender
        self.buff_q = rlwe_enc.buff_q
        self.buff_p = rlwe_enc.buff_p
        self.buff_qp = rlwe_enc.buff_qp

        self.sk = rlwe_enc.sk
        self.uniform_sampler = rlwe_enc.uniform_sampler

        self.ckks_params = params
    
    # encrypt_new encrypts the input plaintext returns the result as a newly allocated ciphertext.
    # The level of the output ciphertext is min(plaintext.level(), ciphertext.level()).
    def encrypt_new(self, plaintext: Plaintext) -> Ciphertext:
        ciphertext = new_ciphertext(self.ckks_params, 1, plaintext.level(), plaintext.scale)
        rlwe_ct = ciphertext.get_rlwe_ciphertext()
        self._mm_encrypt(plaintext.get_rlwe_plaintext(), rlwe_ct)
        return ciphertext


# NewPlaintext creates a new Plaintext of level level and scale scale.
def new_plaintext(params: Parameters, level: int, scale: float) -> Plaintext:
	pt = Plaintext(
        plaintext=rlwe.new_plaintext(params.get_rlwe_params(), level),
        scale=scale)
	pt.value.is_ntt = True
	return pt


class Decryptor(Static[rlwe.Decryptor]):
    params: Parameters

    def __init__(self, rlwe_dec, params):
        self.ring_q = rlwe_dec.ring_q
        self.buff = rlwe_dec.buff
        self.sk = rlwe_dec.sk

        self.params = params
    
    def __repr__(self):
        return f"""\tCKKSDecryptor:
                \t{self.params}
                \t{self.get_rlwe_decryptor()}
        """
    
    def get_rlwe_decryptor(self):
        return rlwe.Decryptor(self.ring_q, self.buff, self.sk)
    
    # decrypt decrypts the ciphertext and write the result in ptOut.
    def decrypt_new(self, ciphertext: Ciphertext) -> Plaintext:
        pt = new_plaintext(self.params, ciphertext.level(), ciphertext.scale)
        self._mm_decrypt(ciphertext.get_rlwe_ciphertext(), pt.get_rlwe_plaintext())
        return pt


# encoder is a struct storing the necessary parameters to encode a slice of complex number on a Plaintext.
class Encoder:
    params: Parameters
    bigint_chain: list[big_uint]
    bigint_coeffs: list[big_uint]
    q_half: big_uint
    buff: ring.Poly
    m: int
    rot_group: list[int]
    gaussian_sampler: ring.GaussianSampler


# NewKeyGenerator creates a rlwe.KeyGenerator instance from the CKKS parameters.
def new_key_generator(params):
    return KeyGenerator(rlwe.new_key_generator(params.get_rlwe_params()), params)


# NewSecretKey returns an allocated CKKS secret key with zero values.
def new_secret_key(params: Parameters) -> rlwe.SecretKey:
	return rlwe.new_secret_key(params.get_rlwe_params())


# NewPublicKey returns an allocated CKKS public with zero values.
def new_public_key(params: Parameters) -> rlwe.PublicKey:
	return rlwe.new_public_key(params.get_rlwe_params())


# NewSwitchingKey returns an allocated CKKS public switching key with zero values.
def new_switching_key(params: Parameters) -> rlwe.SwitchingKey:
	return rlwe.new_switching_key(params.get_rlwe_params(), params.q_count() - 1, params.p_count() - 1)


# NewRelinearizationKey returns an allocated CKKS public relinearization key with zero value.
def new_relinearization_key(params: Parameters) -> rlwe.RelinearizationKey:
	return rlwe.new_relin_key(params.get_rlwe_params(), 1)


# NewEncryptor instantiates a new Encryptor for the CKKS scheme. The key argument can
# be *rlwe.PublicKey, *rlwe.SecretKey or nil.
def new_encryptor(params: Parameters, key):
    if isinstance(key, rlwe.PublicKey):
        return PkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    elif isinstance(key, rlwe.SecretKey):
        return SkEncryptor(rlwe.new_encryptor(params.get_rlwe_params(), key), params)
    else:
	    compile_error("cannot NewEncryptor: key must be either *rlwe.PublicKey or *rlwe.SecretKey")


# NewDecryptor instantiates a Decryptor for the CKKS scheme.
def new_decryptor(params: Parameters, sk: rlwe.SecretKey) -> Decryptor:
	return Decryptor(rlwe.new_decryptor(params.get_rlwe_params(), sk), params)


def gen_bigint_chain(q: list[u64]) -> list[big_uint]:
    num_bits_total = 1
    for m in q: num_bits_total += int(m.bitlen())
    assert num_bits_total <= BIG_INT_LEN, (
        f"Moduli product too large for the bigint in use. Increase the bigint size."
        f" Current bigint size: {BIG_INT_LEN}. Required size: {num_bits_total}")

    bigint_chain = list[big_uint](len(q))
    bigint_chain.append(q[0].ext_to_bigint())
	
    for i in range(1, len(q)):
        bigint_chain.append(q[i].ext_to_bigint())
        bigint_chain[i] *= bigint_chain[i-1]
	
    return bigint_chain


def new_encoder(params: Parameters) -> Encoder:
	m = int(params.ring_q.nth_root)

	rot_group = list[int](m >> 1)
	five_pows = 1
	for _ in range(m >> 2):
		rot_group.append(five_pows) 
		five_pows *= GALOIS_GEN
		five_pows &= (m - 1)

	gaussian_sampler = ring.new_gaussian_sampler(utils.new_prng(), params.ring_q, params.sigma, int(6 * params.sigma))

	return Encoder(
		params=params,
		bigint_chain=gen_bigint_chain(params.q()),
		bigint_coeffs=zeros_vec(m >> 1, TP=big_uint),
		q_half=big_uint(0),
		buff=params.ring_q.new_poly(),
		m=m,
		rot_group=rot_group,
		gaussian_sampler=gaussian_sampler)


# SliceBitReverseInPlaceComplex128 applies an in-place bit-reverse permuation on the input slice.
def slice_bit_reverse_in_place_complex128(slice: list[complex], n: int):
    j = 0

    for i in range(1, n):
        bit = n >> 1

        while j >= bit:
            j -= bit
            bit >>= 1

        j += bit

        if i < j: slice[i], slice[j] = slice[j], slice[i]


# SpecialiFFTVec performs the CKKS special inverse FFT transform in place.
def special_ifft_vec(values: list[complex], n: int, m: int, rot_group: list[int], roots: list[complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                j, k = j + 1, k + 1

    for i in range(n):
        values[i] /= complex(float(n), 0)

    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTVec performs the CKKS special FFT transform in place.
def special_fft_vec(values: list[complex], n: int, m: int, rot_group: list[int], roots: list[complex]):
    slice_bit_reverse_in_place_complex128(values, n)
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1
        
        for i in range(0, n, len_):
            j, k = 0, i
            while j < lenh:
                values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]

                j, k = j + 1, k + 1


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[complex], scale_val: complex):
	for i in range(len(values)): values[i] /= scale_val


# SpecialiFFTUL8Vec performs the CKKS special inverse FFT transform in place with unrolled loops of size 8.
def special_ifft_ul8_vec(values: list[complex], n: int, m: int, rot_group: list[int], roots: list[complex]):
    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(logn, 0, -1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k], values[k + lenh] = values[k] + values[k + lenh], (values[k] - values[k + lenh]) * roots[(lenq - (rot_group[j] & mask)) << log_gap]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], (values[k + 1] - values[k + lenh + 1]) * roots[(lenq - (rot_group[j + 1] & mask)) << log_gap]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], (values[k + 2] - values[k + lenh + 2]) * roots[(lenq - (rot_group[j + 2] & mask)) << log_gap]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], (values[k + 3] - values[k + lenh + 3]) * roots[(lenq - (rot_group[j + 3] & mask)) << log_gap]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], (values[k + 4] - values[k + lenh + 4]) * roots[(lenq - (rot_group[j + 4] & mask)) << log_gap]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], (values[k + 5] - values[k + lenh + 5]) * roots[(lenq - (rot_group[j + 5] & mask)) << log_gap]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], (values[k + 6] - values[k + lenh + 6]) * roots[(lenq - (rot_group[j + 6] & mask)) << log_gap]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], (values[k + 7] - values[k + lenh + 7]) * roots[(lenq - (rot_group[j + 7] & mask)) << log_gap]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]
            psi4 = roots[(lenq - (rot_group[4] & mask)) << log_gap]
            psi5 = roots[(lenq - (rot_group[5] & mask)) << log_gap]
            psi6 = roots[(lenq - (rot_group[6] & mask)) << log_gap]
            psi7 = roots[(lenq - (rot_group[7] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 8] = values[i] + values[i + 8], (values[i] - values[i + 8]) * psi0
                values[i + 1], values[i + 9] = values[i + 1] + values[i + 9], (values[i + 1] - values[i + 9]) * psi1
                values[i + 2], values[i + 10] = values[i + 2] + values[i + 10], (values[i + 2] - values[i + 10]) * psi2
                values[i + 3], values[i + 11] = values[i + 3] + values[i + 11], (values[i + 3] - values[i + 11]) * psi3
                values[i + 4], values[i + 12] = values[i + 4] + values[i + 12], (values[i + 4] - values[i + 12]) * psi4
                values[i + 5], values[i + 13] = values[i + 5] + values[i + 13], (values[i + 5] - values[i + 13]) * psi5
                values[i + 6], values[i + 14] = values[i + 6] + values[i + 14], (values[i + 6] - values[i + 14]) * psi6
                values[i + 7], values[i + 15] = values[i + 7] + values[i + 15], (values[i + 7] - values[i + 15]) * psi7

        elif lenh == 4:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]
            psi2 = roots[(lenq - (rot_group[2] & mask)) << log_gap]
            psi3 = roots[(lenq - (rot_group[3] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 4] = values[i] + values[i + 4], (values[i] - values[i + 4]) * psi0
                values[i + 1], values[i + 5] = values[i + 1] + values[i + 5], (values[i + 1] - values[i + 5]) * psi1
                values[i + 2], values[i + 6] = values[i + 2] + values[i + 6], (values[i + 2] - values[i + 6]) * psi2
                values[i + 3], values[i + 7] = values[i + 3] + values[i + 7], (values[i + 3] - values[i + 7]) * psi3
                values[i + 8], values[i + 12] = values[i + 8] + values[i + 12], (values[i + 8] - values[i + 12]) * psi0
                values[i + 9], values[i + 13] = values[i + 9] + values[i + 13], (values[i + 9] - values[i + 13]) * psi1
                values[i + 10], values[i + 14] = values[i + 10] + values[i + 14], (values[i + 10] - values[i + 14]) * psi2
                values[i + 11], values[i + 15] = values[i + 11] + values[i + 15], (values[i + 11] - values[i + 15]) * psi3
        elif lenh == 2:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]
            psi1 = roots[(lenq - (rot_group[1] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 2] = values[i] + values[i + 2], (values[i] - values[i + 2]) * psi0
                values[i + 1], values[i + 3] = values[i + 1] + values[i + 3], (values[i + 1] - values[i + 3]) * psi1
                values[i + 4], values[i + 6] = values[i + 4] + values[i + 6], (values[i + 4] - values[i + 6]) * psi0
                values[i + 5], values[i + 7] = values[i + 5] + values[i + 7], (values[i + 5] - values[i + 7]) * psi1
                values[i + 8], values[i + 10] = values[i + 8] + values[i + 10], (values[i + 8] - values[i + 10]) * psi0
                values[i + 9], values[i + 11] = values[i + 9] + values[i + 11], (values[i + 9] - values[i + 11]) * psi1
                values[i + 12], values[i + 14] = values[i + 12] + values[i + 14], (values[i + 12] - values[i + 14]) * psi0
                values[i + 13], values[i + 15] = values[i + 13] + values[i + 15], (values[i + 13] - values[i + 15]) * psi1
        elif lenh == 1:
            psi0 = roots[(lenq - (rot_group[0] & mask)) << log_gap]

            for i in range(0, n, 16):
                values[i], values[i + 1] = values[i] + values[i + 1], (values[i] - values[i + 1]) * psi0
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], (values[i + 2] - values[i + 3]) * psi0
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], (values[i + 4] - values[i + 5]) * psi0
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], (values[i + 6] - values[i + 7]) * psi0
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], (values[i + 8] - values[i + 9]) * psi0
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], (values[i + 10] - values[i + 11]) * psi0
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], (values[i + 12] - values[i + 13]) * psi0
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], (values[i + 14] - values[i + 15]) * psi0

    divide_complex128_slice_vec(values, complex(float(n), 0))
    slice_bit_reverse_in_place_complex128(values, n)


# SpecialFFTUL8Vec performs the CKKS special FFT transform in place with unrolled loops of size 8.
def special_fft_ul8_vec(values: list[complex], n: int, m: int, rot_group: list[int], roots: list[complex]):
    slice_bit_reverse_in_place_complex128(values, n)

    logn = int(n.bitlen()) - 1
    logm = int(m.bitlen()) - 1

    for log_len in range(1, logn + 1):
        len_ = 1 << log_len
        lenh = len_ >> 1
        lenq = len_ << 2
        log_gap = logm - 2 - log_len
        mask = lenq - 1

        if lenh > 8:
            for i in range(0, n, len_):
                j, k = 0, i
                while j < lenh:
                    values[k + lenh] *= roots[(rot_group[j] & mask) << log_gap]
                    values[k + lenh + 1] *= roots[(rot_group[j + 1] & mask) << log_gap]
                    values[k + lenh + 2] *= roots[(rot_group[j + 2] & mask) << log_gap]
                    values[k + lenh + 3] *= roots[(rot_group[j + 3] & mask) << log_gap]
                    values[k + lenh + 4] *= roots[(rot_group[j + 4] & mask) << log_gap]
                    values[k + lenh + 5] *= roots[(rot_group[j + 5] & mask) << log_gap]
                    values[k + lenh + 6] *= roots[(rot_group[j + 6] & mask) << log_gap]
                    values[k + lenh + 7] *= roots[(rot_group[j + 7] & mask) << log_gap]

                    values[k], values[k + lenh] = values[k] + values[k + lenh], values[k] - values[k + lenh]
                    values[k + 1], values[k + lenh + 1] = values[k + 1] + values[k + lenh + 1], values[k + 1] - values[k + lenh + 1]
                    values[k + 2], values[k + lenh + 2] = values[k + 2] + values[k + lenh + 2], values[k + 2] - values[k + lenh + 2]
                    values[k + 3], values[k + lenh + 3] = values[k + 3] + values[k + lenh + 3], values[k + 3] - values[k + lenh + 3]
                    values[k + 4], values[k + lenh + 4] = values[k + 4] + values[k + lenh + 4], values[k + 4] - values[k + lenh + 4]
                    values[k + 5], values[k + lenh + 5] = values[k + 5] + values[k + lenh + 5], values[k + 5] - values[k + lenh + 5]
                    values[k + 6], values[k + lenh + 6] = values[k + 6] + values[k + lenh + 6], values[k + 6] - values[k + lenh + 6]
                    values[k + 7], values[k + lenh + 7] = values[k + 7] + values[k + lenh + 7], values[k + 7] - values[k + lenh + 7]

                    j, k = j + 8, k + 8
        elif lenh == 8:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]
            psi4 = roots[(rot_group[4] & mask) << log_gap]
            psi5 = roots[(rot_group[5] & mask) << log_gap]
            psi6 = roots[(rot_group[6] & mask) << log_gap]
            psi7 = roots[(rot_group[7] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 8] *= psi0
                values[i + 9] *= psi1
                values[i + 10] *= psi2
                values[i + 11] *= psi3
                values[i + 12] *= psi4
                values[i + 13] *= psi5
                values[i + 14] *= psi6
                values[i + 15] *= psi7

                values[i], values[i + 8] = values[i]+values[i + 8], values[i] - values[i + 8]
                values[i + 1], values[i + 9] = values[i + 1]+values[i + 9], values[i + 1] - values[i + 9]
                values[i + 2], values[i + 10] = values[i + 2]+values[i + 10], values[i + 2] - values[i + 10]
                values[i + 3], values[i + 11] = values[i + 3]+values[i + 11], values[i + 3] - values[i + 11]
                values[i + 4], values[i + 12] = values[i + 4]+values[i + 12], values[i + 4] - values[i + 12]
                values[i + 5], values[i + 13] = values[i + 5]+values[i + 13], values[i + 5] - values[i + 13]
                values[i + 6], values[i + 14] = values[i + 6]+values[i + 14], values[i + 6] - values[i + 14]
                values[i + 7], values[i + 15] = values[i + 7]+values[i + 15], values[i + 7] - values[i + 15]
        elif lenh == 4:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]
            psi2 = roots[(rot_group[2] & mask) << log_gap]
            psi3 = roots[(rot_group[3] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 4] *= psi0
                values[i + 5] *= psi1
                values[i + 6] *= psi2
                values[i + 7] *= psi3
                values[i + 12] *= psi0
                values[i + 13] *= psi1
                values[i + 14] *= psi2
                values[i + 15] *= psi3

                values[i], values[i + 4] = values[i]+values[i + 4], values[i] - values[i + 4]
                values[i + 1], values[i + 5] = values[i + 1]+values[i + 5], values[i + 1] - values[i + 5]
                values[i + 2], values[i + 6] = values[i + 2]+values[i + 6], values[i + 2] - values[i + 6]
                values[i + 3], values[i + 7] = values[i + 3]+values[i + 7], values[i + 3] - values[i + 7]
                values[i + 8], values[i + 12] = values[i + 8]+values[i + 12], values[i + 8] - values[i + 12]
                values[i + 9], values[i + 13] = values[i + 9]+values[i + 13], values[i + 9] - values[i + 13]
                values[i + 10], values[i + 14] = values[i + 10]+values[i + 14], values[i + 10] - values[i + 14]
                values[i + 11], values[i + 15] = values[i + 11]+values[i + 15], values[i + 11] - values[i + 15]
        elif lenh == 2:
            psi0 = roots[(rot_group[0] & mask) << log_gap]
            psi1 = roots[(rot_group[1] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 2] *= psi0
                values[i + 3] *= psi1
                values[i + 6] *= psi0
                values[i + 7] *= psi1
                values[i + 10] *= psi0
                values[i + 11] *= psi1
                values[i + 14] *= psi0
                values[i + 15] *= psi1

                values[i], values[i + 2] = values[i]+values[i + 2], values[i] - values[i + 2]
                values[i + 1], values[i + 3] = values[i + 1]+values[i + 3], values[i + 1] - values[i + 3]
                values[i + 4], values[i + 6] = values[i + 4]+values[i + 6], values[i + 4] - values[i + 6]
                values[i + 5], values[i + 7] = values[i + 5]+values[i + 7], values[i + 5] - values[i + 7]
                values[i + 8], values[i + 10] = values[i + 8]+values[i + 10], values[i + 8] - values[i + 10]
                values[i + 9], values[i + 11] = values[i + 9]+values[i + 11], values[i + 9] - values[i + 11]
                values[i + 12], values[i + 14] = values[i + 12]+values[i + 14], values[i + 12] - values[i + 14]
                values[i + 13], values[i + 15] = values[i + 13]+values[i + 15], values[i + 13] - values[i + 15]
        elif lenh == 1:
            psi0 = roots[(rot_group[0] & mask) << log_gap]

            for i in range(0, n, 16):
                values[i + 1] *= psi0
                values[i + 3] *= psi0
                values[i + 5] *= psi0
                values[i + 7] *= psi0
                values[i + 9] *= psi0
                values[i + 11] *= psi0
                values[i + 13] *= psi0
                values[i + 15] *= psi0

                values[i], values[i + 1] = values[i] + values[i + 1], values[i] - values[i + 1]
                values[i + 2], values[i + 3] = values[i + 2] + values[i + 3], values[i + 2] - values[i + 3]
                values[i + 4], values[i + 5] = values[i + 4] + values[i + 5], values[i + 4] - values[i + 5]
                values[i + 6], values[i + 7] = values[i + 6] + values[i + 7], values[i + 6] - values[i + 7]
                values[i + 8], values[i + 9] = values[i + 8] + values[i + 9], values[i + 8] - values[i + 9]
                values[i + 10], values[i + 11] = values[i + 10] + values[i + 11], values[i + 10] - values[i + 11]
                values[i + 12], values[i + 13] = values[i + 12] + values[i + 13], values[i + 12] - values[i + 13]
                values[i + 14], values[i + 15] = values[i + 14] + values[i + 15], values[i + 14] - values[i + 15]


def single_float_to_fixed_point_crt(level: int, i: int, value: float, scale: float, ring_q: ring.Ring, coeffs: list[list[u64]]):
    is_negative = False

    if value < 0:
        is_negative = True
        scale *= -1

    value *= scale
    moduli = ring_q.modulus

    if value > 1.8446744073709552e+19:
        # x_flo = big_float(value)
        # x_flo += big_float(0.5)
        # x_int = big_uint(x_flo)
        # for j, qi in enumerate(moduli.slice_reference(0, level + 1)):
        #     tmp = x_int % qi
        #     if is_negative: coeffs[j][i] = qi - tmp
        #     else: coeffs[j][i] = tmp
        raise NotImplementedError()
    else:
        bred_params = ring_q.bred_params

        c = u64(int(value + 0.5))
        if is_negative:
            # @par(num_threads=NUM_THREADS)
            for j, qi in enumerate(moduli.slice_reference(0, level + 1)):
                if c > qi: coeffs[j][i] = qi - ring.bred_add(c, qi, bred_params[j][0])
                else: coeffs[j][i] = qi - c
        else:
            # @par(num_threads=NUM_THREADS)
            for j, qi in enumerate(moduli.slice_reference(0, level + 1)):
                if c > u64(0x1fffffffffffffff): coeffs[j][i] = ring.bred_add(c, qi, bred_params[j][0])
                else: coeffs[j][i] = c


# NttAndMontgomeryLvl takes the polynomial polIn Z[Y] outside of the NTT domain to the polynomial Z[X] in the NTT domain where Y = X^(gap).
# This method is used to accelerate the NTT of polynomials that encode sparse plaintexts.
def _mm_ntt_and_montgomery_lvl(level: int, log_slots: int, ring_q: ring.Ring, montgomery: bool, pol: ring.Poly):
    if u64(1 << log_slots) == ring_q.nth_root >> u64(2):
        ring_q._mm_ntt_lvl(level, pol, pol)
        if montgomery: ring_q._mm_mform_lvl(level, pol, pol)
    else:
        # n = 0
        
        # if ring_q.type() == ring.StandardRing:
        #     n = 2 << log_slots
        # elif ring_q.type() == ring.ConjugateInvariantRing:
        #     n = 1 << log_slots
        #     # NTT = ring_NTTConjugateInvariant
        #     raise NotImplementedError()
        # else: raise ValueError("Invalid ring type")

        # gap = ring_q.n // n
        # for i in range(level + 1):
        #     _mm_coeffs = pol._mm_coeffs[i]

        #     # NTT in dimension n
        #     ring._mm_ntt(_mm_coeffs, _mm_coeffs, n, ring_q.ntt_psi[i], ring_q._mm_modulus[i], ring_q._mm_mred_params[i], ring_q._mm_bred_params[i][0])
        #     if montgomery: ring._mm_mform_vec(_mm_coeffs, _mm_coeffs, ring_q._mm_modulus[i], ring_q._mm_bred_params[i])

        #     coeffs = pol._buf_coeffs[i]
        #     # Maps NTT in dimension n to NTT in dimension n
        #     for j in range(n - 1, -1, -1):
        #         c = coeffs[j]
        #         for w in range(gap): coeffs[j * gap + w] = c
        #     pol._buf_coeffs[i] = coeffs
        raise NotImplementedError("Please tell code owners to implement this corner case.")
            

def complex_to_fixed_point_crt(values: list[complex], scale: float, ring_q: ring.Ring, is_ring_standard: bool, pol: ring.Poly):
    level = pol.level()
    slots = pol.n()

    for i, v in enumerate(values):
        single_float_to_fixed_point_crt(level, i, v.real, scale, ring_q, pol._buf_coeffs)

    if is_ring_standard:
        slots = len(values)
        for i, v in enumerate(values):
            single_float_to_fixed_point_crt(level, i + slots, v.imag, scale, ring_q, pol._buf_coeffs)


# DivideComplex128SliceVec divides the entries in values by scale_val in place.
def divide_complex128_slice_vec(values: list[complex], scale_val: complex):
	for i in range(len(values)): values[i] /= scale_val


def poly_to_complex_no_crt(coeffs: list[u64], values: list[complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring):
    slots = 1 << log_slots
    max_slots = int(ring_q.nth_root >> u64(2))
    gap = max_slots // slots
    q = ring_q.modulus[0]

    c = u64(0)
    i, idx = 0, 0
    while i < slots:
        c = coeffs[idx]
        if c >= q >> u64(1): values[i] = complex(-float(q - c), 0)
        else: values[i] = complex(float(c), 0)
        i, idx = i + 1, idx + gap

    if not isreal:
        i, idx = 0, max_slots
        while i < slots:
            c = coeffs[idx]
            if c >= q >> u64(1): values[i] += complex(0, -float(q - c))
            else: values[i] += complex(0, float(c))
            i, idx = i + 1, idx + gap

    divide_complex128_slice_vec(values, complex(scale, 0))


# Divides x by n^2, returns a float
def scale_down(coeff: big_int, n: float) -> float:
    return coeff.to_float() / n


def poly_to_complex_crt(level: int, coeffs: list[list[u64]], bigint_coeffs: list[big_uint], values: list[complex], scale: float, log_slots: int, isreal: bool, ring_q: ring.Ring, q: big_uint):
    max_slots = int(ring_q.nth_root >> u64(2))
    slots = 1 << log_slots
    gap = max_slots // slots

    ring_q.poly_to_bigint(level, coeffs, gap, bigint_coeffs)

    q_half = q >> big_uint(1)

    for i in range(slots):
        c = bigint_coeffs[i]
        c = biguint_mod(c, q)
        c_intn = c.to_intn()
        if c >= q_half: c_intn -= q.to_intn()
        values[i] = complex(scale_down(c_intn, scale), 0)
    
    if not isreal:
        i, j = 0, slots
        while i < slots:
            c = bigint_coeffs[j]
            c = biguint_mod(c, q)
            c_intn = c.to_intn()  # TODO: Handle edge-case where c_intn != c due to sign bit (make sure big_int is big enough)
            if c >= q_half: c_intn -= q.to_intn()
            values[i] += complex(0, scale_down(c_intn, scale))

            i, j = i + 1, j + 1
    

# StandardDeviation computes the scaled standard deviation of the input vector.
def standard_deviation(vec: list[float], scale: float) -> float:
    # We assume that the error is centered around zero
    n = float(len(vec))
    mean = 0.0
    err = 0.0

    for c in vec: mean += c
    mean /= n

    for c in vec:
        tmp = c - mean
        err += tmp * tmp

    return math.sqrt(err / n) * scale


class EncoderComplex128(Static[Encoder]):
    values: list[complex]
    values_float: list[float]
    roots: list[complex]

    def __init__(self, encoder: Encoder, roots: list[complex], values: list[complex], values_float: list[float]):
        self.params=encoder.params
        self.bigint_chain=encoder.bigint_chain
        self.bigint_coeffs=encoder.bigint_coeffs
        self.q_half=encoder.q_half
        self.buff=encoder.buff
        self.m=encoder.m
        self.rot_group=encoder.rot_group
        self.gaussian_sampler=encoder.gaussian_sampler

        self.roots=roots
        self.values=values
        self.values_float=values_float
    
    # encode encodes a set of values on the target plaintext.
    # This method is identical to "EncodeSlots".
    # Encoding is done at the level and scale of the plaintext.
    # User must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariantRing.
    # Returned plaintext is always in the NTT domain.
    def encode(self, values, plaintext: Plaintext, log_slots: int):
        self.embed(values, log_slots, plaintext.scale, False, plaintext.value)
    
    # embed is a generic method to encode a set of values on the target polyOut interface.
    # This method is at the core of the slot encoding.
    # values: values.(type) can be either []complex128 of []float64.
    # The imaginary part of []complex128 will be discarded if ring_type == ring.ConjugateInvariantRing.
    # logslots: user must ensure that 1 <= len(values) <= 2^log_slots < 2^logn and that log_slots >= 3.
    # scale: the scaling factor used do discretize float64 to fixed point integers.
    # montgomery: if True then the value written on polyOut are put in the Montgomery domain.
    # polyOut: polyOut.(type) can be either ringqp.Poly or *ring.Poly.
    # The encoding encoding is done at the level of polyOut.
    # Values written on  polyOut are always in the NTT domain.
    def embed(self, values, log_slots: int, scale: float, montgomery: bool, polyOut):
        if log_slots < MIN_LOG_SLOTS or log_slots > self.params.max_log_slots():
            raise ValueError(f"cannot embed: log_slots ({log_slots}) must be greater or equal to {MIN_LOG_SLOTS} and smaller than {self.params.max_log_slots()}\n")

        slots = 1 << log_slots
        len_values = 0

        # First checks the type of input values
        # If complex
        if isinstance(values, list[complex]):
            # Checks that the number of values is with the possible range
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            if self.params.ring_type == ring.StandardRing:
                self.values[:len_values] = [v.copy() for v in values]
            elif self.params.ring_type == ring.ConjugateInvariantRing:
                # Discards the imaginary part
                for i, v in enumerate(values):
                    self.values[i] = complex(v.real, 0)
            else:
                raise ValueError("cannot embed: ring_type must be ring.StandardRing or ring.ConjugateInvariantRing")
        # If floats only
        elif isinstance(values, list[float]):
            if len(values) > self.params.max_slots() or len(values) > slots:
                raise ValueError(f"cannot embed: ensure that #values ({len(values)}) <= slots ({slots}) <= max_slots ({self.params.max_slots()})\n")

            len_values = len(values)

            for i, v in enumerate(values):
                self.values[i] = complex(v, 0)
        else:
            compile_error(f"cannot embed: values.(type) must be []complex128 or []float64.")

        for i in range(len_values, slots):
            self.values[i] = complex(0)

        if log_slots < 4:
            special_ifft_vec(self.values, slots, self.m, self.rot_group, self.roots)
        else:
            special_ifft_ul8_vec(self.values, slots, self.m, self.rot_group, self.roots)

        is_ring_standard = self.params.ring_type == ring.StandardRing

        if isinstance(polyOut, ringqp.Poly):
            complex_to_fixed_point_crt(self.values.slice_reference(0, slots), scale, self.params.ring_q, is_ring_standard, polyOut.q)
            _mm_ntt_and_montgomery_lvl(polyOut.q.level(), log_slots, self.params.ring_q, montgomery, polyOut.q)

            if polyOut.p:
                complex_to_fixed_point_crt(self.values.slice_reference(0, slots), scale, self.params.ring_p, is_ring_standard, polyOut.p)
                _mm_ntt_and_montgomery_lvl(polyOut.p.level(), log_slots, self.params.ring_p, montgomery, polyOut.p)
        elif isinstance(polyOut, ring.Poly):
            complex_to_fixed_point_crt(self.values.slice_reference(0, slots), scale, self.params.ring_q, is_ring_standard, polyOut)
            _mm_ntt_and_montgomery_lvl(polyOut.level(), log_slots, self.params.ring_q, montgomery, polyOut)
        else:
            compile_error("cannot embed: invalid polyOut.(type) must be ringqp.Poly or *ring.Poly")

    # decode decodes the input plaintext on a new slice of complex128.
    # This method is the same as .DecodeSlots(*).
    def decode(self, plaintext: Plaintext, log_slots: int):
        return self._mm_decode_slots_public(plaintext, log_slots, 0)
    
    # decode_slots_public decodes the input plaintext on a new slice of complex128.
    # Adds, before the decoding step, an error with standard deviation sigma and bound floor(sqrt(2*pi)*sigma).
    # If the underlying ring_type is ConjugateInvariant, the imaginary part (and
    # its related error) are zero.
    def _mm_decode_slots_public(self, plaintext: Plaintext, log_slots: int, bound: float):
        return self._mm_decode_public(plaintext, log_slots, bound)
    
    def _mm_decode_public(self, plaintext: Plaintext, log_slots: int, sigma: float):
        if log_slots > self.params.max_log_slots() or log_slots < MIN_LOG_SLOTS:
            raise ValueError(f"cannot decode: ensure that {MIN_LOG_SLOTS} <= log_slots ({log_slots}) <= {self.params.max_log_slots()}")

        if plaintext.value.is_ntt:
            self.params.ring_q._mm_inv_ntt_lvl(plaintext.level(), plaintext.value, self.buff)
        else:
            ring._mm_copy_values_lvl(plaintext.level(), plaintext.value, self.buff)

        # B = floor(sigma * sqrt(2*pi))
        if sigma != 0:
            self.gaussian_sampler._mm_read_and_add_from_dist_lvl(plaintext.level(), self.buff, self.params.ring_q, f64xN(sigma), u64xN(int(2.5066282746310002 * sigma)))
        
        self.plaintext_to_complex(plaintext.level(), plaintext.scale, log_slots, self.buff._buf_coeffs, self.values)

        if log_slots < 3:
            special_fft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else:
            special_fft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        return [v.copy() for v in self.values]
    
    def plaintext_to_complex(self, level: int, scale: float, log_slots: int, coeffs: list[list[u64]], values: list[complex]):
        isreal = self.params.ring_type == ring.ConjugateInvariantRing
        if level == 0:
            poly_to_complex_no_crt(coeffs[0], values, scale, log_slots, isreal, self.params.ring_q)
        else:
            poly_to_complex_crt(level, coeffs, self.bigint_coeffs, values, scale, log_slots, isreal, self.params.ring_q, self.bigint_chain[level])

        if isreal: # [X]/(X^n+1) to [X+X^-1]/(X^n+1)
            slots = 1 << log_slots
            for i in range(1, slots): self.values[i] -= complex(0, self.values[slots-i].real)
    
    # get_err_std_slot_domain returns StandardDeviation(values_want-values_have)*scale
    # which is the scaled standard deviation of two complex vectors.
    def get_err_std_slot_domain(self, values_want: list[complex], values_have: list[complex], scale: float) -> float:
        for i in range(len(values_want)):
            err = values_want[i] - values_have[i]
            self.values_float[2 * i] = err.real
            self.values_float[2 * i + 1] = err.imag

        return standard_deviation(self.values_float.slice_reference(0, len(values_want) * 2), scale)
    
    # get_err_std_coeff_domain returns StandardDeviation(encode(values_want-values_have))*scale
    # which is the scaled standard deviation in the coefficient domain of the difference
    # of two complex vector in the slot domain.
    def get_err_std_coeff_domain(self, values_want: list[complex], values_have: list[complex], scale: float) -> float:
        for i in range(len(values_have)): self.values[i] = (values_want[i] - values_have[i])
        for i in range(len(values_have), len(self.values)): self.values[i] = complex(0, 0)

        log_slots = int((len(values_have) - 1).bitlen())

        # Runs FFT^-1 with the smallest power of two length that is greater than the input size
        if log_slots < 3: special_ifft_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)
        else: special_ifft_ul8_vec(self.values, 1 << log_slots, self.m, self.rot_group, self.roots)

        for i in range(len(values_want)):
            self.values_float[2 * i] = self.values[i].real
            self.values_float[2 * i + 1] = self.values[i].imag

        return standard_deviation(self.values_float.slice_reference(0, len(values_want) * 2), scale)


# NewEncoder creates a new Encoder that is used to encode a slice of complex values of size at most n/2 (the number of slots) on a Plaintext.
def new_encoder_complex(params: Parameters) -> EncoderComplex128:
	ecd = new_encoder(params)

	roots = list[complex](ecd.m + 1)
	for i in range(ecd.m):
		angle = 2 * 3.141592653589793 * i / ecd.m
		roots.append(complex(math.cos(angle), math.sin(angle)))

	roots.append(roots[0])

	return EncoderComplex128(
        encoder=ecd,
        roots=roots,
        values=zeros_vec(ecd.m >> 2, TP=complex),
        values_float=zeros_vec(ecd.m >> 1, TP=float))


# Stats is a struct storing the real, imaginary and l2 norm (modulus)
# about the precision of a complex value.
class Stats:
    real: float
    imag: float
    l2: float


# PrecisionStats is a struct storing statistic about the precision of a CKKS plaintext
class PrecisionStats:
    max_delta: Stats
    min_delta: Stats
    max_precision: Stats
    min_precision: Stats
    mean_delta: Stats
    mean_precision: Stats
    median_delta: Stats
    median_precision: Stats
    std_freq: float
    std_time: float

    real_dist: list[dict[str, float]]
    imag_dist: list[dict[str, float]]
    l2_dist: list[dict[str, float]]

    cdf_resol: int

    def __repr__(self) -> str:
        results_arr = array([
            [round(self.min_precision.real, 2), round(self.min_precision.imag, 2), round(self.min_precision.l2, 2)],
            [round(self.max_precision.real, 2), round(self.max_precision.imag, 2), round(self.max_precision.l2, 2)],
            [round(self.mean_precision.real, 2), round(self.mean_precision.imag, 2), round(self.mean_precision.l2, 2)],
            [round(self.median_precision.real, 2), round(self.median_precision.imag, 2), round(self.median_precision.l2, 2)]])
        
        return f"\n(Log2)\n(MIN prec, MAX prec, AVG prec, MED prec) x (real, imag, l2)\n{results_arr}\n"
    
    def calc_cdf(self, precs: list[float], res: list[dict[str, float]]):
        sorted_precs = sorted(precs)
        min_prec = sorted_precs[0]
        max_prec = sorted_precs[len(sorted_precs)-1]
        for i in range(self.cdf_resol):
            cur_prec = min_prec + float(i) * (max_prec - min_prec) / float(self.cdf_resol)
            for count_smaller, p in enumerate(sorted_precs):
                if p >= cur_prec:
                    res[i]["Prec"] = cur_prec
                    res[i]["Count"] = count_smaller
                    break


def delta_to_precision(c: Stats) -> Stats:
	return Stats(math.log2(1 / c.real), math.log2(1 / c.imag), math.log2(1 / c.l2))


def calc_median(values: list[Stats]) -> Stats:
    tmp = sorted([v.real for v in values])
    for i in range(len(values)): values[i].real = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].imag
    tmp.sort()
    for i in range(len(values)): values[i].imag = tmp[i]
    for i in range(len(values)): tmp[i] = values[i].l2
    tmp.sort()
    for i in range(len(values)): values[i].l2 = tmp[i]
    index = len(values) // 2
    if len(values) & 1 == 1 or index + 1 == len(values):
        return Stats(values[index].real, values[index].imag, values[index].l2)

    return Stats((values[index].real + values[index+1].real) / 2,
		(values[index].imag + values[index+1].imag) / 2,
		(values[index].l2 + values[index+1].l2) / 2)


def evaluate_precision(values_test: list[complex], values_want: list[complex]) -> PrecisionStats:
    slots = len(values_want)
    diff = [Stats() for _ in range(slots)]

    prec = PrecisionStats()
    prec.max_delta = Stats(0, 0, 0)
    prec.min_delta = Stats(1, 1, 1)
    prec.mean_delta = Stats(0, 0, 0)
    prec.cdf_resol = 500
    prec.real_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.imag_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]
    prec.l2_dist = [{"Prec": 0.0, "Count": 0.0} for _ in range(prec.cdf_resol)]

    prec_real = [0.0 for _ in range(len(values_want))]
    prec_imag = [0.0 for _ in range(len(values_want))]
    prec_l2 = [0.0 for _ in range(len(values_want))]

    for i in range(len(values_want)):
        delta_real = abs(values_test[i].real - values_want[i].real)
        delta_imag = abs(values_test[i].imag - values_want[i].imag)
        delta_l2 = math.sqrt(delta_real * delta_real + delta_imag * delta_imag)
        prec_real[i] = math.log2(1 / delta_real)
        prec_imag[i] = math.log2(1 / delta_imag)
        prec_l2[i] = math.log2(1 / delta_l2)

        diff[i].real = delta_real
        diff[i].imag = delta_imag
        diff[i].l2 = delta_l2

        prec.mean_delta.real += delta_real
        prec.mean_delta.imag += delta_imag
        prec.mean_delta.l2 += delta_l2

        if delta_real > prec.max_delta.real: prec.max_delta.real = delta_real
        if delta_imag > prec.max_delta.imag: prec.max_delta.imag = delta_imag
        if delta_l2 > prec.max_delta.l2: prec.max_delta.l2 = delta_l2
        if delta_real < prec.min_delta.real: prec.min_delta.real = delta_real
        if delta_imag < prec.min_delta.imag: prec.min_delta.imag = delta_imag
        if delta_l2 < prec.min_delta.l2: prec.min_delta.l2 = delta_l2

    prec.calc_cdf(prec_real, prec.real_dist)
    prec.calc_cdf(prec_imag, prec.imag_dist)
    prec.calc_cdf(prec_l2, prec.l2_dist)
    
    prec.min_precision = delta_to_precision(prec.max_delta)
    prec.max_precision = delta_to_precision(prec.min_delta)
    prec.mean_delta.real /= float(slots)
    prec.mean_delta.imag /= float(slots)
    prec.mean_delta.l2 /= float(slots)
    prec.mean_precision = delta_to_precision(prec.mean_delta)
    prec.median_delta = calc_median(diff)
    prec.median_precision = delta_to_precision(prec.median_delta)

    return prec


# GetPrecisionStats generates a PrecisionStats struct from the reference values and the decrypted values
# vWant.(type) must be either []complex128 or []float64
# element.(type) must be either *Plaintext, *Ciphertext, []complex128 or []float64. If not *Ciphertext, then decryptor can be nil.
def get_precision_stats(
        params: Parameters, encoder: EncoderComplex128, decryptor: Decryptor,
        v_want: list, element, log_slots: int, sigma: float) -> PrecisionStats:
    values_test = []
    values_want = []
    
    if isinstance(element, Ciphertext):
        values_test = encoder._mm_decode_public(decryptor.decrypt_new(element), log_slots, sigma)
    elif isinstance(element, Plaintext):
        values_test = encoder._mm_decode_public(element, log_slots, sigma)
    elif isinstance(element, list[complex]):
        values_test = element
    elif isinstance(element, list[float]):
        values_test = [complex(e, 0) for e in element]
    else: compile_error("Invalid type for test values")

    if isinstance(v_want, list[complex]): values_want = v_want
    elif isinstance(v_want, list[float]): values_want = [complex(e, 0) for e in v_want]
    else: compile_error("Invalid type for test values")

    prec = evaluate_precision(values_test, values_want)
    prec.std_freq = encoder.get_err_std_slot_domain(values_want, values_test, params.default_scale)
    prec.std_time = encoder.get_err_std_coeff_domain(values_want, values_test, params.default_scale)
    
    return prec


class EvaluatorBuffers:
    buff_q: list[ring.Poly]  #[3] Memory buffer in order: for MForm(c_0), MForm(c_1), c2
    buff_ct: Ciphertext  # Memory buffer for ciphertexts that need to be scaled up (to be eventually removed)


class EvaluatorBase:
	ckks_params: Parameters


def scale_up_exact(value: float, n: float, q: u64) -> u64:
    is_negative = False
    x_flo = 0.0

    if value < 0:
        is_negative = True
        x_flo = -n * value  # big.NewFloat(-n * value)
    else:
        x_flo = n * value  # big.NewFloat(n * value)

    x_flo += 0.5  # x_flo.add(x_flo, big.NewFloat(0.5))

    # x_int = new(big.Int)
    x_int = u64(x_flo)  # x_flo.Int(x_int)
    x_int = x_int.__naive_mod(q)

    res = x_int
    if is_negative: res = q - res

    return res


# evaluator is a struct that holds the necessary elements to execute the homomorphic operations between Ciphertexts and/or Plaintexts.
# It also holds a memory buffer used to store intermediate computations.
class Evaluator(Static[EvaluatorBase], Static[EvaluatorBuffers], Static[rlwe.Evaluator]):
    def set_evaluator_base(self, eval_base: EvaluatorBase):
        self.ckks_params = eval_base.ckks_params
    
    def set_evaluator_buffers(self, eval_buffers: EvaluatorBuffers):
        self.buff_ct = eval_buffers.buff_ct
        self.buff_q = eval_buffers.buff_q
    
    def set_rlwe_evaluator(self, eval: rlwe.Evaluator):
        self.ckks_params.set_rlwe_params(eval.params)
        self.params = eval.params
        
        self.buff_qp = eval.buff_qp
        self.buff_inv_ntt = eval.buff_inv_ntt
        self.buff_decomp_qp = eval.buff_decomp_qp
        self._mm_buff_bit_decomp = eval._mm_buff_bit_decomp

        self.rlk = eval.rlk
        self.rtks = eval.rtks
        self.permute_ntt_index = eval.permute_ntt_index

        self.basis_extender = eval.basis_extender
        self.decomposer = eval.decomposer
    
    def get_evaluator_base(self) -> EvaluatorBase:
        return EvaluatorBase(self.ckks_params)
    
    def get_const_and_scale(self, level: int, constant) -> Tuple[float, float, float]:
        # Converts to float and determines if a scaling is required
        # (which is the case if either real or imag have a rational part)
        scale = 1.0
        c_real, c_imag = 0.0, 0.0

        if isinstance(constant, complex):
            c_real = constant.real
            c_imag = constant.imag

            if c_real != 0:
                value_int = int(c_real)
                value_float = c_real - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])

            if c_imag != 0:
                value_int = int(c_imag)
                value_float = c_imag - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])
        elif isinstance(constant, float):
            c_real = constant
            c_imag = float(0)

            if c_real != 0:
                value_int = int(c_real)
                value_float = c_real - float(value_int)

                if value_float != 0:
                    scale = float(self.params.ring_q.modulus[level])
        elif isinstance(constant, u64) or isinstance(constant, int):
            c_real = float(constant)
            c_imag = float(0)
        else:
            compile_error("Invalid constant type within ciphertext multiplication.")

        if self.params.ring_type == ring.ConjugateInvariantRing:
            c_imag = float(0)

        return c_real, c_imag, scale
    
    # mult_by_const multiplies ct_0 by the input constant and returns the result in ct_out.
    # The scale of the output element will depend on the scale of the input element and the constant (if the constant
    # needs to be scaled (its rational part is not zero)). The constant can be a u64, int, float or complex128.
    def _mm_mul_by_const(self, ct_0: Ciphertext, constant, ct_out: Ciphertext):
        if ct_0._nil_ideal:
            ct_out.to_nil_ideal()
            return
        
        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        level = min(ct_0.level(), ct_out.level())

        c_real, c_imag, scale = self.get_const_and_scale(int(level), constant)

        # Component wise multiplication of the following vector with the ciphertext:
        # [a + b*psi_qi^2, ....., a + b*psi_qi^2, a - b*psi_qi^2, ...., a - b*psi_qi^2] mod Qi
        # [{                  N/2                }{                N/2               }]
        # Which is equivalent outside of the NTT domain to adding a to the first coefficient of ct_0 and b to the N/2-th coefficient of ct_0.
        ring_q = self.params.ring_q
        # @par(num_threads=NUM_THREADS)
        for i in range(level + 1):
            qi = ring_q.modulus[i]
            _mm_qi = ring_q._mm_modulus[i]
            bred_params = ring_q.bred_params[i]
            mred_params = ring_q.mred_params[i]
            _mm_mred_params = ring_q._mm_mred_params[i]

            scaled_const_real = u64(0)
            scaled_const_imag = u64(0)
            scaled_const = u64(0)

            if c_real != 0:
                scaled_const_real = scale_up_exact(c_real, scale, qi)
                scaled_const = scaled_const_real

            if c_imag != 0:
                scaled_const_imag = scale_up_exact(c_imag, scale, qi)
                scaled_const_imag = ring.mred(scaled_const_imag, ring_q.ntt_psi[i][1], qi, mred_params)
                scaled_const = ring.cred(scaled_const + scaled_const_imag, qi)

            scaled_const = ring.mform(scaled_const, qi, bred_params)
            _mm_scaled_const = u64xN(scaled_const)

            for u in range(len(ct_0.value)):
                p0_tmp = ct_0.value[u]._mm_coeffs[i]
                p1_tmp = ct_out.value[u]._mm_coeffs[i]
                ring._mm_mul_scalar_montgomery_vec(
                    p0_tmp.slice_reference(0, ring_q._mm_n >> 1),
                    p1_tmp, _mm_scaled_const, _mm_qi, _mm_mred_params)

            if c_imag != 0:
                scaled_const = ring.cred(scaled_const_real + (qi - scaled_const_imag), qi)
                scaled_const = ring.mform(scaled_const, qi, bred_params)
                _mm_scaled_const = u64xN(scaled_const)

            for u in range(len(ct_0.value)):
                p0_tmp = ct_0.value[u]._mm_coeffs[i]
                p1_tmp = ct_out.value[u]._mm_coeffs[i]
                ring._mm_mul_scalar_montgomery_vec(
                    p0_tmp.slice_reference(ring_q._mm_n >> 1, ring_q._mm_n),
                    p1_tmp.slice_reference(ring_q._mm_n >> 1, ring_q._mm_n),
                    _mm_scaled_const, _mm_qi, _mm_mred_params)

        ct_out.scale = ct_0.scale * scale

    def _mm_evaluate_in_place(self, c_0, c_1, ct_out, evaluate_callable):
        if c_0._nil_ideal:
            ct_out.set(c_1)
            return
        if c_1._nil_ideal:
            ct_out.set(c_0)
            return

        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"
        
        level = min(min(c_0.level(), c_1.level()), ct_out.level())
        max_degree = max(c_0.degree(), c_1.degree())
        min_degree = min(c_0.degree(), c_1.degree())

        # Else resizes the receiver element
        ct_out.resize(max_degree, ct_out.level())

        c_0_scale = c_0.scale
        c_1_scale = c_1.scale
        ct_out_scale = ct_out.scale

        if ct_out.level() > level:
            self.drop_level(Ciphertext(ct_out, ct_out_scale), ct_out.level() - min(c_0.level(), c_1.level()))

        c_1_cipher = c_1.ciphertext() if isinstance(c_1, Plaintext) else c_1
        tmp_0, tmp_1 = c_0, c_1_cipher
        # Checks whether or not the receiver element is the same as one of the input elements
        # and acts accordingly to avoid unnecessary element creation or element overwriting,
        # and scales properly the element before the evaluation.
        if ct_out == c_0:
            if c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                tmp_1 = self.buff_ct
                self._mm_mul_by_const(Ciphertext(c_1_cipher, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(tmp_1, ct_out_scale))
            elif c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                self._mm_mul_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(c_0, c_0_scale))
                ct_out.set_scale(c_1_scale)
                tmp_1 = c_1_cipher
            else:
                tmp_1 = c_1_cipher
            tmp_0 = c_0
        elif ct_out == c_1_cipher:
            if c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                tmp_0 = self.buff_ct
                self._mm_mul_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(tmp_0, ct_out_scale))
            elif c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                self._mm_mul_by_const(Ciphertext(c_1_cipher, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(ct_out, ct_out_scale))
                ct_out.set_scale(c_0_scale)
                tmp_0 = c_0
            else:
                tmp_0 = c_0
            tmp_1 = c_1_cipher
        else:
            if c_1_scale > c_0_scale and math.floor(c_1_scale / c_0_scale) > 1:
                tmp_0 = self.buff_ct
                self._mm_mul_by_const(Ciphertext(c_0, c_0_scale), math.floor(c_1_scale / c_0_scale), Ciphertext(tmp_0, ct_out_scale))
                tmp_1 = c_1_cipher
            elif c_0_scale > c_1_scale and math.floor(c_0_scale / c_1_scale) > 1:
                tmp_1 = self.buff_ct
                self._mm_mul_by_const(Ciphertext(c_1_cipher, c_1_scale), math.floor(c_0_scale / c_1_scale), Ciphertext(tmp_1, ct_out_scale))
                tmp_0 = c_0
            else:
                tmp_0 = c_0
                tmp_1 = c_1_cipher

        for i in range(min_degree + 1):
            if evaluate_callable == "ring.add_lvl":
                self.params.ring_q._mm_add_lvl(level, tmp_0.value[i], tmp_1.value[i], ct_out.value[i])
            elif evaluate_callable == "ring.sub_lvl":
                self.params.ring_q._mm_sub_lvl(level, tmp_0.value[i], tmp_1.value[i], ct_out.value[i])
            else:
                raise NotImplementedError("Generic evaluator supports only addition and subtraction at the moment.")

        ct_out.set_scale(max(c_0_scale, c_1_scale))

        # If the inputs degrees differ, it copies the remaining degree on the receiver.
        # Also checks that the receiver is not one of the inputs to avoid unnecessary work.
        if c_0.degree() > c_1.degree() and tmp_0 != ct_out:
            for i in range(min_degree + 1, max_degree + 1):
                ring._mm_copy_values_lvl(level, tmp_0.value[i], ct_out.value[i])
        elif c_1.degree() > c_0.degree() and tmp_1 != ct_out:
            for i in range(min_degree + 1, max_degree + 1):
                ring._mm_copy_values_lvl(level, tmp_1.value[i], ct_out.value[i])
    
    def new_ciphertext_binary(self, op_0, op_1) -> Ciphertext:
        max_degree = max(op_0.degree(), op_1.degree())
        max_scale = max(op_0.scale, op_1.scale)
        min_level = min(op_0.level(), op_1.level())

        return new_ciphertext(self.ckks_params, max_degree, min_level, max_scale)
    
    def check_binary(self, op_0, op_1, op_out, op_out_min_degree: int):
        if not op_0 or not op_1 or not op_out:
            raise ValueError("cannot check_binary: operands cannot be nil")

        if op_0.degree() + op_1.degree() == 0:
            raise ValueError("cannot check_binary: operands cannot be both plaintext")

        if op_out.degree() < op_out_min_degree:
            raise ValueError("cannot check_binary: receiver operand degree is too small")

        op_0_values = [op_0.value] if isinstance(op_0, Plaintext) else op_0.value
        op_1_values = [op_1.value] if isinstance(op_1, Plaintext) else op_0.value

        for pol in op_0_values:
            if not pol.is_ntt:
                raise ValueError("cannot check_binary: op_0 must be in NTT")

        for pol in op_1_values:
            if not pol.is_ntt:
                raise ValueError("cannot check_binary: op_1 must be in NTT")

    # neg negates the value of ct_0 and returns the result in ct_out.
    def neg(self, ct_0: Ciphertext, ct_out: Ciphertext):
        if ct_0._nil_ideal:
            ct_out.to_nil_ideal()
            return
        
        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"
        
        level = min(ct_0.level(), ct_out.level())

        if ct_0.degree() != ct_out.degree():
            raise ValueError("cannot Negate: invalid receiver Ciphertext does not match input Ciphertext degree")

        for i in range(len(ct_0.value)):
            self.params.ring_q._mm_neg_lvl(level, ct_0.value[i], ct_out.value[i])

        ct_out.scale = ct_0.scale

    # neg_new negates ct_0 and returns the result in a newly created element.
    def neg_new(self, ct_0: Ciphertext) -> Ciphertext:
        if ct_0._nil_ideal: return ct_0
        
        ct_out = new_ciphertext(self.ckks_params, ct_0.degree(), ct_0.level(), ct_0.scale)
        self.neg(ct_0, ct_out)
        return ct_out

    # add adds op_1 to ct_in and returns the result in ct_out.
    def add(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        if ct_in._nil_ideal:
            ct_out.set(op_1)
            return
        if op_1._nil_ideal:
            ct_out.set(ct_in)
            return
        
        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        self._mm_evaluate_in_place(ct_in, op_1, ct_out, "ring.add_lvl")
    
    # add_new adds op_1 to ct_in and returns the result in a newly created element.
    def add_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        if ct_in._nil_ideal:
            return op_1.ciphertext()
        if op_1._nil_ideal:
            return ct_in

        ct_out = self.new_ciphertext_binary(ct_in, op_1)
        self.add(ct_in, op_1, ct_out)
        return ct_out
    
    # sub subtracts op_1 from ct_in and returns the result in ct_out.
    def sub(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        if ct_in._nil_ideal:
            self.neg(op_1.ciphertext(), ct_out)
            return
        if op_1._nil_ideal:
            ct_out.set(ct_in)
            return
        
        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        self._mm_evaluate_in_place(ct_in, op_1, ct_out, "ring.sub_lvl")

        level = min(min(ct_in.level(), op_1.level()), ct_out.level())
        if ct_in.degree() < op_1.degree():
            for i in range(ct_in.degree() + 1, op_1.degree() + 1):
                self.params.ring_q._mm_neg_lvl(level, ct_out.value[i], ct_out.value[i])

    # sub_new subtracts op_1 from ct_in and returns the result in a newly created element.
    def sub_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        if ct_in._nil_ideal:
            return self.neg_new(op_1.ciphertext())
        if op_1._nil_ideal:
            return ct_in

        ct_out = self.new_ciphertext_binary(ct_in, op_1)
        self.sub(ct_in, op_1, ct_out)
        return ct_out
    
    # mult_by_i multiplies ct_0 by the imaginary number i, and returns the result in ct_out.
    # It does not change the scale.
    def mul_by_i(self, ct_0: Ciphertext, ct_out: Ciphertext):
        if ct_0._nil_ideal:
            ct_out.to_nil_ideal()
            return
        
        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        if self.params.ring_type == ring.ConjugateInvariantRing:
            raise ValueError("cannot mul_by_i: method not supported when params.RingType() == ring.ConjugateInvariantRing")

        level = min(ct_0.level(), ct_out.level())
        ct_out.scale = ct_0.scale
        ring_q = self.params.ring_q

        # Equivalent to a product by the monomial x^(n/2) outside of the NTT domain
        # @par(num_threads=NUM_THREADS)
        for i in range(level + 1):
            imag = ring_q.ntt_psi[i][1]  # Psi^2
            
            _mm_imag = u64xN(imag)
            _mm_qi = ring_q._mm_modulus[i]
            _mm_mred_params = ring_q._mm_mred_params[i]

            for u in range(len(ct_out.value)):
                p0_tmp = ct_0.value[u]._mm_coeffs[i]
                p1_tmp = ct_out.value[u]._mm_coeffs[i]
                ring._mm_mul_scalar_montgomery_vec(
                    p0_tmp.slice_reference(0, ring_q._mm_n >> 1),
                    p1_tmp, _mm_imag, _mm_qi, _mm_mred_params)
            
            _mm_imag = u64xN(ring_q.modulus[i] - imag)

            for u in range(len(ct_out.value)):
                p0_tmp = ct_0.value[u]._mm_coeffs[i]
                p1_tmp = ct_out.value[u]._mm_coeffs[i]
                ring._mm_mul_scalar_montgomery_vec(
                    p0_tmp.slice_reference(ring_q._mm_n >> 1, ring_q._mm_n),
                    p1_tmp.slice_reference(ring_q._mm_n >> 1, ring_q._mm_n),
                    _mm_imag, _mm_qi, _mm_mred_params)

    # mult_by_i_new multiplies ct_0 by the imaginary number i, and returns the result in a newly created element.
    # It does not change the scale.
    def mul_by_i_new(self, ct_0: Ciphertext) -> Ciphertext:
        if ct_0._nil_ideal:
            return Ciphertext.nil_ideal()

        if self.params.ring_type == ring.ConjugateInvariantRing:
            raise ValueError("cannot mul_by_i_new: method not supported when params.RingType() == ring.ConjugateInvariantRing")

        ct_out = new_ciphertext(self.ckks_params, 1, ct_0.level(), ct_0.scale)
        self.mul_by_i(ct_0, ct_out)
        return ct_out
    
    # mult_new multiplies ct_in with op_1 without relinearization and returns the result in a newly created element.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    def mul_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        if ct_in._nil_ideal or op_1._nil_ideal:
            return Ciphertext.nil_ideal()
        
        ct_out = new_ciphertext(self.ckks_params, ct_in.degree() + op_1.degree(), min(ct_in.level(), op_1.level()), 0)
        self.mul_relin(ct_in, op_1, False, ct_out)
        return ct_out

    #  multiplies ct_in with op_1 without relinearization and returns the result in ct_out.
    # The procedure will panic if either ct_in or op_1 are have a degree higher than 1.
    # The procedure will panic if ct_out.degree != ct_in.degree + op_1.degree.
    def mul(self, ct_in: Ciphertext, op_1, ct_out: Ciphertext):
        if ct_in._nil_ideal or op_1._nil_ideal:
            ct_out.to_nil_ideal()
            return

        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        self.mul_relin(ct_in, op_1, False, ct_out)

    # mult_relin_new multiplies ct_in with op_1 with relinearization and returns the result in a newly created element.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    # The procedure will panic if the evaluator was not created with an relinearization key.
    def mul_relin_new(self, ct_in: Ciphertext, op_1) -> Ciphertext:
        if ct_in._nil_ideal or op_1._nil_ideal:
            return Ciphertext.nil_ideal()
        
        ct_out = new_ciphertext(self.ckks_params, 1, min(ct_in.level(), op_1.level()), 0)
        self.mul_relin(ct_in, op_1, True, ct_out)
        return ct_out

    # MulRelin multiplies ct_in with op_1 with relinearization and returns the result in ct_out.
    # The procedure will panic if either ct_in.degree or op_1.degree > 1.
    # The procedure will panic if ct_out.degree != ct_in.degree + op_1.degree.
    # The procedure will panic if the evaluator was not created with an relinearization key.
    def mul_relin(self, ct_in: Ciphertext, op_1, relin: bool, ct_out: Ciphertext):
        if ct_in._nil_ideal or op_1._nil_ideal:
            ct_out.to_nil_ideal()
            return

        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"
        
        self.check_binary(ct_in, op_1, ct_out, max(ct_in.degree(), op_1.degree()))
        level = min(min(ct_in.level(), op_1.level()), ct_out.level())

        if ct_in.degree() + op_1.degree() > 2:
            raise ValueError("cannot MulRelin: the sum of the input elements' total degree cannot be larger than 2")

        ct_out.scale = ct_in.scale * op_1.scale
        ring_q = self.params.ring_q

        # Case Ciphertext (x) Ciphertext
        if isinstance(op_1, Ciphertext):
            assert ct_in.degree() == 1 and op_1.degree() == 1, "Two ciphertexts should have their degree equal to 1 on multiplication."

            c00 = self.buff_q[0]
            c01 = self.buff_q[1]

            c0 = ct_out.value[0]
            c1 = ct_out.value[1]
            c2 = self.buff_q[2]

            if not relin:
                ct_out.resize(2, level)
                c2 = ct_out.value[2]
            else: ct_out.resize(1, level)
            
            # TODO: Double-check the eq check below: Avoid overwriting if the second input is the output
            tmp0, tmp1 = ct_in, op_1
            if op_1 == ct_out:
                tmp0, tmp1 = op_1, ct_in

            ring_q._mm_mform_lvl(level, tmp0.value[0], c00)
            ring_q._mm_mform_lvl(level, tmp0.value[1], c01)

            ring_q._mm_mul_coeffs_montgomery_lvl(level, c00, tmp1.value[0], c0)  # c0 = c[0]*c[0]
            ring_q._mm_mul_coeffs_montgomery_lvl(level, c01, tmp1.value[1], c2)  # c2 = c[1]*c[1]
            ring_q._mm_mul_coeffs_montgomery_lvl(level, c00, tmp1.value[1], c1)

            if ct_in == op_1:  # squaring case
                ring_q._mm_add_lvl(level, c1, c1, c1)  # c1 = 2*c[0]*c[1]
            else:  # regular case
                ring_q._mm_mul_coeffs_montgomery_and_add_lvl(level, c01, tmp1.value[0], c1)  # c1 = c0[0]*c1[1] + c0[1]*c1[0]

            if relin:
                c2.is_ntt = True
                self._mm_gadget_product(level, c2, self.rlk.keys[0].gadget_ciphertext(), self.buff_qp[1].q, self.buff_qp[2].q)
                ring_q._mm_add_lvl(level, c0, self.buff_qp[1].q, c0)
                ring_q._mm_add_lvl(level, c1, self.buff_qp[2].q, c1)
        elif isinstance(op_1, Plaintext): # Case Ciphertext (x) Plaintext
            if ct_out.degree() < ct_in.degree():
                ct_out.resize(ct_in.degree(), level)
            else:
                ct_out.resize(ct_out.degree(), level)

            c00 = self.buff_q[0]

            ring_q._mm_mform_lvl(level, op_1.value, c00)
            for i in range(len(ct_in.value)):
                ring_q._mm_mul_coeffs_montgomery_lvl(level, ct_in.value[i], c00, ct_out.value[i])
        else:
            compile_error("Invalid multiplication factors. Should be either ciphertext and plaintext or two ciphertexts of degree equal to 1.")

    # RotateNew rotates the columns of ct_0 by k positions to the left, and returns the result in a newly created element.
    # If the provided element is a Ciphertext, a key-switching operation is necessary and a rotation key for the specific rotation needs to be provided.
    def rotate_new(self, ct_0: Ciphertext, k: int) -> Ciphertext:
        if ct_0._nil_ideal:
            return ct_0

        ct_out = new_ciphertext(self.ckks_params, ct_0.degree(), ct_0.level(), ct_0.scale)
        self.rotate(ct_0, k, ct_out)
        return ct_out
    
    # Rotate rotates the columns of ct_0 by k positions to the left and returns the result in ct_out.
    # If the provided element is a Ciphertext, a key-switching operation is necessary and a rotation key for the specific rotation needs to be provided.
    def rotate(self, ct_0: Ciphertext, k: int, ct_out: Ciphertext):
        if ct_0._nil_ideal:
            ct_out.to_nil_ideal()
            return

        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"

        self._mm_automorphism(ct_0.get_rlwe_ciphertext(), self.params.galois_element_for_column_rotation_by(k), ct_out.get_rlwe_ciphertext())
        ct_out.scale = ct_0.scale
    
    def reduce_add(self, ct_0: Ciphertext, cols_in_cipher: int):
        if ct_0._nil_ideal:
            return ct_0
        
        slots = self.ckks_params.slots()
        assert 0 < cols_in_cipher <= slots, "CKKS.Evaluator.reduce_add: Invalid number of columns in cipher"

        rotation_step = 1
        for _ in range((cols_in_cipher - 1).bitlen()):
            rotated_cipher = self.rotate_new(ct_0, rotation_step)
            self.add(ct_0, rotated_cipher, ct_0)
            rotation_step <<= 1
    
    # Rescale divides ct0 by the last modulus in the moduli chain, and repeats this
    # procedure (consuming one level each time) until the scale reaches the original scale or before it goes below it, and returns the result
    # in ct_out. Since all the moduli in the moduli chain are generated to be close to the
    # original scale, this procedure is equivalent to dividing the input element by the scale and adding
    # some error.
    # Returns an error if "min_scale <= 0", ct.scale = 0, ct.level() = 0, ct.IsNTT() != true or if ct.Leve() != ct_out.level()
    def rescale(self, ct_in: Ciphertext, min_scale: float, ct_out: Ciphertext):
        if ct_in._nil_ideal:
            ct_out.to_nil_ideal()
            return

        assert not ct_out._nil_ideal, "CKKS.Ciphertext: output cipher cannot be nil-ideal"
        
        ring_q = self.params.ring_q

        if min_scale <= 0: raise ValueError("cannot Rescale: min_scale is 0")
        if ct_in.scale == 0: raise ValueError("cannot Rescale: ciphertext scale is 0")
        if ct_in.level() == 0: raise ValueError("cannot Rescale: Ciphertext at level 0 --- needs bootstrapping")
        if ct_out.degree() != ct_in.degree(): raise ValueError("cannot Rescale: ct_in.degree() != ct_out.degree()")

        ct_out.scale = ct_in.scale
        nb_rescales = 0
        # Divides the scale by each moduli of the modulus chain as long as the scale isn't smaller than min_scale/2
        # or until the output level() would be zero
        while ct_in.level() - nb_rescales >= 0 and ct_out.scale / float(ring_q.modulus[ct_in.level() - nb_rescales]) >= min_scale / 2:
            ct_out.scale /= float(ring_q.modulus[ct_in.level() - nb_rescales])
            nb_rescales += 1

        if nb_rescales > 0:
            level = ct_in.level()
            for i in range(len(ct_out.value)):
                ring_q._mm_div_round_by_last_modulus_many_ntt_lvl(level, nb_rescales, ct_in.value[i], self.buff_q[0], ct_out.value[i])
            ct_out.resize(ct_out.degree(), level - nb_rescales)
        elif ct_in != ct_out: ct_out = ct_in.copy()
    
    # drop_level reduces the level of ct0 by levels and returns the result in ct0.
    # No rescaling is applied during this procedure.
    def drop_level(self, ct_0: Ciphertext, levels: int):
        if ct_0._nil_ideal:
            return
        ct_0.resize(ct_0.degree(), ct_0.level() - levels)

    # DropLevelNew reduces the level of ct0 by levels and returns the result in a newly created element.
    # No rescaling is applied during this procedure.
    def drop_level_new(self, ct_0: Ciphertext, levels: int) -> Ciphertext:
        if ct_0._nil_ideal:
            return ct_0
        ct_out = ct_0.copy()
        self.drop_level(ct_out, levels)
        return ct_out


def new_evaluator_buffers(eval_base: EvaluatorBase) -> EvaluatorBuffers:
	buff = EvaluatorBuffers()
	params = eval_base.ckks_params
	ring_q = params.ring_q
	buff.buff_q = [ring_q.new_poly() for _ in staticrange(3)]
	buff.buff_ct = new_ciphertext(params, 2, params.max_level(), params.default_scale)
	return buff


def new_evaluator_base(params: Parameters) -> EvaluatorBase:
	ev = EvaluatorBase()
	ev.ckks_params = params
	return ev


# NewEvaluator creates a new Evaluator, that can be used to do homomorphic
# operations on the Ciphertexts and/or Plaintexts. It stores a memory buffer
# and Ciphertexts that will be used for intermediate values.
def new_evaluator(params: Parameters, evaluation_key: rlwe.EvaluationKey) -> Evaluator:
    eval = Evaluator()
    eval.set_evaluator_base(new_evaluator_base(params))
    eval.set_evaluator_buffers(new_evaluator_buffers(eval.get_evaluator_base()))
    eval.set_rlwe_evaluator(rlwe.new_evaluator(params.get_rlwe_params(), evaluation_key))
    return eval


# RotationType defines how much we should rotate and in which direction
class RotationType:
    value: int
    side: bool

    def is_right(self) -> bool:
        return self.side
    
    def is_left(self) -> bool:
        return not self.side


# Generate rotKeys for power of two shifts up to # of slots
# and for every shift up to smallDim
def generate_rot_keys(slots: int, small_dim: Static[int], baby_flag: bool) -> list[RotationType]:
    rotations = list[RotationType]()
    # l is the closest larger pow of 2 to slots
    l = slots if slots.popcnt() == 1 else (1 << slots.bitlen())

    rot = 1
    for _ in range(int(math.ceil(math.log2(float(l))))):
        rotations.append(RotationType(value=rot, side=False))
        rotations.append(RotationType(value=rot, side=True))
        rot *= 2

    # for baby-step giant-step rotations
    if baby_flag:
        rootl = int(math.ceil(math.sqrt(float(slots))))
        for i in range(1, rootl):
            rotations.append(RotationType(value=i, side=False))
            rotations.append(RotationType(value=i * rootl, side=False))

    # for moving the innersum value to its new position
    for i in staticrange(1, small_dim):
        rotations.append(RotationType(value=i, side=True))

    return rotations


# CryptoParams aggregates all ckks scheme information
class CryptoParams:
    sk_shard: rlwe.SecretKey
    pk: rlwe.PublicKey
    rlk: rlwe.RelinearizationKey
    rotks: rlwe.RotationKeySet
    params: Parameters

    encoder: EncoderComplex128
    encryptor: PkEncryptor
    decryptor: Decryptor
    evaluator: Evaluator

    prec: u64

    def __init__(self, params: Parameters):
        self.params = params

    def initialize(
            self, sk_shard: rlwe.SecretKey,
            pk: rlwe.PublicKey, rlk: rlwe.RelinearizationKey, rtks: rlwe.RotationKeySet, prec: u64):
        
        self.evaluator = new_evaluator(self.params, rlwe.EvaluationKey(rlk=rlk, rtks=rtks))
        self.encoder = new_encoder_complex(self.params)  # TODO: #218 Replace with big encoder
        self.encryptor = new_encryptor(self.params, pk)
        self.decryptor = new_decryptor(self.params, sk_shard)

        self.sk_shard = sk_shard
        self.pk = pk
        self.rlk = rlk
        self.rotks = rtks

        # self.prec = # TODO: #218 Replace with big encoder
