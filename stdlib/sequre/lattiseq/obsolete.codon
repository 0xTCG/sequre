"""
The list of obsolete methods.
Kept for testing only.
"""
from experimental.simd import Vec

from ring import Ring, ModupParams, _mm_mred, butterfly, ntt_lazy, reduce_vec
from ..utils.utils import zeros_vec
from ..utils.constants import SIMD_LANE_SIZE


def _mm_butterfly_inplace_x2_old(u: Vec[u64, 4], ntt_psi: u64, two_q: u64, four_q: u64, q: u64, q_inv: u64) -> Vec[u64, 4]:
    u_list = u.scatter()
    u_list[0], u_list[2] = butterfly(u_list[0], u_list[2], ntt_psi, two_q, four_q, q, q_inv)
    u_list[1], u_list[3] = butterfly(u_list[1], u_list[3], ntt_psi, two_q, four_q, q, q_inv)
    return Vec[u64, 4](u_list)


def _mm_butterfly_inplace_x1_old(u: Vec[u64, 4], ntt_psi_0: u64, ntt_psi_1: u64, two_q: u64, four_q: u64, q: u64, q_inv: u64) -> Vec[u64, 4]:
    u_list = u.scatter()
    u_list[0], u_list[1] = butterfly(u_list[0], u_list[1], ntt_psi_0, two_q, four_q, q, q_inv)
    u_list[2], u_list[3] = butterfly(u_list[2], u_list[3], ntt_psi_1, two_q, four_q, q, q_inv)
    return Vec[u64, 4](u_list)


# Caution, returns the values in [0, 2q-1]
def mult_sum(
        v: list[u64], y: list[list[u64]], nb_pi: int, pj: u64,
        q_inv: u64, vtimesqmodp: list[u64], qoverqimodp: list[u64], lane_size: Static[int]):
    rlo = zeros_vec(lane_size, TP=u64)
    rhi = zeros_vec(lane_size, TP=u64)
    res = zeros_vec(lane_size, TP=u64)
	
    # Accumulates the sum on uint128 and does a lazy montgomery reduction at the end
    for i in range(nb_pi):
        for idx in range(lane_size):
            mhi, mlo = y[idx][i].mul_overflow_u64(qoverqimodp[i])
            rlo[idx], c = rlo[idx].add_overflow(mlo)
            rhi[idx] += mhi + c

    for idx in range(lane_size):
        hhi, _ = (rlo[idx] * q_inv).mul_overflow_u64(pj)
        res[idx] = rhi[idx] - hhi + pj + vtimesqmodp[int(v[idx])]

    return res

def reconstruct_rns(
        index: int, x: int, p: list[list[u64]], q: list[u64],
        q_inv: list[u64], qb_mont: list[u64]) -> tuple[list[u64], list[list[u64]]]:
    v = Vec[f64, SIMD_LANE_SIZE](0.0)
    y = list[Vec[u64, SIMD_LANE_SIZE]](32)

    for i in range(index):
        # TODO: Instantiate _mm_* vars once at param setup stage upstream
        _mm_p = Vec[u64, SIMD_LANE_SIZE](p[i].arr.ptr + x)
        _mm_q = Vec[u64, SIMD_LANE_SIZE](q[i])
        _mm_q_inv = Vec[u64, SIMD_LANE_SIZE](q_inv[i])
        _mm_qb_mont = Vec[u64, SIMD_LANE_SIZE](qb_mont[i])

        y.append(_mm_mred(_mm_p, _mm_qb_mont, _mm_q, _mm_q_inv))

        v = v + (y[i] / _mm_q)
    
    return v.to_u64().scatter(), y.scatter().transpose()


# ModUpExact takes p1 mod q and switches its basis to P, returning the result on p2.
# Caution, returns the values in [0, 2q-1]
def mod_up_exact(p1: list[list[u64]], p2: list[list[u64]], ring_q: Ring, ring_p: Ring, params: ModupParams):
    q = ring_q.modulus
    p = ring_p.modulus
    mred_params_q = ring_q.mred_params
    mred_params_p = ring_p.mred_params
    vtimesqmodp = params.vtimesqmodp
    qoverqiinvqi = params.qoverqiinvqi
    qoverqimodp = params.qoverqimodp

    # We loop over each coefficient and apply the basis extension
    for x in range(0, len(p1[0]), SIMD_LANE_SIZE):
        v, y = reconstruct_rns(len(p1), x, p1, q, mred_params_q, qoverqiinvqi)
        for j in range(len(p2)):
            p2[j][x:x + SIMD_LANE_SIZE] = mult_sum(v, y, len(p1), p[j], mred_params_p[j], vtimesqmodp[j], qoverqimodp[j], SIMD_LANE_SIZE)


def ntt(coeffs_in: list[u64], coeffs_out: list[u64], n: int, ntt_psi: list[u64], q: u64, mred_param: u64, bred_param: u64):
    ntt_lazy(coeffs_in, coeffs_out, n, ntt_psi, q, mred_param)
    reduce_vec(coeffs_out, coeffs_out, q, bred_param)
