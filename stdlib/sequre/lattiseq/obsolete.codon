"""
The list of obsolete methods.
Kept for testing only.
"""


def reconstruct_rns(
        index: int, x: int, p: list[list[u64]], q: list[u64],
        q_inv: list[u64], qb_mont: list[u64]) -> tuple[list[u64], list[list[u64]]]:
    v = Vec[f64, SIMD_LANE_SIZE](0.0)
    y = list[Vec[u64, SIMD_LANE_SIZE]](32)

    for i in range(index):
        # TODO: Instantiate _mm_* vars once at param setup stage upstream
        _mm_p = Vec[u64, SIMD_LANE_SIZE](p[i].arr.ptr + x)
        _mm_q = Vec[u64, SIMD_LANE_SIZE](q[i])
        _mm_q_inv = Vec[u64, SIMD_LANE_SIZE](q_inv[i])
        _mm_qb_mont = Vec[u64, SIMD_LANE_SIZE](qb_mont[i])

        y.append(_mm_mred(_mm_p, _mm_qb_mont, _mm_q, _mm_q_inv))

        v = v + (y[i] / _mm_q)
    
    return v.to_u64().scatter(), y.scatter().transpose()


# ModUpExact takes p1 mod q and switches its basis to P, returning the result on p2.
# Caution, returns the values in [0, 2q-1]
def mod_up_exact(p1: list[list[u64]], p2: list[list[u64]], ring_q: Ring, ring_p: Ring, params: ModupParams):
    q = ring_q.modulus
    p = ring_p.modulus
    mred_params_q = ring_q.mred_params
    mred_params_p = ring_p.mred_params
    vtimesqmodp = params.vtimesqmodp
    qoverqiinvqi = params.qoverqiinvqi
    qoverqimodp = params.qoverqimodp

    # We loop over each coefficient and apply the basis extension
    for x in range(0, len(p1[0]), SIMD_LANE_SIZE):
        v, y = reconstruct_rns(len(p1), x, p1, q, mred_params_q, qoverqiinvqi)
        for j in range(len(p2)):
            p2[j][x:x + SIMD_LANE_SIZE] = mult_sum(v, y, len(p1), p[j], mred_params_p[j], vtimesqmodp[j], qoverqimodp[j], SIMD_LANE_SIZE)