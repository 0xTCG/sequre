import prg

from numpy.ndarray import ndarray

from ..lattiseq.rlwe import \
    SecretKey, \
    PublicKey, \
    RelinearizationKey, \
    RotationKeySet, \
    AdditiveShareBigint, \
    new_rotation_key_set
from ..lattiseq.ckks import \
    PN14QP438, \
    Parameters, \
    Ciphertext, \
    PrecisionStats, \
    Plaintext, \
    new_key_generator, \
    evaluate_precision, \
    new_plaintext, \
    new_public_key, \
    new_ciphertext, \
    new_relinearization_key, \
    new_parameters_from_literal, \
    CryptoParams, \
    RotationType, \
    generate_rot_keys
from ..lattiseq.ring import \
    Poly as ring_Poly, \
    new_gaussian_sampler
from ..lattiseq.ringqp import \
    UniformSampler, \
    Poly, \
    Ring, \
    new_uniform_sampler
from ..lattiseq.dckks import \
    RefreshShare, \
    RefreshProtocol, \
    new_pcks_protocol, \
    new_ckg_protocol, \
    new_rkg_protocol, \
    new_refresh_protocol, \
    get_minimum_level_for_bootstrapping, \
    new_rot_kg_protocol, \
    new_e2s_protocol, \
    new_s2e_protocol, \
    new_additive_share_bigint
from ..lattiseq.drlwe import \
    PCKSShare, \
    CKGShare, \
    RKGShare, \
    RTGShare, \
    CKSShare
from ..lattiseq.utils import new_prng
from ..types.utils import double_to_fp, fp_to_double
from ..utils.utils import zeros_vec, ones_vec, one_hot_vector
from ..utils.param import int_t

from stats import MPCStats
from randomness import MPCRandomness
from comms import MPCComms


class MPCHE[TP]:
    pid: int
    stats: MPCStats
    randomness: MPCRandomness
    comms: MPCComms[TP]

    crp_gen: UniformSampler
    crypto_params: CryptoParams

    # Bootstrap safety params
    bootstrap_min_level: int
    bootstrap_log_bound: int
    boostrap_safe: bool

    def __init__(self, comms: MPCComms[TP]):
        self.pid = comms.pid
        self.stats = comms.stats
        self.randomness = comms.randomness
        self.comms = comms
    
    def default_setup(self):
        print(f"CP{self.pid}:\tSetting up default MHE setup ...")
        ckks_params = new_parameters_from_literal(PN14QP438)
        self.set_params(ckks_params)
        self.collective_init(ckks_params, u64(256))

    def set_params(self, params: Parameters):
        self.randomness.switch_seed(-1)
        seed = u32(prg.getrandbits(32))
        self.randomness.restore_seed(-1)

        ring_qp = params.ring_qp()
        crp_gen = new_uniform_sampler(new_prng(seed), ring_qp)

        self.crp_gen = crp_gen
        self.crypto_params = CryptoParams(params)

        self.bootstrap_min_level, self.bootstrap_log_bound, self.boostrap_safe = get_minimum_level_for_bootstrapping(
            128, params.default_scale, self.comms.number_of_parties - 1, params.q())
        
        assert self.boostrap_safe, "MPCHE: Colletive bootstrapping is unsafe for selected HE parametrization and number of computing parties. Aborting ..."
    
    def aggregate_pub_key_shares(self, poly: CKGShare) -> CKGShare:
        out = CKGShare()

        ring_qp = self.crypto_params.params.ring_qp()

        pid = self.pid
        if pid > 0:
            if pid == self.comms.hub_pid:
                out.value = ring_qp.new_poly()

                for p in range(1, self.comms.number_of_parties):
                    new_poly = poly.value
                    if p != pid:
                        new_poly = self.comms.receive_as_jar(p, Poly)
                    ring_qp._mm_add(new_poly, out.value, out.value)
                
                for p in range(1, self.comms.number_of_parties):
                    if p != pid: self.comms.send_as_jar(out.value, p)
                
            else:
                self.comms.send_as_jar(poly.value, self.comms.hub_pid)
                out.value = self.comms.receive_as_jar(self.comms.hub_pid, Poly)

        return out
    
    def collective_pub_key_gen(self, parameters: Parameters, sh_shard: SecretKey, crp_gen: UniformSampler) -> PublicKey:
        sk = sh_shard

        ckg_protocol = new_ckg_protocol(parameters)
        pk_share = ckg_protocol.allocate_share()

        crp = parameters.ring_qp().new_poly()
        crp_gen._mm_read(crp)
        ckg_protocol._mm_gen_share(sk, crp, pk_share)

        pk_agg = self.aggregate_pub_key_shares(pk_share)

        hub_pid = self.comms.hub_pid
        if self.pid == 0: pk_agg.value = self.comms.receive_as_jar(hub_pid, Poly)
        elif self.pid == hub_pid: self.comms.send_as_jar(pk_agg.value, 0)

        pk = new_public_key(parameters)
        ckg_protocol.gen_public_key(pk_agg, crp, pk)

        return pk

    def aggregate_relin_key_share(self, share: RKGShare, second_slot: bool) -> RKGShare:
        pid = self.pid
        context_qp = self.crypto_params.params.ring_qp()
        rns_decomp = len(share.value)
        bit_decomp = len(share.value[0])

        share_out = RKGShare()
        share_out.value = list[list[list[Poly]]](rns_decomp)

        if pid > 0:
            if pid == self.comms.hub_pid:
                # Initialize
                for i in range(rns_decomp):
                    mat = list[list[Poly]](bit_decomp)
                    for j in range(bit_decomp):
                        row = list[Poly](2)
                        row.append(context_qp.new_poly())
                        if second_slot: row.append(context_qp.new_poly())
                        mat.append(row)
                    share_out.value.append(mat)

                # Aggregate
                for p in range(1, self.comms.number_of_parties):
                    for i in range(rns_decomp):
                        for j in range(bit_decomp):
                            if p != pid:
                                other0 = self.comms.receive_as_jar(p, Poly)
                                if second_slot: other1 = self.comms.receive_as_jar(p, Poly)
                            else:
                                other0 = share.value[i][j][0]
                                if second_slot: other1 = share.value[i][j][1]

                            context_qp._mm_add(other0, share_out.value[i][j][0], share_out.value[i][j][0])
                            if second_slot:
                                context_qp._mm_add(other1, share_out.value[i][j][1], share_out.value[i][j][1])

                # Broadcast
                for p in range(1, self.comms.number_of_parties):
                    if p != pid:
                        for i in range(rns_decomp):
                            for j in range(bit_decomp):
                                self.comms.send_as_jar(share_out.value[i][j][0], p)
                                if second_slot: self.comms.send_as_jar(share_out.value[i][j][1], p)
                
            else:
                # Send share
                for i in range(rns_decomp):
                    for j in range(bit_decomp):
                        self.comms.send_as_jar(share.value[i][j][0], self.comms.hub_pid)
                        if second_slot: self.comms.send_as_jar(share.value[i][j][1], self.comms.hub_pid)

                # Receive result
                for i in range(rns_decomp):
                    mat = list[list[Poly]](bit_decomp)
                    for j in range(bit_decomp):
                        row = list[Poly](2)
                        row.append(self.comms.receive_as_jar(self.comms.hub_pid, Poly))
                        if second_slot: row.append(self.comms.receive_as_jar(self.comms.hub_pid, Poly))
                        mat.append(row)
                    share_out.value.append(mat)

        return share_out
    
    def collective_relin_key_gen(self, params: Parameters, sk_shard: SecretKey, crp_gen: UniformSampler) -> RelinearizationKey:
        sk = sk_shard
        ring_qp = params.ring_qp()

        prot = new_rkg_protocol(params)
        eph_sk, share_1, share_2 = prot.allocate_share()

        rns_decomp = len(share_1.value)
        bit_decomp = len(share_1.value[0])

        assert len(share_1.value) == len(share_2.value)
        assert len(share_1.value[0]) == len(share_2.value[0])

        crp = self._mm_gen_crp_matrix(ring_qp, crp_gen, rns_decomp, bit_decomp)
        evk = new_relinearization_key(params)

        if self.pid > 0:
            prot._mm_gen_share_round_one(sk, crp, eph_sk, share_1)
            out_round_1 = self.aggregate_relin_key_share(share_1, True)

            prot._mm_gen_share_round_two(eph_sk, sk, out_round_1, share_2)
            out_round_2 = self.aggregate_relin_key_share(share_2, True)

            prot.gen_relinearization_key(out_round_1, out_round_2, evk)
        
        return evk
    
    def aggregate_rot_key_share(self, share: RTGShare) -> RTGShare:
        rns_decomp, bit_decomp = share.value.shape
        in_share_value = list[list[list[Poly]]](rns_decomp)
        for i in range(rns_decomp):
            in_share_value_row = list[list[Poly]](bit_decomp)
            for j in range(bit_decomp):
                in_share_value_row.append([share.value[i][j]])
            in_share_value.append(in_share_value_row)
        
        in_share = RKGShare(in_share_value)
        out = self.aggregate_relin_key_share(in_share, False).value

        share_out_value = list[list[Poly]](rns_decomp)
        for i in range(rns_decomp):
            share_out_row = list[Poly](bit_decomp)
            for j in range(bit_decomp):
                share_out_row.append(out[i][j][0])
            share_out_value.append(share_out_row)

        return RTGShare(share_out_value)
    
    def collective_rot_key_gen(self, parameters: Parameters, sk_shard: SecretKey,
            crp_gen: UniformSampler, rot_types: list[RotationType]) -> RotationKeySet:
        slots = parameters.slots()
        sk = sk_shard

        shifts = list[int](len(rot_types))
        for rot_type in rot_types:
            shift = 0
            if rot_type.is_right(): shift = slots - rot_type.value
            else: shift = rot_type.value

            shifts.append(shift)

        g_elems = list[u64](len(shifts))

        for k in shifts:
            g_elems.append(parameters.galois_element_for_column_rotation_by(k))

        # Need to sortInt otherwise different parties might have different ordering
        g_elems.sort()

        rot_keys = new_rotation_key_set(parameters.get_rlwe_params(), g_elems)

        if self.pid == 0: return rot_keys

        ring_qp = parameters.ring_qp()
        for gal_el in g_elems:
            
            rtg_protocol = new_rot_kg_protocol(parameters)
            rtg_share = rtg_protocol.allocate_share()

            crp = self._mm_gen_crp_matrix(
                ring_qp, crp_gen, len(rtg_share.value), len(rtg_share.value[0]))

            rtg_protocol._mm_gen_share(sk, gal_el, crp, rtg_share)
            rtg_agg = self.aggregate_rot_key_share(rtg_share)
            rtg_protocol.gen_rotation_key(rtg_agg, crp, rot_keys.keys[gal_el])

        return rot_keys

    def collective_init(self, params: Parameters, prec: u64):
        print(f"CP{self.pid}:\tMHE collective initialization ...")

        kgen = new_key_generator(params)
        ring_qp = params.ring_qp()

        sk_shard = SecretKey()
        if self.pid == 0: sk_shard.value = ring_qp.new_poly()
        else: sk_shard = kgen.gen_secret_key()

        p = ring_qp.new_poly()
        self.crp_gen._mm_read(p)

        print(f"CP{self.pid}:\tMHE generating public key ...")
        pk = self.collective_pub_key_gen(params, sk_shard, self.crp_gen)

        print(f"CP{self.pid}:\tMHE generating relinearization key ...")
        rlk = self.collective_relin_key_gen(params, sk_shard, self.crp_gen)
        
        print(f"CP{self.pid}:\tMHE generating rotation keys ... ")
        rtks = self.collective_rot_key_gen(
            params, sk_shard, self.crp_gen,
            generate_rot_keys(params.slots(), 32, True))

        print(f"CP{self.pid}:\tInitializing MHE ... ")
        self.crypto_params.initialize(sk_shard, pk, rlk, rtks, prec)

        print(f"CP{self.pid}:\tMHE setup complete.")
    
    def precision_stats(self, result, expected) -> PrecisionStats:
        if isinstance(result, ndarray):
            _result = result.tolist()
        elif isinstance(result, ByVal):
            _result = [result]
        else:
            _result = result
        
        if isinstance(expected, ndarray):
            _expected = expected.tolist()
        elif isinstance(expected, ByVal):
            _expected = [expected]
        else:
            _expected = expected
        
        assert _result.shape == _expected.shape, f"Result and expected result shapes mismatch while checking MHE precision: {_result.shape} != {_expected.shape}"
        result_flattened = _result.flatten()
        expected_flattened = _expected.flatten()

        print(f"CP{self.pid}:\tValues computed [0:10]: {result_flattened[:10]} ...\n")
        print(f"CP{self.pid}:\tValues expected [0:10]: {expected_flattened[:10]} ...\n")

        precision_stats = evaluate_precision(result_flattened.to_complex(), expected_flattened.to_complex())
        print(precision_stats)

        return precision_stats
    
    # enc_vector encrypts or encodes a list of values in multiple batched ciphers or plaintexts.
    def enc_vector[T](self, values: list) -> list[T]:
        nbr_max_coef = self.crypto_params.params.slots()
        length = len(values)

        _arr = list[T]((length + nbr_max_coef - 1) // nbr_max_coef)
        elements_enc = 0

        while elements_enc < length:
            start = elements_enc
            end = elements_enc + nbr_max_coef
            if end > length: end = length

            # Encoding values
            plaintext = new_plaintext(
                self.crypto_params.params,
                self.crypto_params.params.max_level(),
                self.crypto_params.params.default_scale)
            self.crypto_params.encoder.encode(
                values[start:end].pad_vec_inplace(nbr_max_coef).to_complex(),
                plaintext,
                self.crypto_params.params.log_slots)

            if isinstance(T, Plaintext): _text = plaintext
            elif isinstance(T, Ciphertext): _text = self.crypto_params.encryptor.encrypt_new(plaintext)
            else: compile_error("Invalid cipher/plaintext type.")
            
            _arr.append(_text)
            elements_enc += (end - start)

        return _arr
    
    def aggregate_decrypt_shares(self, poly: PCKSShare, out_level: int) -> PCKSShare:
        out = PCKSShare()

        pid = self.pid
        if pid > 0:
            if pid == self.comms.hub_pid:

                for _ in range(len(poly.value)):
                    out.value.append(self.crypto_params.params.ring_q.new_poly_lvl(out_level))
                
                for p in range(1, self.comms.number_of_parties):
                    for i in range(len(poly.value)):
                        new_poly = poly[i]
                        if p != pid: new_poly = self.comms.receive_as_jar(p, type(poly[i]))
                        level = len(new_poly._mm_coeffs) - 1
                        self.crypto_params.params.ring_q._mm_add_lvl(level, new_poly, out[i], out[i])
                
                for p in range(1, self.comms.number_of_parties):
                    if p != pid:
                        for i in range(len(poly.value)):
                            self.comms.send_as_jar(out[i], p)
            else:
                for i in range(len(poly.value)):
                    self.comms.send_as_jar(poly[i], self.comms.hub_pid)
                for i in range(len(poly.value)):
                    out.value.append(self.comms.receive_as_jar(self.comms.hub_pid, type(poly[i])))

        return out

    def collective_decrypt(self, ct: Ciphertext, hub_pid: int) -> Plaintext:
        if self.pid == 0:
            return Plaintext()
        
        tmp = ct
        if hub_pid > -1:  # If ct is not already broadcast to all parties
            tmp = self.comms.broadcast_from(ct, hub_pid)
        parameters = self.crypto_params.params

        zero_pk = new_public_key(parameters)

        pcks_protocol = new_pcks_protocol(parameters, 6.36)
        dec_share = pcks_protocol.allocate_share(tmp.level())

        pcks_protocol._mm_gen_share(self.crypto_params.sk_shard, zero_pk, tmp.value[1], dec_share)
        dec_agg = self.aggregate_decrypt_shares(dec_share, tmp.level())

        ciphertext_switched = new_ciphertext(parameters, 1, tmp.level(), tmp.scale)
        pcks_protocol.key_switch(tmp, dec_agg, ciphertext_switched)

        return ciphertext_switched.plaintext()
    
    def decrypt(self, x: list[Ciphertext], mirrored: bool = False) -> list[Plaintext]:
        return self._collective_op(x, MPCHE.collective_decrypt, mirrored)
    
    def rescale(self, x: list[Ciphertext], target_scale: float) -> list[Ciphertext]:
        for cipher in x:
            if cipher.scale > target_scale:
                self.crypto_params.evaluator.rescale(cipher, target_scale, cipher)
                self.stats.secure_rescale_count += 1
        
        return x
    
    def bootstrap(self, x: list[Ciphertext]) -> list[Ciphertext]:
        for cipher in x:
            if cipher.level() == self.bootstrap_min_level:
                self.collective_bootstrap(cipher, self.comms.hub_pid)
        
        return x
    
    def refresh(self, x: list[Ciphertext]) -> list[Ciphertext]:
        if not len(x):
            return x
        
        self.rescale(x, self.crypto_params.params.default_scale)
        self.bootstrap(x)
        
        return x
    
    def iadd(self, x: list, y: list) -> list:
        assert len(x) == len(y), "Ciphervector lenghts differ"
        
        for i in range(len(x)):
			# TODO: Check level
            self.crypto_params.evaluator.add(x[i], y[i], x[i])
        
        return x
    
    def isub(self, x: list, y: list) -> list:
        assert len(x) == len(y), "Ciphervector lenghts differ"
        
        for i in range(len(x)):
			# TODO: Check level
            self.crypto_params.evaluator.sub(x[i], y[i], x[i])
        
        return x
    
    def imul[T](self, x: list[Ciphertext], y: list[T]) -> list[Ciphertext]:
        if not (isinstance(T, Ciphertext) or isinstance(T, Plaintext)):
            compile_error("Invalid cipher type")
        
        assert len(x) == len(y), "Ciphervector lenghts differ"

        if not len(x):
            return x
        
        max_len = max(len(x), len(y))
        relin = True if isinstance(T, Ciphertext) else False

        self.refresh(x)
        if isinstance(T, Ciphertext):
            self.refresh(y)

        for i in range(max_len):
            self.crypto_params.evaluator.mul_relin(x[i], y[i], relin, x[i])
        
        return x
    
    def irotate(self, x: list[Ciphertext], k: int) -> list[Ciphertext]:
        for i in range(len(x)):
            self.crypto_params.evaluator.rotate(x[i], k, x[i])
        
        return x

    def add(self, x: list, y: list) -> list:
        return self.iadd(x.copy(), y)

    def sub(self, x: list, y: list) -> list:
        return self.isub(x.copy(), y)
    
    def mul(self, x: list[Ciphertext], y: list) -> list[Ciphertext]:
        # Check if first operand should be refreshed before copying it downstream
        # Second operand will be checked in imul
        self.refresh(x)
        return self.imul(x.copy(), y)
    
    def rotate(self, x: list[Ciphertext], k: int) -> list[Ciphertext]:
        return self.irotate(x.copy(), k)
    
    def reduce_add(self, x: list[Ciphertext], size: int) -> list[Ciphertext]:
        slots = self.crypto_params.params.slots()
        assert 0 < size, "MPCHE.reduce_add: Invalid number of columns per cipher"

        reduced_cipher = x[0].copy()
        for i in range(1, len(x)):
            self.crypto_params.evaluator.add(reduced_cipher, x[i], reduced_cipher)

        self.crypto_params.evaluator.reduce_add(reduced_cipher, min(slots, size))
        
        reduced_vector = []
        for _ in range(size // slots):
            reduced_vector.append(reduced_cipher.copy())
        
        offset = size % slots
        if offset:
            if size <= (slots >> 1):
                mirror_cipher = self.crypto_params.evaluator.rotate_new(reduced_cipher, slots - size)
                self.crypto_params.evaluator.add(reduced_cipher, mirror_cipher, reduced_cipher)
                
            mask = self.enc_vector([(1.0 if i < offset else 0.0) for i in range(slots)], T=Plaintext)
            self.imul([reduced_cipher], mask)
            reduced_vector.append(reduced_cipher)
        
        return reduced_vector
    
    def drop_level(self, a: list[list[Ciphertext]], out_level: int) -> list[list[Ciphertext]]:
        out = list[list[Ciphertext]](len(a))
        for i in range(len(a)):
            row = list[Ciphertext](len(a[i]))
            for j in range(len(a[i])):
                if a[i][j].level() > out_level:
                    row.append(self.crypto_params.evaluator.drop_level_new(a[i][j], a[i][j].level() - out_level))
                elif a[i][j].level() == out_level:
                    row.append(a[i][j].copy())
                else:
                    raise ValueError(f"DropLevel: requested level {out_level} when input is {a[i][j].level()}")
            out.append(row)
        return out

    def flatten_levels(self, x: list[list[Ciphertext]]) -> tuple[list[list[Ciphertext]], int]:
        min_level = x[0][0].level()
        not_flat = False
        
        for row in x:
            for col in row:
                if col.level() != min_level:
                    min_level = min(col.level(), min_level)
                    not_flat = True

        if not not_flat:
            return x, min_level

        return self.drop_level(x, min_level), min_level

    def aggregate_refresh_share(self, ref_protocol: RefreshProtocol, share: RefreshShare) -> RefreshShare:
        context_q = self.crypto_params.params.ring_q

        # Initialize
        share_out = RefreshShare(
            context_q.new_poly_lvl(share.e2s_share.value.level()),
            context_q.new_poly_lvl(share.s2e_share.value.level()))

        if self.pid > 0:
            if self.pid == self.comms.hub_pid:
                # Aggregate
                for p in range(1, self.comms.number_of_parties):
                    other = share
                    if p != self.pid: other = self.comms.receive_as_jar(p, RefreshShare)
                    ref_protocol.aggregate_shares(other, share_out, share_out)

                # Broadcast
                for p in range(1, self.comms.number_of_parties):
                    if p != self.pid: self.comms.send_as_jar(share_out, p)
            
            else:
                # Send share
                self.comms.send_as_jar(share, self.comms.hub_pid)

                # Receive result
                share_out = self.comms.receive_as_jar(self.comms.hub_pid, RefreshShare)

        return share_out

    def collective_bootstrap(self, ct: Ciphertext, hub_pid: int):
        self.stats.secure_bootstrap_count += 1
        
        if self.pid == 0:
            return

        if not self.comms.is_broadcast(ct):
            ct = self.comms.broadcast_from(ct, hub_pid)

        parameters = self.crypto_params.params
        level_start = ct.level()

        assert (self.boostrap_safe and
                self.bootstrap_min_level <= level_start and
                self.bootstrap_min_level < parameters.max_level()
                ), f"Bootstrapping: Not enough levels to ensure correctness and 128 security.\n\tCurrent cipher level {level_start}.\n\tMin required level {self.bootstrap_min_level}.\n\tMax possible level for the selected parameters: {parameters.max_level()}\n"

        ref_protocol = new_refresh_protocol(parameters, 256, 6.36)
        ref_share = ref_protocol.allocate_share(level_start, parameters.max_level())
        crp = self.crp_gen._mm_read_new(parameters).q

        ref_protocol.gen_share(
            self.crypto_params.sk_shard,
            self.bootstrap_log_bound,
            parameters.log_slots,
            ct.value[1],
            ct.scale,
            crp,
            ref_share)
        
        ref_agg = self.aggregate_refresh_share(ref_protocol, ref_share)
        ref_protocol.finalize(ct, parameters.log_slots, crp, ref_agg, ct)
    
    def cipher_to_additive_plaintext(self, ct: Ciphertext, hub_pid: int) -> AdditiveShareBigint:
        parameters = self.crypto_params.params
        
        if self.pid == 0:
            return new_additive_share_bigint(parameters, parameters.log_slots)

        ct = self.comms.broadcast_from(ct, hub_pid)

        level_start = ct.level()

        assert (self.boostrap_safe and
                self.bootstrap_min_level <= level_start and
                self.bootstrap_min_level < parameters.max_level()
                ), f"E2S: Not enough levels to ensure correctness and 128 security.\n\tCurrent cipher level {level_start}.\n\tMin required level {self.bootstrap_min_level}.\n\tMax possible level for the selected parameters: {parameters.max_level()}\n"
        
        self.crypto_params.evaluator.drop_level(ct, ct.level() - self.bootstrap_min_level - 1)

        e2s_protocol = new_e2s_protocol(parameters, 3.2)
        public_e2s_share = e2s_protocol.allocate_share(level_start)
        secret_share = new_additive_share_bigint(parameters, parameters.log_slots)
        
        e2s_protocol.gen_share(
            self.crypto_params.sk_shard,
            self.bootstrap_log_bound,
            parameters.log_slots,
            ct.value[1],
            secret_share,
            public_e2s_share)
        
        if self.pid == hub_pid:
            for p in range(1, self.comms.number_of_parties):
                if p != hub_pid:
                    e2s_protocol._mm_aggregate_shares(public_e2s_share, self.comms.receive_as_jar(p, CKSShare), public_e2s_share)

            # sum(-M_i) + x
            e2s_protocol.get_share(secret_share, public_e2s_share, parameters.log_slots, ct, secret_share)
        else: self.comms.send_as_jar(public_e2s_share, hub_pid)
        
        return secret_share
    
    def additive_plaintext_to_cipher(self, secret_share: AdditiveShareBigint, hub_pid: int) -> Ciphertext:
        parameters = self.crypto_params.params
        cipher_level = parameters.max_level()

        assert (self.boostrap_safe and
                self.bootstrap_min_level <= cipher_level and
                self.bootstrap_min_level < parameters.max_level()
                ), f"E2S: Not enough levels to ensure correctness and 128 security.\n\tCurrent cipher level {cipher_level}.\n\tMin required level {self.bootstrap_min_level}.\n\tMax possible level for the selected parameters: {parameters.max_level()}\n"

        crp = self.crp_gen._mm_read_new(parameters).q
        s2e_protocol = new_s2e_protocol(parameters, 3.2)
        public_s2e_share = s2e_protocol.allocate_share(cipher_level)

        s2e_protocol.gen_share(
            self.crypto_params.sk_shard,
            crp,
            parameters.log_slots,
            secret_share,
            public_s2e_share)
        
        if self.pid == hub_pid:
            for p in range(1, self.comms.number_of_parties):
                if p != hub_pid:
                    s2e_protocol._mm_aggregate_shares(public_s2e_share, self.comms.receive_as_jar(p, CKSShare), public_s2e_share)
        else: self.comms.send_as_jar(public_s2e_share, hub_pid)

        ct_rec = new_ciphertext(parameters, 1, cipher_level, parameters.default_scale)
        if self.pid == hub_pid:
            s2e_protocol.get_encryption(public_s2e_share, crp, ct_rec)
        
        return ct_rec
    
    def decode_vector[DTP=complex](self, enc: list[Plaintext]) -> list[DTP]:
        data_decoded = []

        for plaintext in enc:
            val = self.crypto_params.encoder.decode(plaintext, self.crypto_params.params.log_slots)
            if isinstance(DTP, int):
                data_decoded.extend([int(round(float(c))) for c in val])
            else:
                data_decoded.extend([DTP(c) for c in val])

        return data_decoded
    
    def _mm_gen_crp_matrix(
            self, ring_qp: Ring, crp_gen: UniformSampler,
            rows: int, cols: int) -> list[list[Poly]]:
        crp = list[list[Poly]](rows)
        
        for _ in range(rows):
            row = list[Poly](cols)
            for _ in range(cols):
                p = ring_qp.new_poly()
                crp_gen._mm_read(p)
                row.append(p)
            crp.append(row)
        
        return crp

    def zero_cipher(self) -> Ciphertext:
        ct = new_ciphertext(
            params=self.crypto_params.params,
            degree=1,
            level=self.crypto_params.params.max_level(),
            scale=self.crypto_params.params.default_scale)
        self.crypto_params.encryptor._mm_encrypt_zero(ct.get_rlwe_ciphertext())
        return ct

    def aggregate_cipher_vector(self, ciphervector: List[Ciphertext]) -> List[Ciphertext]:
        if self.pid == 0: return []

        if self.pid == self.comms.hub_pid:
            # receive and add
            out = ciphervector.copy()
            for p in range(1, self.comms.number_of_parties):
                if p != self.pid:
                    out = self.add(out, self.comms.receive_as_jar(p, List[Ciphertext]))

            for p in range(1, self.comms.number_of_parties):
                if p != self.pid:
                    self.comms.send_as_jar(out, p)
        else:
            self.comms.send_as_jar(ciphervector, self.comms.hub_pid)
            out = self.comms.receive_as_jar(self.comms.hub_pid, List[Ciphertext])

        return out

    def aggregate_refresh_share_vec(self, share: List[ring_Poly], out_level: int) -> List[ring_Poly]:
        context_q = self.crypto_params.params.ring_q
        share_out = []
        
        if self.pid > 0:
            if self.pid == self.comms.hub_pid:
                # Initialize
                for i in range(len(share)):
                    share_out.append(context_q.new_poly_lvl(out_level))

                # Aggregate
                for p in range(1, self.comms.number_of_parties):
                    if p != self.pid: other = self.comms.receive_as_jar(p, List[ring_Poly])
                    else: other = share

                    for i in range(len(share)):
                        context_q._mm_add_lvl(len(other[i]._buf_coeffs) - 1, other[i], share_out[i], share_out[i])

                # Broadcast
                for p in range(1, self.comms.number_of_parties):
                    if p != self.pid:
                        self.comms.send_as_jar(share_out, p)

            else:
                # Send share
                self.comms.send_as_jar(share, self.comms.hub_pid)
                # Receive result
                share_out = self.comms.receive_as_jar(self.comms.hub_pid, List[ring_Poly])

        return share_out

    def additive_share_vector_to_ciphervector(self, shared_vector: List[int_t], modulus: int_t) -> List[Ciphertext]:
        self.stats.secure_mhe_mpc_switch_count += 1
        if self.pid == 0: return []

        # mask = shared_vector.rand(modulus)
        # shared_matrix_mask = self.comms.reveal(shared_vector.copy() - mask, modulus)
        # share = (shared_matrix_mask + mask) if self.pid == self.comms.hub_pid else mask
        # return self.aggregate_cipher_vector(self.enc_vector(values, T=Ciphertext))
        
        # Temp non-secure solution
        revealed_share = self.comms.reveal(shared_vector, modulus)
        values = fp_to_double(revealed_share, modulus)
        return self.enc_vector(values, T=Ciphertext)

    def ciphervector_to_additive_share_vector[dtype](self, ciphervector: List[Ciphertext], number_of_elements: int, modulus: int_t) -> List[int_t]:
        self.stats.secure_mhe_mpc_switch_count += 1
        # slots = self.crypto_params.params.slots()
        # shared_vector = zeros_vec(number_of_elements)
        # if self.pid == 0: return shared_vector

        # if hub_pid > 0:
        #     ciphervector = self.comms.collect(ciphervector, hub_pid)

        # ciphermatrix, level_start = self.flatten_levels([ciphervector])
        # ciphervector = ciphermatrix[0]

        # params = self.crypto_params.params
        # ring_q = params.ring_q

        # share_decrypt = [params.ring_q.new_poly_lvl(level_start) for _ in range(len(ciphervector))]
        
        # self.randomness.switch_seed(-1)
        # seed = u32(prg.getrandbits(32))
        # self.randomness.restore_seed(-1)
        # sampler = new_gaussian_sampler(new_prng(seed), ring_q, 3.19, 19)

        # pt_mask = []
        # for k in range(len(ciphervector)):
        #     # h0 = mask (at level min)
        #     share_decrypt[k].randomize(ring_q.modulus[level_start])
        #     ring_q._mm_ntt_lvl(level_start, share_decrypt[k], share_decrypt[k])
        #     pt_mask.append(Plaintext(share_decrypt[k].copy(), ciphervector[0].scale))

        #     # h0 = sk*c1 + mask
        #     ring_q._mm_mul_coeffs_montgomery_and_add_lvl(level_start, self.crypto_params.sk_shard.value.q, ciphervector[k].value[1], share_decrypt[k])

        #     # h0 = sk*c1 + mask + e0
        #     tmp = sampler._mm_read_new()
        #     ring_q._mm_ntt_lvl(level_start, tmp, tmp)
            
        #     ring_q._mm_add_lvl(level_start, share_decrypt[k], tmp, share_decrypt[k])

        # # TODO: communicate in one batch
        # agg = self.aggregate_refresh_share_vec(share_decrypt, level_start)

        # pt = []
        # for i in range(len(ciphervector)):
        #     ct_out = ciphervector[i].copy()
        #     ring_q._mm_add_lvl(level_start, ct_out.value[0], agg[i], ct_out.value[0])

        #     pt.append(ct_out.plaintext())

        # for i in range(len(pt)):
        #     rv_out = zeros_vec(slots, TP=complex)
        #     if self.pid == self.comms.hub_pid:
        #         rv_out = self.crypto_params.encoder.decode(pt[i], self.crypto_params.params.log_slots)

        #     rv_mask = self.crypto_params.encoder.decode(pt_mask[i], self.crypto_params.params.log_slots)
        #     rv_out -= rv_mask

        #     rv_out_shared = double_to_fp([e.real for e in rv_out], modulus)

        #     start = i * slots
        #     end = start + slots
        #     if end > number_of_elements: end -= number_of_elements
        #     else: end = slots

        #     shared_vector.extend(rv_out_shared.slice_reference(0, end))

        # return shared_vector

        # Temp non-secure solution:
        if self.pid == 0:
            return zeros_vec(number_of_elements, TP=type(modulus))
        
        decrypted_vector = self.decrypt(ciphervector, mirrored=True)
        if self.pid == self.comms.hub_pid:
            decoded_values = self.decode_vector(decrypted_vector, DTP=dtype)
            if isinstance(dtype, float):
                return double_to_fp(decoded_values, modulus)
            elif isinstance(dtype, int):
                return decoded_values.to_int_t(modulus)
            else:
                compile_error("Invalid type in ciphervector to additive share vector switch")
        return zeros_vec(number_of_elements, TP=type(modulus))

    def mask_one[T](self, x: T, idx: int, complement: bool = False) -> T:
        slots = self.crypto_params.params.slots()
        
        if isinstance(T, Plaintext) or isinstance(T, list[Plaintext]):
            compile_error("Not implemented yet: masking plaintext")
        elif isinstance(T, Ciphertext):
            assert idx < slots, "MPCHE: idx out of bound"

            mask = self.enc_vector(one_hot_vector(idx, slots, complement, TP=float), T=Ciphertext)
            return self.mul([x], mask)[0]
        elif isinstance(T, list[Ciphertext]):
            target_cipher_idx = idx // slots
            target_cipher = x[target_cipher_idx]
            masked_cipher = self.mask_one(target_cipher, idx % slots, complement)
            if len(x) > 1:
                fill_cipher = self.enc_vector(ones_vec(slots, TP=float), T=Ciphertext)[0] if complement else self.zero_cipher()
            return [(fill_cipher.copy() if i != target_cipher_idx else masked_cipher) for i in range(len(x))]
        else:
            compile_error("Invalid input to mask")
    
    def _collective_op(self, x: list[Ciphertext], collective_op, mirrored: bool = False):
        if mirrored or self.pid == 0:
            return [collective_op(self, cipher, -1) for cipher in x]
        
        collection = self.comms.collect(x)
        plain_vectors = [
            [collective_op(self, cipher, pid) for cipher in collection[pid - 1]]
            for pid in range(1, self.comms.number_of_parties)]
        
        return plain_vectors[self.pid - 1]
