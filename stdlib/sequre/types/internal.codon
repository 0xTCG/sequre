import prg

from helpers import argmin

from shared_tensor import SharedTensor
from cipher_tensor import CipherTensor
from multiparty_partition import MPP
from utils import double_to_fp

from ..stdlib.fp import fp_div, fp_sqrt
from ..utils.param import int_t, DEBUG


TP = int_t


@extend
class SharedTensor:
    def to_mhe(self, mpc):
        ciphervector = mpc.he.additive_share_vector_to_ciphervector(self.share.flatten(), self.modulus)
        return CipherTensor(ciphervector, self.shape(), mpc.he.crypto_params.params.slots())

    def to_mpp[S, dtype](self, mpc, ratios: list[int]):
        return self.to_mhe(mpc).to_mpp(mpc, ratios, self.modulus, S=S, dtype=dtype)


@extend
class CipherTensor:
    def to_mpc(self, mpc, source_pid, modulus):
        share = mpc.he.ciphervector_to_additive_share_vector(self._data, source_pid, self.shape.reduce_mul(), modulus).reshape(self.shape)
        return SharedTensor(share, modulus)
    
    def to_mpp[S, dtype](self, mpc, ratios: list[int], modulus: int_t):
        n = self.shape[0]
        s = ratios.sum()
        assert n % s == 0, "CipherTensor: Cannot distribute partitions by the given proportion"
        
        reference_pid = mpc.pid - 1  # Avoid CP0
        k = n // s
        start = ratios[:reference_pid].sum() * k

        return MPP[S, dtype](
            modulus=modulus,
            _encryption_unified=self[start:start + ratios[reference_pid] * k])


@extend
class MPP:
    def to_mpc(self, mpc) -> SharedTensor:
        return self.collect_at(mpc, mpc.comms.hub_pid).to_mpc(mpc, mpc.comms.hub_pid, self.modulus)


class InternalMPC:
    def evalp(mpc, x_, coefs_, exps_):
        assert isinstance(x_, SharedTensor), "Secure polynomial evaluation is enabled only for SharedTensor"
        
        x_r = []
        r = []

        for sn in x_:
            x_r_, r_ = sn.get_partitions(mpc, force=False)
            x_r.append(x_r_)
            r.append(r_)

        coefs = [int_t(coefs_[i])
                    for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        result = mpc.polynomial._beaver_evaluate_poly(
            x_r, r, coefs, exps, x_[0].modulus)
        sv = SharedTensor(result, x_[0].modulus)
        sv.fp = x_[0].is_fp()
        
        # TODO: #23 Handle sqrts and partitions

        return sv

    def add(mpc, x, y):
        if isinstance(x, float):
            return InternalMPC.__add_public(mpc, x.to_fp(y.modulus), y, False)
        elif isinstance(y, float):
            return InternalMPC.__add_public(mpc, y.to_fp(x.modulus), x, False)
        elif isinstance(x, int):
            return InternalMPC.__add_public(mpc, x.to_fp(y.modulus) if y.fp else int_t(x), y, False)
        elif isinstance(y, int):
            return InternalMPC.__add_public(mpc, y.to_fp(x.modulus) if x.fp else int_t(y), x, False)
        elif isinstance(x, SharedTensor[list[list[int_t]]]) and isinstance(y, SharedTensor[list[int_t]]):
            return x.broadcast_add(y)
        elif isinstance(x, SharedTensor[list[int_t]]) and isinstance(y, SharedTensor[int_t]):
            return x.broadcast_add(y)
        else:
            if not x.is_public() and not y.is_public():
                return x + y
            elif x.is_public():
                return InternalMPC.__add_public(mpc, x.share, y, x.diagonal)
            elif y.is_public():
                return InternalMPC.__add_public(mpc, y.share, x, y.diagonal)

            raise ValueError("Invalid type of addends in secure add")

    def sub(mpc, x, y):
        if isinstance(x, float):
            return InternalMPC.__add_public(mpc, x.to_fp(y.modulus), -y, False)
        elif isinstance(y, float):
            return InternalMPC.__add_public(mpc, (-y).to_fp(x.modulus), x, False)
        elif isinstance(x, int):
            return InternalMPC.__add_public(mpc, x.to_fp(y.modulus) if y.fp else int_t(x), -y, False)
        elif isinstance(y, int):
            return InternalMPC.__add_public(mpc, (-y).to_fp(x.modulus) if x.fp else (x.modulus - y), x, False)
        elif isinstance(x, SharedTensor[list[list[int_t]]]) and isinstance(y, SharedTensor[list[int_t]]):
            return x.broadcast_add(-y)
        elif isinstance(x, SharedTensor[list[int_t]]) and isinstance(y, SharedTensor[int_t]):
            return x.broadcast_add(-y)
        else:
            if not x.is_public() and not y.is_public():
                return x + (-y)
            elif x.is_public():
                return InternalMPC.__add_public(mpc, x.share, -y, x.diagonal)
            elif y.is_public():
                return InternalMPC.__add_public(mpc, y.share.neg_mod(x.modulus), x, y.diagonal)

            raise ValueError("Invalid type of addends in sub")

    def mul(mpc, x, y):
        if isinstance(y, float):
            y_fp = double_to_fp(y, x.modulus)
            sv = x * y_fp
            # TODO: #117 Implement clever joint truncations pattern matcher
            if x.is_fp(): sv = sv.trunc(mpc.fp)
            sv.fp = True
            return sv
        else:
            if x.public or y.public:
                c_share = x.share.mul_mod(y.share, x.modulus if y.public else y.modulus)
                sv = SharedTensor(c_share, x.modulus if y.public else y.modulus)
                sv.fp = x.is_fp() or y.is_fp()
                return sv
            
            if DEBUG: assert x.modulus == y.modulus, f"Non-matching moduli for factors: {x.modulus} != {y.modulus}"
            modulus = x.modulus

            x_1_r, r_1 = x.get_partitions(mpc, force=False)
            x_2_r, r_2 = y.get_partitions(mpc, force=False)

            c = mpc.arithmetic.__beaver_mul(x_1_r, r_1, x_2_r, r_2, modulus)
            c = mpc.arithmetic.__beaver_reconstruct(c, modulus)

            if x.is_fp() and y.is_fp():
                c = mpc.fp.trunc(c, modulus)
            
            sv = SharedTensor(c, modulus)
            sv.fp = x.is_fp() or y.is_fp()

            # TODO: #23 Efficiently calculate beaver partitions of c here
            # Bellow is temp dirty solution for beaver partitioning which should be both:
            # - Computed with less network overhead
            # - Computed only if compiler figures out that partitions will be needed downstream
            # sv.set_partitions(mpc.arithmetic.__beaver_partition(sv.share, modulus))

            # TODO: #23 Check if there is a better way to do this
            # if x.sqrt and y.sqrt:
            #     sv.sqrt = mpc.arithmetic.multiply(x.sqrt, y.sqrt, modulus)
            #     sv.sqrt = mpc.fp.trunc(sv.sqrt, modulus)
            #     sv.sqrt_inv = mpc.arithmetic.multiply(x.sqrt_inv, y.sqrt_inv, modulus)
            #     sv.sqrt_inv = mpc.fp.trunc(sv.sqrt_inv, modulus)
            return sv

    def pow(mpc, x_, p):
        modulus = x_.modulus

        if x_.is_fp():
            # TODO: #58 Implement efficient pows calculation for FPs
            x_pow = x_
            for _ in range(p - 1): x_pow = InternalMPC.mul(mpc, x_pow, x_)
            return x_pow

        x_r, r = x_.get_partitions(mpc, force=False)
        c = mpc.polynomial.powers_cached(x_r, r, p, modulus)[p]
        
        sv = SharedTensor(c, modulus)
        sv.fp = x_.is_fp()

        # TODO: #23 Efficiently calculate beaver partitions of c here
        # TODO: #23 Check if there is a way to calculate cached sqrts efficiently
        return sv

    def div(mpc, x, y):
        # TODO: #26 Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(x, int) or isinstance(x, float):
            if isinstance(y.share, list):
                sv = SharedTensor([double_to_fp(float(x), y.modulus) for _ in range(len(y.share))], y.modulus)
                return fp_div(mpc, sv, y)
            else:
                sv = SharedTensor(double_to_fp(float(x), y.modulus), y.modulus)
                return fp_div(mpc, sv, y)
        elif isinstance(y, float) or isinstance(y, int):
            sv = x * double_to_fp(1.0 / y, x.modulus)
            if x.is_fp(): sv = sv.trunc(mpc.fp)
            return sv
        else:
            # TODO: Efficiently calculate beaver partitions of sv here
            return fp_div(mpc, x, y)
    
    def gt(mpc, x, y):
        # TODO: #26 Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(y, int) or isinstance(y, TP):
            modulus = x.modulus
            if y == 0:
                return SharedTensor(mpc.boolean.is_positive(x.share, modulus), modulus)

            return SharedTensor(mpc.boolean.greater_than_public(x.share, TP(y), modulus), modulus)
        elif isinstance(y, float):
            modulus = x.modulus
            return SharedTensor(mpc.boolean.greater_than_public(x.to_fp().share, double_to_fp(y, modulus), modulus), modulus)
        else:
            if DEBUG: assert x.modulus == y.modulus
            modulus = x.modulus
            return SharedTensor(mpc.boolean.greater_than(x.share, y.share, modulus), modulus)
        
        # TODO: Efficiently calculate beaver partitions of sv here

    def lt(mpc, x, y):
        # TODO: #26 Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if isinstance(y, int) or isinstance(y, TP):
            modulus = x.modulus
            if y == 0:
                return SharedTensor(mpc.boolean.is_positive(x.share.neg_mod(modulus), modulus), modulus)
            
            return SharedTensor(mpc.boolean.less_than_public(x.share, TP(y), modulus), modulus)
        elif isinstance(y, float):
            modulus = x.modulus
            return SharedTensor(mpc.boolean.less_than_public(x.to_fp().share, double_to_fp(y, modulus), modulus), modulus)
        else:
            if DEBUG: assert x.modulus == y.modulus
            modulus = x.modulus
            return SharedTensor(mpc.boolean.less_than(x.share, y.share, modulus), modulus)
        
        # TODO: #23 Efficiently calculate beaver partitions of sv here
    
    def eq(mpc, x, y):
        if x.modulus.popcnt() == 1:
            # TODO: #158 Make comparisons stable on rings.
            l = InternalMPC.gt(mpc, InternalMPC.sub(mpc, x, y), 0)
            r = InternalMPC.gt(mpc, InternalMPC.sub(mpc, y, x), 0)
            return InternalMPC.sub(mpc, 1, InternalMPC.add(mpc, l, r))

        sub = InternalMPC.sub(mpc, x, y)
        is_pos = InternalMPC.gt(mpc, InternalMPC.mul(mpc, sub, sub), 0)
        return InternalMPC.sub(mpc, 1, is_pos)

    def sqrt_inv(mpc, x, y):
        # TODO: #26 Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        
        if not y.sqrt_inv:
            s, sinv = fp_sqrt(mpc, y)
            y.sqrt, y.sqrt_inv = s.share, sinv.share
        
        if isinstance(x, int):
            sv = SharedTensor(y.sqrt_inv, y.modulus)
            sv.fp = True
            # TODO: #23 Efficiently calculate beaver partitions of c here
            # Bellow is temp dirty solution for beaver partitioning which should be both:
            # - Computed with less network overhead
            # - Computed only if compiler figures out that partitions will be needed downstream
            # sv.set_partitions(mpc.arithmetic.__beaver_partition(sv.share, modulus))
            return sv * x
        else:
            if DEBUG: assert x.modulus == y.modulus
            modulus = x.modulus
            
            x_1_r, r_1 = x.get_partitions(mpc, force=False)
            x_2_r, r_2 = mpc.arithmetic.__beaver_partition(y.sqrt_inv, modulus)
            
            c = mpc.arithmetic.__beaver_mul(x_1_r, r_1, x_2_r, r_2, modulus)
            c = mpc.arithmetic.__beaver_reconstruct(c, modulus)
            if x.is_fp():
                c = mpc.fp.trunc(c, modulus)
            
            sv = SharedTensor(c, modulus)
            sv.fp = True
            # TODO: #23 Efficiently calculate beaver partitions of c here
            # Bellow is temp dirty solution for beaver partitioning which should be both:
            # - Computed with less network overhead
            # - Computed only if compiler figures out that partitions will be needed downstream
            # sv.set_partitions(mpc.arithmetic.__beaver_partition(sv.share, modulus))
            
            return sv

    def dot(mpc, x, y):
        if DEBUG: assert x.modulus == y.modulus
        modulus = x.modulus

        x_1_r, r_1 = x.get_partitions(mpc, force=False)
        x_2_r, r_2 = y.get_partitions(mpc, force=False)

        c = mpc.arithmetic.__beaver_dot_prod(x_1_r, r_1, x_2_r, r_2, modulus)
        c = mpc.arithmetic.__beaver_reconstruct(c, modulus)

        if x.is_fp() and y.is_fp():
            c = mpc.fp.trunc(c, modulus)
        
        sv = SharedTensor(c, modulus)
        sv.fp = x.is_fp() or y.is_fp()
        # TODO: #23 Efficiently calculate beaver partitions of sv here
        # Bellow is temp dirty solution for beaver partitioning which should be both:
        # - Computed with less network overhead
        # - Computed only if compiler figures out that partitions will be needed downstream
        # sv.set_partitions(mpc.arithmetic.__beaver_partition(sv.share, modulus))
        
        return sv

    def dot(mpc, x):
        return InternalMPC.dot(mpc, x, x)

    def matmul(mpc, x, y):
        if DEBUG: assert x.modulus == y.modulus
        modulus = x.modulus

        x_1_r, r_1 = x.get_partitions(mpc, force=False)
        x_2_r, r_2 = y.get_partitions(mpc, force=False)

        c = mpc.arithmetic.__beaver_matmul(x_1_r, r_1, x_2_r, r_2, modulus)
        c = mpc.arithmetic.__beaver_reconstruct(c, modulus)

        if x.is_fp() and y.is_fp():
            c = mpc.fp.trunc(c, modulus)
        
        sv = SharedTensor(c, modulus)
        sv.fp = x.is_fp() or y.is_fp()

        # TODO: #23 Efficiently calculate beaver partitions of sv here
        # Bellow is temp dirty solution for beaver partitioning which should be both:
        # - Computed with less network overhead
        # - Computed only if compiler figures out that partitions will be needed downstream
        # sv.set_partitions(mpc.arithmetic.__beaver_partition(sv.share, modulus))
        
        # TODO: #23 Check if there is a better way to do this
        # if x.sqrt and y.sqrt:
        #     sv.sqrt = mpc.arithmetic.multiply(x.sqrt, y.sqrt, modulus)
        #     sv.sqrt = mpc.fp.trunc(sv.sqrt, modulus)
        #     sv.sqrt_inv = mpc.arithmetic.multiply(x.sqrt_inv, y.sqrt_inv, modulus)
        #     sv.sqrt_inv = mpc.fp.trunc(sv.sqrt_inv, modulus)
        
        return sv

    def sqrt(mpc, x):
        # TODO: #26 Currently does not work for complex algebraic structures.
        # Resolve issue #26 and change code below in order to fix this.
        if not x.sqrt:
            s, sinv = fp_sqrt(mpc, x)
            x.sqrt, x.sqrt_inv = s.share, sinv.share
        
        sv = SharedTensor(x.sqrt, x.modulus)
        sv.fp = True
        # TODO: #23 Efficiently calculate beaver partitions of sv here
        return sv

    def broadcast(mpc, value):
        value.share = mpc.comms.broadcast(value.share, value.modulus)
        value.public = True
        return value

    def dist(mpc, shape, name, modulus, params):
        if name == 'normal':
            rows, cols = shape
            gaussian = [[double_to_fp(prg.gauss(*params), modulus) if mpc.pid == 0 else TP(0)
                        for _ in range(cols)] for _ in range(rows)]
            gaussian = mpc.comms.share(gaussian, modulus)

            stensor = SharedTensor(gaussian, modulus)
            stensor.fp = True

            return stensor

        raise NotImplementedError(f'Distribution {name} not implemented yet.')
    
    def __add_public(mpc, x_public, y, diagonal):
        share = y.share
        modulus = y.modulus

        if isinstance(share, list[list]) and isinstance(x_public, list[list]):
            if diagonal:
                for i in range(len(share)):
                    share[i][i] = mpc.arithmetic.add_public(share[i][i], x_public[i][i], modulus)
            else: share = mpc.arithmetic.add_public(share, x_public, modulus)
        else: share = mpc.arithmetic.add_public(share, x_public, modulus)
        
        sv = SharedTensor(share, modulus)
        sv.fp = y.fp

        if y.sqrt:
            sv.sqrt = type(share)(0)
            sv.sqrt_inv = type(share)(0)
        
        if not y.is_partitioned():
            return sv
        
        sv.x_r = y.x_r.add_mod(x_public, modulus)
        sv.r = y.r

        return sv        


class InternalMHE:
    def add(mpc, x, y):
        return x.add(mpc, y)

    def sub(mpc, x, y):
        return x.sub(mpc, y)
    
    def mul(mpc, x, y):
        return x.mul(mpc, y)

    def matmul(mpc, x, y):
        return x.matmul(mpc, y)
    
    def gt(mpc, x, y):
        if isinstance(x, CipherTensor): x_shared = x.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: x_shared = x
        
        if isinstance(y, CipherTensor): y_shared = y.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: y_shared = y
        
        return InternalMPC.gt(mpc, x_shared, y_shared).to_mhe(mpc)

    def lt(mpc, x, y):
        if isinstance(x, CipherTensor): x_shared = x.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: x_shared = x
        
        if isinstance(y, CipherTensor): y_shared = y.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: y_shared = y
        
        return InternalMPC.lt(mpc, x_shared, y_shared).to_mhe(mpc)

    def eq(mpc, x, y):
        return x == y


class InternalMPP:
    def add(mpc, x, y):
        return x._do_elem_wise_op(mpc, y, MPP._elem_wise_add)

    def sub(mpc, x, y):
        return x._do_elem_wise_op(mpc, y, MPP._elem_wise_sub)
    
    def mul(mpc, x, y):
        return x._do_elem_wise_op(mpc, y, MPP._elem_wise_mul)

    def matmul(mpc, x, y):
        return MPP.matmul(mpc, x, y)
    
    def gt(mpc, x, y):
        if isinstance(x, MPP): x_shared = x.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: x_shared = x
        
        if isinstance(y, MPP): y_shared = y.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: y_shared = y
        
        return InternalMPC.gt(mpc, x_shared, y_shared).to_mpp(mpc, ratios=x._ratios, S=x.S, dtype=x.dtype)

    def lt(mpc, x, y):
        if isinstance(x, MPP): x_shared = x.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: x_shared = x
        
        if isinstance(y, MPP): y_shared = y.to_mpc(mpc, mpc.comms.hub_pid, mpc.base_modulus)
        else: y_shared = y
        
        return InternalMPC.lt(mpc, x_shared, y_shared).to_mpp(mpc, ratios=x._ratios, S=x.S, dtype=x.dtype)

    def eq(mpc, x, y):
        return x._do_elem_wise_op(mpc, y, MPP._elem_wise_eq)


class Internal:
    def secure_add(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.add(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.add(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.add(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def secure_sub(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.sub(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.sub(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.sub(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def secure_mul(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.mul(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.mul(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.mul(mpc, x, y)
        else: compile_error("Invalid secure operands")
    
    def secure_matmul(mpc, x, y):
        return Internal.matmul(mpc, x, y)

    def secure_pow(mpc, x_, p):
        if isinstance(x_, SharedTensor):
            return InternalMPC.pow(mpc, x_, p)
        elif isinstance(x_, CipherTensor):
            return InternalMHE.pow(mpc, x_, p)
        else: compile_error("Invalid secure operands")

    def secure_div(mpc, x, y):
        if isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.div(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.div(mpc, x, y)
        else: compile_error("Invalid secure operands")
    
    def secure_gt(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.gt(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.gt(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.gt(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def secure_lt(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.lt(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.lt(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.lt(mpc, x, y)
        else: compile_error("Invalid secure operands")
    
    def secure_eq(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.eq(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.eq(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.eq(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def secure_sqrt_inv(mpc, x, y):
        assert isinstance(x, SharedTensor) or isinstance(y, SharedTensor), "Secure sqrt inverse computing is enabled only for MPC"
        return InternalMPC.sqrt_inv(mpc, x, y)
    
    def secure_evalp(mpc, x_, coefs_, exps_):
        assert isinstance(x_, SharedTensor), "Secure polynomial evaluation is enabled only for SharedTensor"
        return InternalMPC.evalp(mpc, x_, coefs_, exps_)

    def dot(mpc, x, y):
        if isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.dot(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.dot(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def dot(mpc, x):
        if isinstance(x, SharedTensor):
            return InternalMPC.dot(mpc, x)
        elif isinstance(x, CipherTensor):
            return InternalMHE.dot(mpc, x)
        else: compile_error("Invalid secure operands")

    def matmul(mpc, x, y):
        if isinstance(x, MPP) or isinstance(y, MPP):
            return InternalMPP.matmul(mpc, x, y)
        elif isinstance(x, SharedTensor) or isinstance(y, SharedTensor):
            return InternalMPC.matmul(mpc, x, y)
        elif isinstance(x, CipherTensor) or isinstance(y, CipherTensor):
            return InternalMHE.matmul(mpc, x, y)
        else: compile_error("Invalid secure operands")

    def sqrt(mpc, x):
        if isinstance(x, SharedTensor):
            return InternalMPC.sqrt(mpc, x)
        elif isinstance(x, CipherTensor):
            return InternalMHE.sqrt(mpc, x)
        else: compile_error("Invalid secure operands")

    def broadcast(mpc, value):
        if isinstance(value, SharedTensor):
            return InternalMPC.broadcast(mpc, value)
        elif isinstance(value, CipherTensor):
            return InternalMHE.broadcast(mpc, value)
        else: compile_error("Invalid secure operands")

    def min_cost_router(new_vars, cost_vars):
        return new_vars[argmin(cost_vars)]
