from math import ceil, log2, sqrt

from ..lattiseq.rlwe import \
    SecretKey, \
    PublicKey, \
    RelinearizationKey, \
    RotationKeySet, \
    EvaluationKey
from ..lattiseq.ckks import \
    Parameters, \
    EncoderComplex128, \
    PkEncryptor, \
    Decryptor, \
    Evaluator, \
    new_evaluator, \
    new_encoder_complex, \
    new_encryptor, \
    new_decryptor



# CryptoParams aggregates all ckks scheme information
class CryptoParams:
    sk: SecretKey
    aggregate_sk: SecretKey
    pk: PublicKey
    rlk: RelinearizationKey
    rotks: RotationKeySet
    params: Parameters

    encoder: EncoderComplex128
    encryptor: PkEncryptor
    decryptor: Decryptor
    evaluator: Evaluator

    prec: u64

    def __init__(self, params: Parameters):
        self.params = params

    def initialize(
            self, sk: SecretKey, aggregate_sk: SecretKey,
            pk: PublicKey, rlk: RelinearizationKey, rtks: RotationKeySet, prec: u64):
        
        self.evaluator = new_evaluator(self.params, EvaluationKey(rlk=rlk, rtks=rtks))
        self.encoder = new_encoder_complex(self.params)  # TODO: #218 Replace with big encoder
        self.encryptor = new_encryptor(self.params, pk)
        self.decryptor = new_decryptor(self.params, aggregate_sk)

        self.sk = sk
        self.aggregate_sk = aggregate_sk
        self.pk = pk
        self.rlk = rlk
        self.rotks = rtks

        # self.prec = # TODO: #218 Replace with big encoder


# NewCryptoParams initializes CryptoParams with the given values
def new_crypto_params(
        params: Parameters, sk: SecretKey, aggregate_sk: SecretKey,
        pk: PublicKey, rlk: RelinearizationKey, prec: u64) -> CryptoParams:
    return CryptoParams(
        params=params, sk=sk, aggregate_sk=aggregate_sk,
        pk=pk, rlk=rlk, prec=prec)


# RotationType defines how much we should rotate and in which direction
class RotationType:
    value: int
    side: bool

    def is_right(self) -> bool:
        return self.side
    
    def is_left(self) -> bool:
        return not self.side


# Generate rotKeys for power of two shifts up to # of slots
# and for every shift up to smallDim
def generate_rot_keys(slots: int, small_dim: Static[int], baby_flag: bool) -> list[RotationType]:
    rotations = list[RotationType]()
    # l is the closest larger pow of 2 to slots
    l = slots if slots.popcnt() == 1 else (1 << slots.bitlen())

    rot = 1
    for _ in range(int(ceil(log2(float(l))))):
        rotations.append(RotationType(value=rot, side=False))
        rotations.append(RotationType(value=rot, side=True))
        rot *= 2

    # for baby-step giant-step rotations
    if baby_flag:
        rootl = int(ceil(sqrt(float(slots))))
        for i in range(1, rootl):
            rotations.append(RotationType(value=i, side=False))
            rotations.append(RotationType(value=i * rootl, side=False))

    # for moving the innersum value to its new position
    for i in staticrange(1, small_dim):
        rotations.append(RotationType(value=i, side=True))

    return rotations


# class Partition[S, T]:
#     _encrypted_data: list[CipherTensor[Ciphertext]]  # A CipherTensor per each pid
#     _local_data: ndarray[S, T]

#     @staticmethod
#     def collective_load[dtype=int](mpc, data_path, rows, cols, binary, partitioning):
#         with open(data_path) as f:
#             data = read_matrix(f, rows, cols, binary, TP=dtype)
        
#         all_pids_rows = mpc.comms.gather_at_hub(rows)
#         all_pids_cols = mpc.comms.gather_at_hub(cols)
        
#         if partitioning == HORIZONTAL_PARTITION_FLAG:
#             col = all_pids_cols[0]
#             for c in all_pids_cols:
#                 if c != col: raise ValueError("Invalid dimensions for horizontal partitioning of the matrix.\nOne of the parties' data has more columns than the other parties.")

#             shape = [all_pids_cols.sum(), col]
#         elif partitioning == VERTICAL_PARTITION_FLAG:
#             row = all_pids_rows[0]
#             for r in all_pids_rows:
#                 if r != row: raise ValueError("Invalid dimensions for vertical partitioning of the matrix.\nOne of the parties' data has more rows than the other parties.")

#             shape = [row, all_pids_rows.sum()]
