from pickler import pickle, unpickle

from sequre.lattiseq.ckks import Ciphertext, Plaintext
from sequre.mpc.env import MPCEnv
from sequre.utils.utils import one_hot_vector


class CipherTensor[T]:
    _data: List[T]
    shape: list[int]
    slots: int
    _chunk_size: int

    def __init__(self, _data: List[T], shape: list[int], slots: int):
        self._data = _data
        self.shape = shape
        self.slots = slots
        
        self.reset_chunk_size()
    
    def __repr__(self) -> str:
        return f"""
            Ciphertensor:
            \tShape: {self.shape}
            \tSlots: {self.slots}
            \t(Ciphertensor elements cannot be printed in a bulk)
        """

    def __pickle__(self, jar: Jar, pasteurized: bool):
        pickle(self.slots, jar, pasteurized)
        if not pasteurized: jar += self.slots.pickle_size()
        pickle(self.shape, jar, pasteurized)
        if not pasteurized: jar += self.shape.pickle_size()
        pickle(self._data, jar, pasteurized)
    
    def __unpickle__(jar: Jar, pasteurized: bool) -> CipherTensor[T]:
        slots = unpickle(jar, pasteurized, int)
        if not pasteurized: jar += slots.pickle_size()
        shape = unpickle(jar, pasteurized, list[int])
        if not pasteurized: jar += shape.pickle_size()
        _data = unpickle(jar, pasteurized, List[T])

        return CipherTensor[T](
            _data=_data,
            shape=shape,
            slots=slots)

    def reset_chunk_size(self):
        self._chunk_size = 0 if len(self.shape) <= 1 else CipherTensor[T].count_elements(self.shape[1:], self.slots)
    
    def pickle_size(self) -> int:
        return self.slots.pickle_size() + self.shape.pickle_size() + self._data.pickle_size()

    def __add__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors cannot be added without IR pass enabled.")

    def __sub__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors cannot be subtracted without IR pass enabled.")
    
    def __mul__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors cannot be multiplied without IR pass enabled.")

    def __matmul__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors matrices cannot be multiplied without IR pass enabled.")

    def __gt__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors cannot be compared without IR pass enabled.")

    def __lt__(self: CipherTensor[T], other) -> CipherTensor[T]:
        raise NotImplementedError("CipherTensors cannot be compared without IR pass enabled.")

    def __eq__(self, other: CipherTensor[T]) -> bool:
        if self.shape != other.shape or self.slots != other.slots: return False
        return self._data == other._data
    
    def __getitem__(self, i: int) -> CipherTensor[T]:
        assert len(self.shape) > 1, "CipherTensor: Cannot getitem from one-dimensional CipherTensor."
        return CipherTensor[T](
            _data=self._data[i * self._chunk_size:(i + 1) * self._chunk_size],
            shape=self.shape[1:],
            slots=self.slots)

    @staticmethod
    def count_elements(shape: List[int], slots: int) -> int:
        return shape[:-1].reduce_mul() * (shape[-1] + slots - 1) // slots

    def count_elements(self):
        return CipherTensor.count_elements(self.shape, self.slots)
        
    def enc(mpc: MPCEnv, data) -> CipherTensor[T]:
        shape = data.shape()
        vec_len = shape[-1]
        slots = mpc.he.crypto_params.params.slots()
        number_of_elements = CipherTensor[T].count_elements(shape, slots)
        vector_generator = data.generate_vectors()

        _data = List[T](number_of_elements)
        for _ in range(0, shape.reduce_mul(), vec_len):
            _data.extend(mpc.he.enc_vector(next(vector_generator), T=T))
        
        return CipherTensor[T](
            _data=_data,
            shape=shape,
            slots=slots)
    
    
    def __getitem__(self, i: int) -> CipherTensor[T]:
        assert len(self.shape) > 1, "CipherTensor: Cannot getitem from one-dimensional CipherTensor."
        return CipherTensor[T](
            _flat_array=self._flat_array[i * self._chunk_size:(i + 1) * self._chunk_size],
            shape=self.shape[1:],
            slots=self.slots)


    def __getitem__(self, i: int) -> CipherTensor[T]:
        assert len(self.shape) > 1, "CipherTensor: Cannot getitem from one-dimensional CipherTensor."
        return CipherTensor[T](
            _flat_array=self._flat_array[i * self._chunk_size:(i + 1) * self._chunk_size],
            shape=self.shape[1:],
            slots=self.slots)

    def append(self, other: CipherTensor):
        assert self.shape[1:] == other.shape, "CipherTensor: Invalid shapes for append."

        self._data.extend(other._data)
        self.shape[0] += 1
    
    def pop(self):
        assert len(self.shape) > 1, "CipherTensor: Cannot pop from one-dimensional CipherTensor."
        self._data.len -= self._chunk_size
        self.shape[0] -= 1
    
    def zeros(mpc: MPCEnv, shape: List[int]) -> CipherTensor[Ciphertext]:
        slots = mpc.he.crypto_params.params.slots()
        number_of_elements = CipherTensor[T].count_elements(shape, slots)
        
        return CipherTensor[Ciphertext](
            _data=[mpc.he.zero_cipher() for _ in range(number_of_elements)],
            shape=shape,
            slots=slots)

    def reveal(self, mpc: MPCEnv):
        new_shape = self.shape[:-1]
        new_shape.append(self.shape[-1] // self.slots * self.slots + self.slots)
        return mpc.he.decode_vector(mpc.he.decrypt_vector(self._data)).reshape(new_shape).pad_inplace(self.shape)
    
    def iadd(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.iadd: Shapes mismatch: {self.shape} != {other_cipher.shape}"

        mpc.he.iadd(self._data, other_cipher._data)
        return self

    def isub(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.iadd: Shapes mismatch: {self.shape} != {other_cipher.shape}"

        mpc.he.isub(self._data, other_cipher._data)
        return self

    def imul(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.imul: Shapes mismatch: {self.shape} != {other_cipher.shape}"

        mpc.he.imul(self._data, other_cipher._data)
        return self

    def add(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.add: Shapes mismatch: {self.shape} != {other_cipher.shape}"
        
        _data = mpc.he.add(self._data, other_cipher._data)
        return CipherTensor[_data.T](
            _data=_data,
            shape=self.shape,
            slots=self.slots)

    def sub(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.add: Shapes mismatch: {self.shape} != {other_cipher.shape}"
        
        _data = mpc.he.sub(self._data, other_cipher._data)
        return CipherTensor[_data.T](
            _data=_data,
            shape=self.shape,
            slots=self.slots)
    
    def mul(self, mpc: MPCEnv, other) -> CipherTensor[T]:
        other_cipher = self._check_other_operand(mpc, other)
        assert self.shape == other_cipher.shape, f"CipherTensor.mul: Shapes mismatch: {self.shape} != {other_cipher.shape}"
        
        _data = mpc.he.mul(self._data, other_cipher._data)
        return CipherTensor[_data.T](
            _data=_data,
            shape=self.shape,
            slots=self.slots)

    def matmul(self, mpc: MPCEnv, other, debug=True) -> CipherTensor:
        other_cipher = self._check_other_operand(mpc, other)
        assert len(self.shape) == len(other_cipher.shape) == 2, f"CipherTensor: At least one of the tensors is not a matrix. Self shape: {self.shape}, other shape: {other_cipher.shape}. Ciphertensor matmul supports only matrices at the moment."
        # assert self.shape[1] == other_cipher.shape[0], f"CipherTensor: Invalid matrix dimentions: {self.shape} x {other_cipher.shape}."

        masks = CipherTensor[Plaintext].enc(mpc, [one_hot_vector(i, other_cipher.shape[1], TP=float) for i in range(other_cipher.shape[0])])

        new_cipher_tensor = CipherTensor[T](
            shape=[0, other_cipher.shape[1]],
            slots=self.slots)
        for i in range(self.shape[0]):
            new_row = CipherTensor[Ciphertext].zeros(mpc, [other_cipher.shape[1]])

            for j in range(other_cipher.shape[0]): # rows of two_x = columns of two_XT
                rotated_result = self[i].mul(mpc, other_cipher[j])

                rotation_step = 1
                # for small matrices it would be better to do #int(math.ceil(math.log2(cols)))
                for _ in range(mpc.he.crypto_params.params.log_slots):
                    rotated_result.iadd(mpc, rotated_result.rotate(mpc, rotation_step))
                    rotation_step <<= 1

                new_row.iadd(mpc, rotated_result.mul(mpc, masks[j]))
                if debug: print(f"Matmul: {i + 1}/{self.shape[0]} -- {j + 1}/{other_cipher.shape[0]}")
            if debug: print("----------------------")
            
            new_cipher_tensor.append(new_row)
        
        return new_cipher_tensor

    def rotate(self, mpc, step: int) -> CipherTensor[T]:
        return CipherTensor[T](
            _data=mpc.he.rotate(self._data, step),
            shape=self.shape,
            slots=self.slots)

    def _check_other_operand(self, mpc, other):
        if isinstance(other, CipherTensor): return other
        elif isinstance(other, List): return CipherTensor[Plaintext].enc(mpc, other)
        elif isinstance(other, int) or isinstance(other, float):
            new_tensor_flattened = [other for _ in range(self.shape.reduce_mul())]
            new_cipher = CipherTensor[Plaintext].enc(mpc, new_tensor_flattened)
            new_cipher.shape = self.shape
            new_cipher.reset_chunk_size()
            return new_cipher
        else: raise TypeError("Invalid operand for CipherTensor")
