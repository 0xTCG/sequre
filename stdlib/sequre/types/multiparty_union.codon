import operator

from numpy.ndarray import ndarray
from numpy.create import zeros

from sequre.attributes import sequre
from sequre.lattiseq.ckks import Ciphertext
from sequre.types.ciphertensor import Ciphertensor
from sequre.types.multiparty_partition import MPP
from sequre.types.multiparty_aggregate import MPA


# Multiparty union
class MPU[S, dtype]:
    _mpp: MPP[S, dtype]
    _mpa: MPA[S, dtype]

    def __init__(self: MPU[S, dtype], mpc, plain: ndarray[S, dtype], collective_type: Static[str]):
        if collective_type == "partition":
            self._mpp = MPP[S, dtype](mpc, plain)
            self._mpa = MPA[S, dtype](mpc)
        elif collective_type == "aggregate":
            self._mpp = MPP[S, dtype](mpc)
            self._mpa = MPA[S, dtype](mpc, plain)
        else:
            compile_error("MPU: invalid collective type")

    def __getitem__(self, index) -> MPU:
        self.check_valid()
        
        if self.is_mpa():
            item = self._mpa[index]
            return MPU[item.S, item.dtype](
                _mpp=MPP[item.S, item.dtype](item._mpc),
                _mpa=item)
        
        item = self._mpp[index]
        return MPU[item.S, item.dtype](
            _mpp=item,
            _mpa=MPA[item.S, item.dtype](item._mpc))
    
    def __setitem__(self, index, val: MPU):
        self.check_valid()
        
        if self.is_mpa():
            assert val.is_mpa(), "Not implemented yet: cannot set MPA value into MPP-typed MPU"
            self._mpa[index] = val._mpa
        else:
            assert val.is_mpp(), "Not implemented yet: cannot set MPP value into MPA-typed MPU"
            self._mpp[index] = val._mpp
    
    def __add__(self, other) -> MPU[S, dtype]:
        self.check_valid()
        other.check_valid()
        return self._add(other)
    
    def __sub__(self, other) -> MPU[S, dtype]:
        self.check_valid()
        other.check_valid()
        return self._sub(other)
    
    def __mul__(self, other) -> MPU[S, dtype]:
        self.check_valid()
        other.check_valid()
        return self._mul(other)
    
    def __matmul__(self, other) -> MPU[S, dtype]:
        self.check_valid()
        other.check_valid()
        return self._matmul(other)
    
    @property
    def shape(self):
        self.check_valid()

        if self.is_mpa():
            return self._mpa.shape
        return self._mpp.cohort_shape

    @property
    def mpc(self):
        return self._mpp._mpc
    
    @property
    def T(self):
        self.check_valid()
        
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa.T)
        
        return MPU[S, dtype](
            _mpp=self._mpp.T,
            _mpa=MPA[S, dtype](self._mpp._mpc))
    
    def copy(self):
        self.check_valid()
        return MPU[S, dtype](
            _mpp=self._mpp.copy(),
            _mpa=self._mpa.copy())
    
    def is_mpp(self) -> bool:
        return bool(self._mpp)
    
    def is_mpa(self) -> bool:
        return bool(self._mpa)
    
    def is_valid(self) -> bool:
        return self.is_mpp() ^ self.is_mpa()
    
    def dot(self) -> MPU[S, dtype]:
        self.check_valid()
        
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa.dot())
        
        return MPU[S, dtype](
            _mpp=self._mpp.dot(),
            _mpa=MPA[S, dtype](self._mpp._mpc))
    
    def reveal(self, *args) -> ndarray[S, dtype]:
        self.check_valid()
        
        if self.is_mpa():
            return self._mpa.reveal()
        return self._mpp.reveal()
    
    def expand_dims(self, axis: int = 0) -> MPU:
        self.check_valid()
        if self.is_mpa():
            expanded = self._mpa.expand_dims(axis)
            return MPU[expanded.S, dtype](
                _mpp=MPP[expanded.S, dtype](self._mpa._mpc),
                _mpa=expanded)
        
        expanded = self._mpp.expand_dims(axis)
        return MPU[expanded.S, dtype](
            _mpp=expanded,
            _mpa=MPA[expanded.S, dtype](self._mpp._mpc))
    
    def check_valid(self):
        assert self.is_valid(), f"MPU: invalid MPU---should contain either MPP or MPA exclusively. MPP found: {self.is_mpp()}. MPA found: {self.is_mpa()}."
    
    def _add(self, other) -> MPU[S, dtype]:
        if isinstance(other, ndarray):
            return self._public_op(other, operator.add)

        if self.is_mpa() and other.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa + other._mpa)
        
        if self.is_mpp() and other.is_mpp():
            return MPU[S, dtype](
                _mpp=self._mpp + other._mpp,
                _mpa=MPA[S, dtype](self._mpp._mpc))
        
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=MPU._add_mpa_mpp(self._mpa, other._mpp))
        
        return MPU[S, dtype](
            _mpp=MPP[S, dtype](self._mpa._mpc),
            _mpa=MPU._add_mpa_mpp(other._mpa, self._mpp))
        
    def _sub(self, other) -> MPU[S, dtype]:
        if isinstance(other, ndarray):
            return self._public_op(other, operator.sub)

        if self.is_mpa() and other.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa - other._mpa)
        
        if self.is_mpp() and other.is_mpp():
            return MPU[S, dtype](
                _mpp=self._mpp - other._mpp,
                _mpa=MPA[S, dtype](self._mpp._mpc))
        
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=MPU._sub_mpa_mpp(self._mpa, other._mpp))
        
        return MPU[S, dtype](
            _mpp=MPP[S, dtype](self._mpa._mpc),
            _mpa=MPU._add_mpa_mpp(-other._mpa, self._mpp))
    
    def _mul(self, other) -> MPU[S, dtype]:
        if isinstance(other, ndarray):
            return self._matmul_public(other)

        if self.is_mpa() and other.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa * other._mpa)
        
        if self.is_mpp() and other.is_mpp():
            return MPU[S, dtype](
                _mpp=self._mpp * other._mpp,
                _mpa=MPA[S, dtype](self._mpp._mpc))
        
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=MPU._mul_mpa_mpp(self._mpa, other._mpp))
        
        return MPU[S, dtype](
            _mpp=MPP[S, dtype](self._mpa._mpc),
            _mpa=MPU._mul_mpa_mpp(other._mpa, self._mpp))

    def _matmul(self, other) -> MPU[S, dtype]:
        if isinstance(other, ndarray):
            return self._matmul_public(other)

        if self.is_mpa() and other.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa @ other._mpa)
        
        if self.is_mpp() and other.is_mpp():
            if self._mpp._transposed:
                return MPU[S, dtype](
                    _mpp=MPP[S, dtype](self._mpp._mpc),
                    _mpa=MPU._matmul_mpp_t_mpp(self._mpp._mpc, self._mpp, other._mpp))

            return MPU[S, dtype](
                _mpp=self._mpp @ other._mpp,
                _mpa=MPA[S, dtype](self._mpp._mpc))
        
        if self.is_mpa():
            return MPU._matmul_mpa_mpp(self._mpa._mpc, self._mpa, other._mpp)
        
        return MPU._matmul_mpp_mpa(self._mpp._mpc, self._mpp, other._mpa)
    
    def _public_op(self, other: ndarray[S, dtype], op) -> MPU[S, dtype]:
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=op(self._mpa, other))
        
        return MPU[S, dtype](
            _mpp=op(self._mpp, other),
            _mpa=MPA[S, dtype](self._mpp._mpc))
    
    def _matmul_public(self, other: ndarray[S, dtype]) -> MPU[S, dtype]:
        mpc = self.mpc
        if self.is_mpa():
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpa._mpc),
                _mpa=self._mpa @ other)
        
        if self._mpp._transposed:
            start, stop = self._mpp.get_relative_indices()
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](self._mpp._mpc),
                _mpa=MPU._matmul_mpp_t_mpp(mpc, self._mpp, MPP[S, dtype](mpc, other[start:stop], self._mpp._ratios)))

        return MPU[S, dtype](
            _mpp=self._mpp @ other,
            _mpa=MPA[S, dtype](self._mpp._mpc))
    
    def _add_mpa_mpp(mpa: MPA[S, dtype], mpp: MPP[S, dtype]) -> MPA[S, dtype]:
        mpc = mpa._mpc
        if mpc.pid == 0:
            return mpa.copy()
        
        transposed = mpp._transposed
        start, end = mpp.get_relative_indices()
        
        new_mpa = mpa.T if transposed else mpa.copy()
        if end - start:
            if mpp.has_local_data():
                new_mpa[start:end] += MPA[S, dtype](mpc, mpp._local_data)
            else:
                mpp.unify_encryption()
                new_mpa[start:end] += MPA[S, dtype](mpc, mpp._encryption_unified)
        
        return new_mpa.T if transposed else new_mpa
    
    def _sub_mpa_mpp(mpa: MPA[S, dtype], mpp: MPP[S, dtype]) -> MPA[S, dtype]:
        mpc = mpa._mpc
        if mpc.pid == 0:
            return mpa.copy()
        
        transposed = mpp._transposed
        start, end = mpp.get_relative_indices()
        
        new_mpa = mpa.T if transposed else mpa.copy()
        if end - start:
            if mpp.has_local_data():
                new_mpa[start:end] -= MPA[S, dtype](mpc, mpp._local_data)
            else:
                mpp.unify_encryption()
                new_mpa[start:end] -= MPA[S, dtype](mpc, mpp._encryption_unified)
        
        return new_mpa.T if transposed else new_mpa
    
    def _mul_mpa_mpp(mpa: MPA[S, dtype], mpp: MPP[S, dtype]) -> MPA[S, dtype]:
        if mpa._mpc.pid == 0:
            return mpa.copy()
        
        if mpp._transposed:
            return (mpa.T * mpp.T.join()).T
        
        return mpa * mpp.join()
    
    def _matmul_mpp_mpa(mpc, mpp: MPP[S, dtype], mpa: MPA[S, dtype]) -> MPU[S, dtype]:
        if mpp._transposed:
            return MPU[S, dtype](
                _mpp=MPP[S, dtype](mpc),
                _mpa=MPU._matmul_mpp_t_mpa(mpc, mpp, mpa))
        
        return MPU[S, dtype](
            _mpp=MPU._matmul_mpp_nt_mpa(mpc, mpp, mpa),
            _mpa=MPA[S, dtype](mpc))
    
    def _matmul_mpa_mpp(mpc, mpa: MPA[S, dtype], mpp: MPP[S, dtype]) -> MPU[S, dtype]:
        return MPU._matmul_mpp_mpa(mpc, mpp.T, mpa.T).T
    
    @sequre
    def _matmul_mpp_t_mpa(mpc, mpp: MPP[S, dtype], mpa: MPA[S, dtype]) -> MPA[S, dtype]:
        assert mpp._transposed, "MPP: MPP expected to be tranposed in transposed x MPA matmul case"
        
        if mpc.pid == 0:
            return MPA[S, dtype](mpc, zeros((mpp._local_data.shape[1], mpa._plain.shape[1]), dtype=dtype))
        
        mpa.aggregate()
        start, stop = mpp.get_relative_indices()
        other = MPP[S, dtype](mpc, mpa._aggregate[start:stop], mpp._ratios)
        
        _encryption = Ciphertensor[Ciphertext]()
        with mpp.partition_aligner(), other.partition_aligner():
            if not mpp.is_empty():
                if mpp.is_local():
                    _encryption = mpp._local_data.T @ other._encryption_unified
                else:
                    mpp.unify_encryption()
                    _encryption = mpp._encryption_unified.T @ other._encryption_unified
            
            return MPA[S, dtype](
                _mpc=mpc,
                _encryption=_encryption)
    
    @sequre
    def _matmul_mpp_nt_mpa(mpc, mpp: MPP[S, dtype], mpa: MPA[S, dtype]) -> MPP[S, dtype]:
        assert not mpp._transposed, "MPP: MPP expected not to be tranposed in transposed x MPA matmul case"
        
        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=mpp._mpc,
                _ratios=mpp._ratios.copy(),
                _local_data=zeros((mpp._local_data.shape[0], mpa.shape[1]), dtype=dtype))
        
        mpa.aggregate()

        _encryption = Ciphertensor[Ciphertext]()
        with mpp.partition_aligner() as aligner:
            if not mpp.is_empty():
                if mpp.is_local():
                    _encryption = mpp._local_data @ mpa._aggregate
                else:
                    mpp.unify_encryption()
                    _encryption = mpp._encryption_unified @ mpa._aggregate
            
            return aligner.new_mpp(
                _encryption_unified=_encryption)

    @sequre
    def _matmul_mpp_t_mpp(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPA[S, dtype]:
        if mpc.pid == 0:
            return MPA[S, dtype](
                _mpc=first._mpc,
                _plain=zeros((first._local_data.shape[1], other._local_data.shape[1]), dtype=dtype))

        assert not (first.is_empty() ^ other.is_empty()), "MPP: all or none of the partitions should be empty"

        plain = ndarray[S, dtype]()
        enc = Ciphertensor[Ciphertext]()
        
        with first.partition_aligner(), other.partition_aligner():
            assert first.shape[1] == other.shape[0], f"MPP: Invalid shapes for per-partition matmul. {first.shape} x {other.shape}"

            if not first.is_empty():
                if not first.is_local():
                    first.unify_encryption()
                if not other.is_local():
                    other.unify_encryption()
                
                if first.is_local() and other.is_local():
                    plain = first._local_data.T @ other._local_data
                elif first.is_local():
                    enc = first._local_data.T @ other._encryption_unified
                elif other.is_local():
                    enc = first._encryption_unified.T @ other._local_data
                else:
                    enc = first._encryption_unified.T @ other._encryption_unified

        return MPA[S, dtype](
            _mpc=first._mpc,
            _plain=plain,
            _encryption=enc)
