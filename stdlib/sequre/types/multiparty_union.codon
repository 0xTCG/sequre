from sequre.types.multiparty_partition import MPP
from sequre.types.multiparty_aggregate import MPA


# Multiparty union
class MPU[S, dtype]:
    _mpp: MPP[S, dtype]
    _mpa: MPA[S, dtype]

    

# def _matmul_case_mpa(mpc, first: MPP[S, dtype], other: MPA[S, dtype]) -> Tuple[MPP[S, dtype], MPA[S, dtype]]:
#         if first._transposed:
#             return MPP[S, dtype](), MPP._matmul_case_t_mpa(mpc, first, other)
#         return MPP._matmul_case_nt_mpa(mpc, first, other), MPA[S, dtype]()
    
#     @sequre
#     def _matmul_case_t_mpa(mpc, first: MPP[S, dtype], other: MPA[S, dtype]) -> MPA[S, dtype]:
#         if DEBUG: print(f"CP{mpc.pid}:\tMPP matmul case transposed MPP x MPA. Partition shapes: {first.shape} x {other.shape}")
#         assert first._transposed, "MPP: MPP expected to be tranposed in transposed x MPA matmul case"
        
#         if mpc.pid == 0:
#             return MPP[S, dtype](
#                 _mpc=first._mpc,
#                 _ratios=first._ratios.copy(),
#                 _plain=zeros((first._plain.shape[0], other.shape[1]), dtype=dtype))
        
#         _encryption = Ciphertensor[Ciphertext]()
#         ref_pid = mpc.pid - 1
#         start = first._ratios[:ref_pid].sum()
#         stop = start + first._ratios[ref_pid]
        
#         with first.partition_aligner():
#             if not first.is_empty():
#                 if first.is_plain():
#                     _encryption = first._plain @ other._aggregate[start:stop]
#                 else:
#                     first.unify_encryption()
#                     _encryption = first._encryption @ other._aggregate[start:stop]
            
#             return MPA[S, dtype](
#                 _mpc=mpc,
#                 _encryption=_encryption)
    
#     @sequre
#     def _matmul_case_nt_mpa(mpc, first: MPP[S, dtype], other: MPA[S, dtype]) -> MPP[S, dtype]:
#         if DEBUG: print(f"CP{mpc.pid}:\tMPP matmul case non-transposed MPP x MPA. Partition shapes: {first.shape} x {other.shape}")
#         assert not first._transposed, "MPP: MPP expected not to be tranposed in transposed x MPA matmul case"
        
#         if mpc.pid == 0:
#             return MPP[S, dtype](
#                 _mpc=first._mpc,
#                 _ratios=first._ratios.copy(),
#                 _plain=zeros((first._plain.shape[0], other.shape[1]), dtype=dtype))
        
#         _encryption = Ciphertensor[Ciphertext]()
        
#         with first.partition_aligner() as aligner:
#             if not first.is_empty():
#                 if first.is_plain():
#                     _encryption = first._plain @ other._aggregate
#                 else:
#                     first.unify_encryption()
#                     _encryption = first._encryption @ other._aggregate
            
#             return aligner.new_mpp(
#                 _encryption=_encryption)

# @sequre
#     def _matmul_case_tnt_mpa(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPA[S, dtype]:
#         if DEBUG: print(f"CP{mpc.pid}:\tMPP matmul case transposed x non-transposed. Partition shapes: {first.shape} x {other.shape}")
        
#         if mpc.pid == 0:
#             return MPA[S, dtype](
#                 _mpc=first._mpc,
#                 _plain=zeros((first._plain.shape[1], other._plain.shape[1]), dtype=dtype))

#         assert not (first.is_empty() ^ other.is_empty()), "MPP: all or none of the partitions should be empty"

#         plain = ndarray[S, dtype]()
#         enc = Ciphertensor[Ciphertext]()
        
#         with first.partition_aligner(), other.partition_aligner():
#             assert first.shape[1] == other.shape[0], f"MPP: Invalid shapes for per-partition matmul. {first.shape} x {other.shape}"

#             if not first.is_empty():
#                 if not first.is_plain():
#                     first.unify_encryption()
#                 if not other.is_plain():
#                     other.unify_encryption()
                
#                 if first.is_plain() and other.is_plain():
#                     plain = first._plain.T @ other._plain
#                 elif first.is_plain():
#                     enc = first._plain.T @ other._encryption
#                 elif other.is_plain():
#                     enc = first._encryption.T @ other._plain
#                 else:
#                     enc = first._encryption.T @ other._encryption

#         return MPA[S, dtype](
#             _mpc=first._mpc,
#             _plain=plain,
#             _encryption=enc)
