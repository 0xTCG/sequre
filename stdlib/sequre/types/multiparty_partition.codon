from numpy.ndarray import ndarray
from numpy.create import zeros

from sequre.attributes import sequre
from sequre.lattiseq.ckks import Ciphertext
from sequre.types.builtin import int_t
from sequre.types.cipher_tensor import CipherTensor
from sequre.utils.io import read_ndarray
from sequre.utils.constants import C_CONTIG, D_CONTIG


# Multiparty partition
class MPP[S, dtype]:
    modulus: int_t
    _ratios: list[int]
    _local_data: ndarray[S, dtype]
    _encryption_left: CipherTensor[Ciphertext]
    _encryption_right: CipherTensor[Ciphertext]
    _encryption_unified: CipherTensor[Ciphertext]
    _transposed: bool

    def copy(self) -> MPP[S, dtype]:
        return MPP[S, dtype](
            modulus=self.modulus,
            _ratios=self._ratios.copy(),
            _local_data=self._local_data.copy(),
            _encryption_left=self._encryption_left.copy(),
            _encryption_right=self._encryption_right.copy(),
            _encryption_unified=self._encryption_unified.copy(),
            _transposed=self._transposed)
    
    @property
    def shape(self) -> S:
        if self.is_local():
            _shape = self._local_data.shape
            
            if self._transposed:
                _shape = _shape[::-1]
            
            return _shape
        
        if self.has_unified_encryption():
            if staticlen(S) == 2:
                rows, cols = self._encryption_unified.shape
                _shape = (rows, cols)
            elif staticlen(S) == 1:
                _shape = (self._encryption_unified.shape[0], )
            else:
                compile_error("MPP: Dimension has to be less than 3 until tuple(list) is enabled")
            
            if self._transposed:
                _shape = _shape[::-1]
            
            return _shape

        assert self.has_local_data(), "MPP must have local data if it has no unified encryption"
        last_lane = self._local_data.shape[-1]
        if self._encryption_left: last_lane += self._encryption_left.shape[-1]
        if self._encryption_right: last_lane += self._encryption_right.shape[-1]
        
        _shape = (*self._local_data.shape[:-1], last_lane)
        
        if self._transposed:
            _shape = _shape[::-1]
        
        return _shape
    
    @property
    def cohort_shape(self) -> S:
        _shape = self.shape[::-1] if self._transposed else self.shape
        _shape = (self._ratios.sum(), *_shape[1:])
        if self._transposed:
            _shape = _shape[::-1]
        return _shape
    
    @property
    def T(self) -> MPP[S, dtype]:
        new_mpp = self.copy()
        new_mpp._transposed ^= True
        return new_mpp
    
    @property
    def ndim(self) -> int:
        if self._local_data:
            return self._local_data.ndim
        elif self._encryption_unified:
            return self._encryption_unified.ndim
        return len(self.shape)

    def __iter__(self):
        assert not self.is_semi_encrypted() and not self.is_full_encrypted(), "Cannot iter encrypted data"
        for e in self._local_data: yield e
    
    def __add__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be added without IR pass enabled")
    
    def __sub__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be subtracted without IR pass enabled")

    def __mul__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be multiplied without IR pass enabled")
    
    def __matmul__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be matrix-multiplied without IR pass enabled")
    
    def __gt__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be compared without IR pass enabled")

    def __lt__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be compared without IR pass enabled")
    
    def __eq__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be compared without IR pass enabled")
    
    # Has either of the encrypted sub-partitions
    def has_partial_encryption(self):
        return bool(self._encryption_left) or bool(self._encryption_right)
    
    # Has encryption for whole partition
    def has_unified_encryption(self):
        return bool(self._encryption_unified)
    
    # Has local data
    def has_local_data(self):
        return bool(self._local_data)
    
    # Has local data and either of the encrypted portion
    def is_semi_encrypted(self) -> bool:
        return self.has_local_data() and self.has_partial_encryption()

    # Does not have local data and whole partition is encrypted
    def is_full_encrypted(self) -> bool:
        return not self.has_local_data() and self.has_unified_encryption()
    
    # Has local data only
    def is_local(self) -> bool:
        return self.has_local_data() and not self.has_partial_encryption()

    @staticmethod
    def collective_load[dtype=int](mpc, data_path: str, rows: int, cols: int, binary: bool, modulus: int_t) -> MPP[Tuple[int, int], dtype]:
        if mpc.pid == 0:
            total_number_of_rows = mpc.comms.receive_as_jar(mpc.comms.hub_pid, T=int)
            return MPP[Tuple[int, int], dtype](
                modulus=modulus,
                _local_data=zeros((total_number_of_rows, cols), dtype=dtype))
        
        assert mpc.comms.collect(cols).reduce_and() == cols, f"MPP: The numbers of columns should be the same in the horizontaly partitioned matrix. \n\tCollected cols: {mpc.comms.collect(cols)}\n\t cols at CP{mpc.pid}: {cols}"
        ratios = mpc.comms.collect(rows)
        if mpc.pid == mpc.comms.hub_pid:
            mpc.comms.send_as_jar(ratios.sum(), 0)
        
        with open(data_path) as f:
            data = read_ndarray(f, (rows, cols), binary, dtype=dtype)
        
        return MPP[Tuple[int, int], dtype](
            modulus=modulus,
            _ratios=ratios,
            _local_data=data)
    
    def unify_encryption(self, mpc):
        if mpc.pid == 0:
            return
        if self.has_unified_encryption():
            return
        assert self.has_local_data(), "MPP must have local data if it has no unified encryption"

        is_transposed = False
        is_d_contig = False
        if self._encryption_left and self._encryption_right:
            assert self._encryption_left._transposed == self._encryption_right._transposed, "Not implemented yet: Unifying transposed and non-transposed partitions is not supported yet"
            assert self._encryption_left._diagonal_contiguous == self._encryption_right._diagonal_contiguous, "Not implemented yet: Unifying diagonal-contiguous and non-diagonal-contiguous partitions is not supported yet"
        if self._encryption_left:
            is_transposed = self._encryption_left._transposed
            is_d_contig = self._encryption_left._diagonal_contiguous
        if self._encryption_right:
            is_transposed = self._encryption_right._transposed
            is_d_contig = self._encryption_right._diagonal_contiguous
        
        local_data = self._local_data.diagonal_contig() if is_d_contig else self._local_data
        local_data = local_data.T if is_transposed else local_data
        enc_mode = D_CONTIG if is_d_contig else C_CONTIG
        self._encryption_unified = CipherTensor[Ciphertext].enc(mpc, local_data, mode=enc_mode)
        self._encryption_unified._transposed = is_transposed
        
        if self._encryption_left:
            self._encryption_unified = self._encryption_left.concat(mpc, self._encryption_unified, axis=1)
        if self._encryption_right:
            self._encryption_unified = self._encryption_unified.concat(mpc, self._encryption_right, axis=1)

    def gather_partitions(self, mpc) -> list[CipherTensor[Ciphertext]]:
        if mpc.pid == 0:
            return []
        self.unify_encryption(mpc)
        return mpc.comms.collect(self._encryption_unified.copy())
    
    def collect(self, mpc) -> CipherTensor[Ciphertext]:
        if mpc.pid == 0:
            return CipherTensor[Ciphertext]()
        return self.gather_partitions(mpc).unfence(mpc)
    
    def collect_at(self, mpc, target_pid: int) -> CipherTensor[Ciphertext]:
        if mpc.pid == 0:
            return CipherTensor[Ciphertext]()
        self.unify_encryption(mpc)
        enc = self._encryption_unified.copy()
        partitions = mpc.comms.collect_at(enc, target_pid)
        if mpc.pid == target_pid:
            ct = partitions.unfence(mpc)
            mpc.comms.send_to_all_from(ct.shape, target_pid)
            return ct
        return CipherTensor[Ciphertext](
            shape=mpc.comms.receive_as_jar(target_pid, type(enc.shape)),
            slots=enc.slots,
            _transposed=enc._transposed,
            _diagonal_contiguous=enc._diagonal_contiguous,
            _skinny=enc._skinny)
    
    def reveal(self, mpc) -> ndarray[S, dtype]:
        if mpc.pid == 0:
            return self._local_data
        
        if self.has_local_data():
            print(f"CP{mpc.pid}: WARNING! Revealing local data")

        if self.is_local():
            arr = mpc.comms.collect(self._local_data.copy()).unfence()
        else:            
            arr = self.collect(mpc).reveal(mpc, T=dtype)
    
        if self._transposed: return arr.T
        return arr
    
    @sequre
    def matmul_public(mpc, first: MPP[S, dtype], other: ndarray[S, dtype]) -> MPP[S, dtype]:
        assert first.shape[1] == other.shape[0], f"MPP: Invalid shapes for public matmul. {first.shape} x {other.shape}"

        if mpc.pid == 0:
            return MPP[S, dtype](
                modulus=first.modulus,
                _local_data=zeros((first._local_data.shape[0], other.shape[1]), dtype=dtype))
        
        _local_data = ndarray[S, dtype]()
        _encryption_unified = CipherTensor[Ciphertext]()
        
        if first.is_local():
            _local_data = first._local_data @ other
        else:
            first.unify_encryption(mpc)
            _encryption_unified = first._encryption_unified @ other.T
        
        return MPP[S, dtype](
            modulus=first.modulus,
            _ratios=first._ratios,
            _local_data=_local_data,
            _encryption_unified=_encryption_unified)
    
    def matmul(self, mpc, other) -> MPP[S, dtype]:
        assert self.ndim == other.ndim == 2, f"MPP: Invalid dimensions for matmul. {self.ndim} != {other.ndim}"
        assert self.shape[1] == other.shape[0], f"MPP: Invalid shapes for matmul. {self.shape} x {other.shape}"
                
        if isinstance(other, ndarray):
            return MPP.matmul_public(mpc, self, other)
        
        if self._transposed and other._transposed:
            return MPP._matmul_case_tt(mpc, self, other)
        if self._transposed and not other._transposed:
            return MPP._matmul_case_tnt(mpc, self, other)
        if not self._transposed and other._transposed:
            return MPP._matmul_case_ntt(mpc, self, other)
        
        # Case not self._transposed and not other._transposed:
        return MPP._matmul_case_ntnt(mpc, self, other)
        
    @sequre
    def _matmul_case_ntnt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        other_partitions = other.gather_partitions(mpc)

        if first.is_local():
            _encryption_unified = first._local_data @ other_partitions.unfence(mpc)
        else:
            first.unify_encryption(mpc)
            _encryption_unified = first._encryption_unified @ other_partitions.unfence(mpc)
        
        return MPP[S, dtype](
            modulus=first.modulus,
            _ratios=first._ratios,
            _encryption_unified=_encryption_unified)

    @sequre
    def _matmul_case_tt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        return (other.to_mpc(mpc) @ first.to_mpc(mpc)).T.to_mpp(mpc, first._ratios)

    @sequre
    def _matmul_case_tnt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        if mpc.pid == 0:
            return MPP[S, dtype](
                modulus=first.modulus,
                _local_data=zeros((first._local_data.shape[1], other._local_data.shape[1]), dtype=dtype))

        if not first.is_local():
            first.unify_encryption(mpc)
        if not other.is_local():
            other.unify_encryption(mpc)
        
        if first.is_local() and other.is_local():
            enc = CipherTensor[Ciphertext].enc(mpc, first._local_data.T @ other._local_data)
        elif first.is_local():
            enc = first._local_data.T @ other._encryption_unified
        else:
            enc = first._encryption_unified.T @ other._encryption_unified

        return mpc.comms.collect_at(enc, mpc.comms.hub_pid).sum(mpc).to_mpp(mpc, first._ratios, first.modulus, S=S, dtype=dtype)

    @sequre
    def _matmul_case_ntt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        if mpc.pid == 0:
            return MPP[S, dtype](
                modulus=first.modulus,
                _local_data=zeros((first._local_data.shape[0], other._local_data.shape[0]), dtype=dtype))

        _local_data = ndarray[S, dtype]()
        _encryption_left = CipherTensor[Ciphertext]()
        _encryption_right = CipherTensor[Ciphertext]()
        _encryption_unified = CipherTensor[Ciphertext]()

        other_partitions = other.gather_partitions(mpc)
        reference_pid = mpc.pid - 1  # Avoid CP0
        
        if other.is_local():
            other_encryption_left = other_partitions[:reference_pid].unfence(mpc) if reference_pid else CipherTensor[Ciphertext]()
            other_encryption_right = other_partitions[reference_pid + 1:].unfence(mpc) if not mpc.pid == mpc.comms.number_of_parties - 1 else CipherTensor[Ciphertext]()

            if first.is_local():
                if other_encryption_left: _encryption_left = first._local_data @ other_encryption_left.T
                _local_data = first._local_data @ other._local_data.T
                if other_encryption_right: _encryption_right = first._local_data @ other_encryption_right.T
            else:
                first.unify_encryption(mpc)
                _encryption_unified_enclosed = []
                if other_encryption_left:
                    _encryption_unified_enclosed.append(first._encryption_unified @ other_encryption_left.T)
                _encryption_unified_enclosed.append(first._encryption_unified @ other._local_data.T)
                if other_encryption_right:
                    _encryption_unified_enclosed.append(first._encryption_unified @ other_encryption_right.T)
                _encryption_unified = _encryption_unified_enclosed.unfence(mpc)
        elif first.is_local():
            _encryption_unified = first._local_data @ other_partitions.unfence(mpc).T
        else:
            first.unify_encryption(mpc)
            _encryption_unified = first._encryption_unified @ other_partitions.unfence(mpc).T
        
        return MPP[S, dtype](
            modulus=first.modulus,
            _ratios=first._ratios,
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified)

    def _do_elem_wise_op_partitions(self, mpc, other_data: ndarray[S, dtype], elem_wise_op) -> Tuple[ndarray[S, dtype], CipherTensor[Ciphertext], CipherTensor[Ciphertext], CipherTensor[Ciphertext]]:
        _local_data = ndarray[S, dtype]()
        _encryption_left = CipherTensor[Ciphertext]()
        _encryption_right = CipherTensor[Ciphertext]()
        _encryption_unified = CipherTensor[Ciphertext]()

        if mpc.pid == 0:
            return (self._local_data, _encryption_left, _encryption_right, _encryption_unified)

        if other_data.shape[0] == self._ratios.sum():
            reference_pid = mpc.pid - 1  # Avoid CP0
            start = self._ratios[:reference_pid].sum()
            end = start + self._ratios[reference_pid]
            other_data = other_data[start:end]
        elif not other_data.shape[0] == self.shape[0]:
            raise ValueError("MPP: Shapes mismatch in elem-wise operation")
        
        col_end = 0
        if self.is_local():
            _local_data = elem_wise_op(mpc, self._local_data, other_data)
        elif self.has_partial_encryption():
            if self._encryption_left:
                col_end = self._encryption_left.shape[1]
                _encryption_left = elem_wise_op(mpc, self._encryption_left, other_data[:, :col_end])
            assert self.has_local_data(), "MPP must have local data if it has partial encryption"
            col_start = col_end
            col_end = col_start + self._local_data.shape[1]
            _local_data = elem_wise_op(mpc, self._local_data, other_data[:, col_start:col_end])
            if self._encryption_right:
                col_start = col_end
                _encryption_right = elem_wise_op(mpc, self._encryption_right, other_data[:, col_start:])
        elif self.has_unified_encryption():
            _encryption_unified = elem_wise_op(mpc, self._encryption_unified, other_data)
        else:
            raise ValueError("MPP: Invalid partition")

        return (_local_data, _encryption_left, _encryption_right, _encryption_unified)
    
    def _do_elem_wise_op(self, mpc, other, elem_wise_op) -> MPP[S, dtype]:
        if mpc.pid == 0:
            return MPP[S, dtype](
                modulus=self.modulus,
                _local_data=self._local_data)

        _local_data = ndarray[S, dtype]()
        _encryption_left = CipherTensor[Ciphertext]()
        _encryption_right = CipherTensor[Ciphertext]()
        _encryption_unified = CipherTensor[Ciphertext]()
        
        if isinstance(other, ndarray):
            if staticlen(self.S) != staticlen(other.S):
                other_broadcast = other.check_broadcast(self.shape)
            else:
                other_broadcast = other
            
            _local_data, _encryption_left, _encryption_right, _encryption_unified = self._do_elem_wise_op_partitions(mpc, other_broadcast, elem_wise_op)
        else:
            assert self.cohort_shape == other.cohort_shape, f"MPP: Shapes mismatch in elem-wise operation. {self.cohort_shape} != {other.cohort_shape}"

            if self._transposed ^ other._transposed:
                other_encryption_unified = other.to_mpc(mpc).T.to_mpp(mpc, self._ratios, S=S, dtype=dtype)._encryption_unified
                if self.is_local():
                    _encryption_unified = elem_wise_op(mpc, other_encryption_unified, self._local_data)
                else:
                    self.unify_encryption(mpc)
                    _encryption_unified = elem_wise_op(mpc, other_encryption_unified, self._encryption_unified)
            elif self.is_local() and other.is_local():
                _local_data = elem_wise_op(mpc, self._local_data, other._local_data)
            elif other.is_local():
                _local_data, _encryption_left, _encryption_right, _encryption_unified = self._do_elem_wise_op_partitions(mpc, other._local_data, elem_wise_op)
            elif self.is_local():
                _local_data, _encryption_left, _encryption_right, _encryption_unified = other._do_elem_wise_op_partitions(mpc, self._local_data, elem_wise_op)
            elif self.has_unified_encryption() and not other.has_unified_encryption():
                assert other.is_semi_encrypted(), "MPP: Operand expected to be semi-ecrypted"
                other.unify_encryption(mpc)
                _encryption_unified = elem_wise_op(mpc, self._encryption_unified, other._encryption_unified)
            elif not self.has_unified_encryption() and other.has_unified_encryption():
                assert self.is_semi_encrypted(), "MPP: Operand expected to be semi-ecrypted"
                self.unify_encryption(mpc)
                _encryption_unified = elem_wise_op(mpc, self._encryption_unified, other._encryption_unified)
            else:
                if self.has_local_data() and other.has_local_data():
                    _local_data = elem_wise_op(mpc, self._local_data, other._local_data)
                if self._encryption_left and other._encryption_left:
                    _encryption_left = elem_wise_op(mpc, self._encryption_left, other._encryption_left)
                if self._encryption_right and other._encryption_right:
                    _encryption_right = elem_wise_op(mpc, self._encryption_right, other._encryption_right)
                if self.has_unified_encryption() and other.has_unified_encryption():
                    _encryption_unified = elem_wise_op(mpc, self._encryption_unified, other._encryption_unified)
        
        return MPP[S, dtype](
            modulus=self.modulus,
            _ratios=self._ratios,
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified,
            _transposed=self._transposed)
    
    def _elem_wise_eq(mpc, a, b):
        if isinstance(a, ndarray):
            return (a == b).all()
        elif isinstance(a, CipherTensor):
            return a == b
        else:
            compile_error("MPP: Invalid types in equality check")
