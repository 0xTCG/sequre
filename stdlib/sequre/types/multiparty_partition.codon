import secure_operator

from numpy.ndarray import ndarray
from numpy.create import zeros, array

from helpers import argmax

from sequre.mpc.env import MPCEnv
from sequre.attributes import sequre
from sequre.lattiseq.ckks import Ciphertext
from sequre.types.builtin import int_t
from sequre.types.ciphertensor import Ciphertensor
from sequre.types.utils import EmptyWith
from sequre.utils.io import read_ndarray
from sequre.utils.constants import C_CONTIG, D_CONTIG, MHE_MUL_TO_ADD_THRESHOLD
from sequre.utils.utils import one_hot_vector


# Multiparty partition
class MPP[S, dtype]:
    _mpc: MPCEnv[int_t]
    _ratios: list[int]
    _local_data: ndarray[S, dtype]
    _encryption_left: Ciphertensor[Ciphertext]
    _encryption_right: Ciphertensor[Ciphertext]
    _encryption_unified: Ciphertensor[Ciphertext]
    _transposed: bool

    @staticmethod
    def like[T](other: T, arr: ndarray) -> T:
        if isinstance(T, ndarray):
            return arr
        elif isinstance(T, MPP):
            return MPP(
                _mpc=other._mpc,
                _ratios=other._ratios.copy(),
                _local_data=arr)
        else:
            compile_error("Invalid reference type")
    
    def copy(self) -> MPP[S, dtype]:
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=self._ratios.copy(),
            _local_data=self._local_data.copy(),
            _encryption_left=self._encryption_left.copy(),
            _encryption_right=self._encryption_right.copy(),
            _encryption_unified=self._encryption_unified.copy(),
            _transposed=self._transposed)
    
    @property
    def modulus(self) -> int_t:
        return self._mpc.base_modulus
    
    @property
    def shape(self) -> S:
        if self.is_empty():
            return S(0)
        
        if self.is_local():
            _shape = self._local_data.shape
            
            if self._transposed:
                _shape = _shape[::-1]
            
            return _shape
        
        if self.has_unified_encryption():
            cols = self._encryption_unified.actual_shape[-1]
            if staticlen(S) == 2:
                _shape = (self._rows_count(), cols)
            elif staticlen(S) == 1:
                _shape = (cols, )
            else:
                compile_error("MPP: dimension has to be less than 3")
            
            if self._transposed:
                _shape = _shape[::-1]
            
            return _shape

        assert self.is_semi_encrypted(), "MPP must be semi encrypted if it is not local and has no unified encryption"
        cols = self._local_data.shape[-1]
        if self._encryption_left: cols += self._encryption_left.actual_shape[-1]
        if self._encryption_right: cols += self._encryption_right.actual_shape[-1]
        
        _shape = (*self._local_data.shape[:-1], cols)
        
        if self._transposed:
            _shape = _shape[::-1]
        
        return _shape
    
    @property
    def cohort_shape(self) -> S:
        if staticlen(S) == 1:
            return S(self._mpc.comms.broadcast_from(self.shape, argmax(self._ratios) + 1)[-1])
        
        _shape = self.shape[::-1] if self._transposed else self.shape
        _shape = (self._ratios.sum(), *_shape[1:])
        if self._transposed:
            _shape = _shape[::-1]
        
        return _shape
    
    @property
    def T(self) -> MPP[S, dtype]:
        new_mpp = self.copy()
        new_mpp._transposed ^= True
        return new_mpp
    
    @property
    def ndim(self) -> int:
        return staticlen(S)
    
    @property
    def I(self) -> MPP[S, dtype]:
        id_mat = ndarray[S, dtype].diag(self.cohort_shape, dtype(1))
        reference_pid = self._mpc.pid - 1
        start = self._ratios[:reference_pid].sum()
        end = start + self._ratios[reference_pid]
        
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=self._ratios.copy(),
            _local_data=id_mat[start:end],
            _transposed=self._transposed)

    def __getitem__(self, indices) -> MPP:
        if staticlen(S) == 1:
            return self._getitem_1_dim(indices)
        elif staticlen(S) == 2:
            return self._getitem_2_dim(indices)
        else:
            compile_error("MPP: invalid shape")
    
    def __setitem__(self, indices, value: MPP):
        if staticlen(S) == 1:
            return self._setitem_1_dim(indices, value)
        elif staticlen(S) == 2:
            return self._setitem_2_dim(indices, value)
        else:
            compile_error("MPP: invalid shape")
    
    def __iter__(self):
        assert not self.is_semi_encrypted() and not self.is_full_encrypted(), "Cannot iter encrypted data"
        if self.has_local_data():
            for e in self._local_data: yield e
    
    def __len__(self):
        cohort_shape = self.cohort_shape
        if staticlen(S) == 1:
            return cohort_shape
        elif staticlen(S) == 2:
            return cohort_shape[0]
        else:
            compile_error("MPP: invalid shape")    
    
    def __add__(self, other) -> MPP[S, dtype]:
        self._mpc.stats.secure_add_count += 1
        return self._do_elem_wise_op(other, secure_operator.add)
    
    def __sub__(self, other) -> MPP[S, dtype]:
        self._mpc.stats.secure_sub_count += 1
        return self._do_elem_wise_op(other, secure_operator.sub)

    def __mul__(self, other) -> MPP[S, dtype]:
        self._mpc.stats.secure_mul_count += 1
        return self._do_elem_wise_op(other, secure_operator.mul, MUL=1)
    
    def __matmul__(self, other) -> MPP[S, dtype]:
        self._mpc.stats.secure_matmul_count += 1
        self._mpc.stats.secure_matmul_complexity += (self.cohort_shape[0] * self.cohort_shape[1] * other.cohort_shape[1])
        return self.matmul(other)
    
    def __truediv__(self, other) -> MPP[S, dtype]:
        raise NotImplementedError("MPPs cannot be divided yet")
    
    def __gt__(self, other) -> MPP[S, dtype]:
        if isinstance(other, MPP) or isinstance(other, Ciphertensor):
            compile_error("Not implemented yet: Comparison between MPPs and Ciphertensors")

        return secure_operator.gt(self._mpc, self.to_mpc(), other).to_mpp(self._mpc, ratios=self._ratios, dtype=self.dtype)

    def __lt__(self, other) -> MPP[S, dtype]:
        if isinstance(other, MPP) or isinstance(other, Ciphertensor):
            compile_error("Not implemented yet: Comparison between MPPs and Ciphertensors")

        return secure_operator.lt(self._mpc, self.to_mpc(), other).to_mpp(self._mpc, ratios=self._ratios, dtype=self.dtype)
    
    # Partition has either of the encrypted sub-partitions
    def has_partial_encryption(self):
        return bool(self._encryption_left) or bool(self._encryption_right)
    
    # Partition has encryption for whole partition
    def has_unified_encryption(self):
        return bool(self._encryption_unified)
    
    # Partition has local data
    def has_local_data(self):
        return not self._local_data.is_empty()
    
    # Partition has local data and either of the encrypted portion
    def is_semi_encrypted(self) -> bool:
        return self.has_local_data() and self.has_partial_encryption()

    # Partition does not have local data and whole partition is encrypted
    def is_full_encrypted(self) -> bool:
        return not self.has_local_data() and self.has_unified_encryption()
    
    # Partition has local data only
    def is_local(self) -> bool:
        return self.has_local_data() and not self.has_partial_encryption()
    
    # Partition does not contain any data
    def is_empty(self) -> bool:
        return not self.has_local_data() and not self.has_unified_encryption() and not self.has_partial_encryption()
    
    # All partitions aligned
    def cohort_is_aligned(self) -> bool:
        return self._ratios.same()

    @staticmethod
    def collective_load[dtype](mpc: MPCEnv, data_path: str, rows: int, cols: int, binary: bool) -> MPP[Tuple[int, int], dtype]:
        assert rows and cols, "MPP: Collective load can load only matrices"
        
        if mpc.pid == 0:
            ratios = mpc.comms.receive_as_jar(mpc.comms.hub_pid, T=list[int])
            return MPP[Tuple[int, int], dtype](
                _mpc=mpc,
                _ratios=ratios,
                _local_data=zeros((ratios.sum(), cols), dtype=dtype))
        
        assert mpc.comms.collect(cols).reduce_and() == cols, f"MPP: The numbers of columns should be the same in the horizontaly partitioned matrix. \n\tCollected cols: {mpc.comms.collect(cols)}\n\t cols at CP{mpc.pid}: {cols}"
        ratios = mpc.comms.collect(rows)
        if mpc.pid == mpc.comms.hub_pid:
            mpc.comms.send_as_jar(ratios, 0)
        
        with open(data_path) as f:
            data = read_ndarray(f, (rows, cols), binary, dtype=dtype)
        
        return MPP[Tuple[int, int], dtype](
            _mpc=mpc,
            _ratios=ratios,
            _local_data=data)
    
    def astype(self, t: type) -> MPP[S, t]:
        return MPP[S, t](
            _mpc=self._mpc,
            _ratios=self._ratios.copy(),
            _local_data=self._local_data.astype(t),
            _encryption_left=self._encryption_left,
            _encryption_right=self._encryption_right,
            _encryption_unified=self._encryption_unified,
            _transposed=self._transposed)
    
    def unify_encryption(self):
        mpc = self._mpc
        if staticlen(S) > 2:
            compile_error("MPP: cannot have dimension larger than 2")
        
        if mpc.pid == 0:
            return
        if self.has_unified_encryption():
            return
        if self.is_empty():
            return
        assert self.has_local_data(), "MPP must have local data if it has no unified encryption"

        is_transposed = False
        is_d_contig = False
        local_data = self._local_data
        
        if staticlen(S) == 2:        
            if self._encryption_left and self._encryption_right:
                assert self._encryption_left._transposed == self._encryption_right._transposed, "Not implemented yet: Unifying transposed and non-transposed partitions is not supported yet"
                assert self._encryption_left._diagonal_contiguous == self._encryption_right._diagonal_contiguous, "Not implemented yet: Unifying diagonal-contiguous and non-diagonal-contiguous partitions is not supported yet"
            if self._encryption_left:
                is_transposed = self._encryption_left._transposed
                is_d_contig = self._encryption_left._diagonal_contiguous
            if self._encryption_right:
                is_transposed = self._encryption_right._transposed
                is_d_contig = self._encryption_right._diagonal_contiguous
            
            local_data = local_data.T if is_transposed else local_data

        self._encryption_unified = Ciphertensor[Ciphertext].enc(mpc, local_data, mode=D_CONTIG if is_d_contig else C_CONTIG)
        self._encryption_unified._transposed = is_transposed
        if self._encryption_left:
            self._encryption_unified = self._encryption_left.concat(mpc, self._encryption_unified, axis=1)
        if self._encryption_right:
            self._encryption_unified = self._encryption_unified.concat(mpc, self._encryption_right, axis=1)

    def collect(self) -> list[Ciphertensor[Ciphertext]]:
        mpc = self._mpc
        if mpc.pid == 0:
            return []
        self.unify_encryption()
        return mpc.comms.collect(self._encryption_unified.copy())
    
    def join(self) -> Ciphertensor[Ciphertext]:
        mpc = self._mpc
        if mpc.pid == 0:
            return Ciphertensor[Ciphertext]()
        return self.collect().unfence(mpc)
    
    def join_at(self, target_pid: int) -> Ciphertensor[Ciphertext]:
        mpc = self._mpc
        if mpc.pid == 0:
            return Ciphertensor[Ciphertext]()
        self.unify_encryption()
        enc = self._encryption_unified.copy()
        partitions = mpc.comms.collect_at(enc, target_pid)
        if mpc.pid == target_pid:
            ct = partitions.unfence(mpc)
            mpc.comms.send_to_all_from(ct.shape, target_pid)
            return ct
        return Ciphertensor[Ciphertext](
            shape=mpc.comms.receive_as_jar(target_pid, type(enc.shape)),
            slots=enc.slots,
            _transposed=enc._transposed,
            _diagonal_contiguous=enc._diagonal_contiguous,
            _skinny=enc._skinny)
    
    def broadcast_from(self, source_pid: int):
        mpc = self._mpc
        self._ratios = mpc.comms.broadcast_from(self._ratios, source_pid)
        self._local_data = mpc.comms.broadcast_from(self._local_data, source_pid)
        self._encryption_left = mpc.comms.broadcast_from(self._encryption_left, source_pid)
        self._encryption_right = mpc.comms.broadcast_from(self._encryption_right, source_pid)
        self._encryption_unified = mpc.comms.broadcast_from(self._encryption_unified, source_pid)
        self._transposed = mpc.comms.broadcast_from(self._transposed, source_pid)
    
    def reveal(self, *args):
        mpc = self._mpc
        if mpc.pid == 0:
            return self._local_data
        
        if self.has_local_data():
            print(f"CP{mpc.pid}: WARNING! Revealing local data")

        if staticlen(S) == 1:
            self.broadcast_from(argmax(self._ratios) + 1)
            
            if self.is_local():
                return self._local_data
            else:
                self.unify_encryption()
                return self._encryption_unified.reveal(mpc, T=dtype)[0]
        
        elif staticlen(S) == 2:
            if mpc.council(self.is_local()).any():
                arr = mpc.comms.collect(self._local_data.copy()).unfence()
            else:
                arr = self.join().reveal(mpc, T=dtype)
    
            return arr.T if self._transposed else arr
        
        else:
            compile_error("MPP: can only be 1-dimensional and 2-dimensional")
    
    def dot(self) -> MPP[S, dtype]:
        if staticlen(S) != 2 and staticlen(S) != 1:
            compile_error("MPP: invalid shape for dot product")
        
        mpc = self._mpc
        
        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=mpc,
                _ratios=self._ratios.copy(),
                _local_data=zeros((self.shape[0], 1) if staticlen(S) == 2 else (1,), dtype=dtype))
        
        if self._transposed:
            print("INFO: MPP tranposed lazily. Dot product iterates over columns instead of rows.")
        
        axis = (1 if staticlen(S) == 2 else 0)
        
        _local_data = ndarray[S, dtype]()
        _encryption_unified = Ciphertensor[Ciphertext]()
        
        with self.partition_aligner() as mpp_aligner:
            if not self.is_empty():
                if self.has_local_data():
                    _local_data = self._local_data.dot_axis(axis=axis)
                
                if self.is_local():
                    pass
                elif self.has_unified_encryption():
                    _encryption_unified = self._encryption_unified.dot(mpc, axis=axis)
                elif self.is_semi_encrypted():
                    _encryption_unified = Ciphertensor[Ciphertext].enc(mpc, _local_data)
                    
                    if self._encryption_left:
                        _encryption_unified = self._encryption_left.dot(mpc, axis=axis).iadd(mpc, _encryption_unified)
                    if self._encryption_right:
                        _encryption_unified.iadd(mpc, self._encryption_right.dot(mpc, axis=axis))
                else:
                    raise ValueError(f"MPP: partition empty at CP{mpc.pid} while computing dot product")

            return mpp_aligner.new_mpp(_local_data=_local_data, _encryption_unified=_encryption_unified)
    
    def matmul(self, other) -> MPP[S, dtype]:
        mpc = self._mpc
        assert self.ndim == other.ndim == 2, f"MPP: Invalid dimensions for matmul. {self.ndim} != {other.ndim}"
        if mpc.pid: assert self.cohort_shape[1] == other.cohort_shape[0], f"MPP: Invalid shapes for matmul. {self.cohort_shape} x {other.cohort_shape}"
        else: assert self.shape[1] == other.shape[0], f"MPP: Invalid shapes for matmul. {self.shape} x {other.shape}"
                
        if isinstance(other, ndarray):
            return MPP._matmul_public(mpc, self, other)
        
        if self._transposed and other._transposed:
            return MPP._matmul_case_tt(mpc, self, other)
        if not self._transposed and not other._transposed:
            return MPP._matmul_case_ntnt(mpc, self, other)

        assert self.shape[1] == other.shape[0], f"MPP: Invalid shapes for per-partition matmul. {self.shape} x {other.shape}"

        if self._transposed and not other._transposed:
            return MPP._matmul_case_tnt(mpc, self, other)
        else: # case not self._transposed and other._transposed
            return MPP._matmul_case_ntt(mpc, self, other)
    
    def patch_copy(self, new_size: int) -> MPP[S, dtype]:
        mpc = self._mpc
        if staticlen(S) != 1:
            compile_error("Not implemented yet: MPP n-dim patch copy")
        assert not self.is_semi_encrypted(), "Not implemented yet: Semi-encrypted MPP patch copy"
        assert not self.is_empty(), "MPP: cannot patch copy empty partition"

        new_mpp = MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=self._ratios)
        
        if self.is_local() or mpc.pid == 0:
            new_mpp._local_data = self._local_data.patch_copy(new_size)
        elif self.is_full_encrypted():
            new_mpp._encryption_unified = self._encryption_unified.patch_copy(mpc, new_size)
        else:
            raise NotImplementedError("MPP: expected to be either local or fully encrypted for patch copy at the moment")
        
        return new_mpp
    
    def check_broadcast[S2](self, target_shape: S2) -> MPP[S2, dtype]:
        if self.is_empty():
            return self
        
        if staticlen(S2) > staticlen(S):
            raise NotImplementedError("Broadasting MPP from lower to higher dimension not implemented yet")
        elif staticlen(S2) == staticlen(S):
            if staticlen(S2) == 1 and target_shape[0] > self.shape[0] and self.shape[0] == 1:
                return self.patch_copy(target_shape[0])
            return self
        else:
            compile_error("MPP: Incompatible shapes for broadcast")

    def zeros(self) -> MPP[S, dtype]:
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=self._ratios.copy(),
            _local_data=zeros(self.shape, dtype=dtype))

    def expand_dims(self, axis: int = 0) -> MPP:
        if staticlen(S) != 1:
            compile_error("MPP: only 1-dim MPPs can be expanded")
        assert axis == 0, "Not implemented yet: MPP dim expansion over secondary axes"
        
        _local_data = ndarray[Tuple[int, int], dtype]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()
        
        if not self._local_data.is_empty(): _local_data = self._local_data.expand_dims(axis=axis)
        if self._encryption_left: _encryption_left = self._encryption_left.expand_dims(axis=axis)
        if self._encryption_right: _encryption_right = self._encryption_right.expand_dims(axis=axis)
        if self._encryption_unified: _encryption_unified = self._encryption_unified.expand_dims(axis=axis)

        return MPP[Tuple[int, int], dtype](
            _mpc=self._mpc,
            _ratios=self._ratios.copy(),
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified,
            _transposed=self._transposed)

    def _autocast(self, other):
        assert isinstance(other, MPP) or isinstance(other, ndarray), "MPP: Autocasting can be done only between MPPs or ndarrays for now"
        
        if isinstance(dtype, type(other._internal_type)):
            return self, other
        if isinstance(dtype, int) and isinstance(type(other._internal_type), float):
            return self.astype(float), other
        if isinstance(dtype, float) and isinstance(type(other._internal_type), int):
            return self, other.astype(float)
        
        compile_error("Cannot autocast dtypes")
    
    @sequre
    def _matmul_public(mpc, first: MPP[S, dtype], other: ndarray[S, dtype]) -> MPP[S, dtype]:
        assert first.ndim == other.ndim == 2, f"MPP: Invalid dimensions for matmul. {first.ndim} != {other.ndim}"
        assert first.shape[1] == other.shape[0], f"MPP: Invalid shapes for public matmul. {first.shape} x {other.shape}"

        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=first._mpc,
                _ratios=first._ratios.copy(),
                _local_data=zeros((first._local_data.shape[0], other.shape[1]), dtype=dtype))
        
        _local_data = ndarray[S, dtype]()
        _encryption_unified = Ciphertensor[Ciphertext]()
        
        with first.partition_aligner() as aligner:
            if not first.is_empty():
                if first.is_local():
                    _local_data = first._local_data @ other
                else:
                    first.unify_encryption()
                    _encryption_unified = first._encryption_unified @ other
            
            return aligner.new_mpp(
                _local_data=_local_data,
                _encryption_unified=_encryption_unified)
    
    @sequre
    def _matmul_case_ntnt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        return (first.to_mpc() @ other.to_mpc()).to_mpp(mpc, first._ratios, dtype=dtype)

    @sequre
    def _matmul_case_tt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        return (other.to_mpc() @ first.to_mpc()).T.to_mpp(mpc, first._ratios, dtype=dtype)

    @sequre
    def _matmul_case_tnt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=first._mpc,
                _ratios=first._ratios.copy(),
                _local_data=zeros((first._local_data.shape[1], other._local_data.shape[1]), dtype=dtype))

        assert not (first.is_empty() ^ other.is_empty()), "MPP: all or none of the partitions should be empty"

        enc = Ciphertensor[Ciphertext]()
        
        with first.partition_aligner(), other.partition_aligner():
            if not first.is_empty():
                if not first.is_local():
                    first.unify_encryption()
                if not other.is_local():
                    other.unify_encryption()
                
                if first.is_local() and other.is_local():
                    enc = Ciphertensor[Ciphertext].enc(mpc, first._local_data.T @ other._local_data)
                elif first.is_local():
                    enc = first._local_data.T @ other._encryption_unified
                elif other.is_local():
                    enc = first._encryption_unified.T @ other._local_data
                else:
                    enc = first._encryption_unified.T @ other._encryption_unified

        return mpc.comms.collect_at(enc, mpc.comms.hub_pid).sum(mpc).to_mpp(mpc, first._ratios, S=S, dtype=dtype)

    @sequre
    def _matmul_case_ntt(mpc, first: MPP[S, dtype], other: MPP[S, dtype]) -> MPP[S, dtype]:
        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=first._mpc,
                _ratios=first._ratios.copy(),
                _local_data=zeros((first._local_data.shape[0], other._local_data.shape[0]), dtype=dtype))

        _local_data = ndarray[S, dtype]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()

        with first.partition_aligner() as aligner:
            if not first.is_empty():
                other_partitions = other.collect()
                reference_pid = mpc.pid - 1  # Avoid CP0
                
                if other.is_local():
                    other_encryption_left = other_partitions[:reference_pid].unfence(mpc) if reference_pid else Ciphertensor[Ciphertext]()
                    other_encryption_right = other_partitions[reference_pid + 1:].unfence(mpc) if not mpc.pid == mpc.comms.number_of_parties - 1 else Ciphertensor[Ciphertext]()

                    if first.is_local():
                        if other_encryption_left: _encryption_left = first._local_data @ other_encryption_left.T
                        _local_data = first._local_data @ other._local_data.T
                        if other_encryption_right: _encryption_right = first._local_data @ other_encryption_right.T
                    else:
                        first.unify_encryption()
                        _encryption_unified_enclosed = []
                        if other_encryption_left:
                            _encryption_unified_enclosed.append(first._encryption_unified @ other_encryption_left.T)
                        _encryption_unified_enclosed.append(first._encryption_unified @ other._local_data.T)
                        if other_encryption_right:
                            _encryption_unified_enclosed.append(first._encryption_unified @ other_encryption_right.T)
                        _encryption_unified = _encryption_unified_enclosed.unfence(mpc)
                elif first.is_local():
                    _encryption_unified = first._local_data @ other_partitions.unfence(mpc).T
                else:
                    first.unify_encryption()
                    _encryption_unified = first._encryption_unified @ other_partitions.unfence(mpc).T
        
            return aligner.new_mpp(
                _local_data=_local_data,
                _encryption_left=_encryption_left,
                _encryption_right=_encryption_right,
                _encryption_unified=_encryption_unified)

    def _check_binary_operands(self, other):
        assert isinstance(other, MPP) or isinstance(other, ndarray) or isinstance(other, ByVal), "MPP: Elem-wise operand should be either MPP, ndarray or by-value type"
        return self._autocast(array([other]) if isinstance(other, ByVal) else other)
    
    def _do_elem_wise_op_public(self, other_data: ndarray[S, dtype], elem_wise_op) -> Tuple[ndarray[S, dtype], Ciphertensor[Ciphertext], Ciphertensor[Ciphertext], Ciphertensor[Ciphertext]]:
        mpc = self._mpc
        assert self.shape[-1] == other_data.shape[-1], "MPP: shapes missmatch in public elem-wise operation"
        _local_data = ndarray[S, dtype]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()

        if mpc.pid == 0:
            return (self._local_data, _encryption_left, _encryption_right, _encryption_unified)

        if staticlen(S) == 2:
            if other_data.shape[0] == self._ratios.sum():
                reference_pid = mpc.pid - 1  # Avoid CP0
                start = self._ratios[:reference_pid].sum()
                end = start + self._ratios[reference_pid]
                other_data = other_data[start:end]
            elif not other_data.shape[0] == self.shape[0]:
                raise ValueError("MPP: shapes missmatch in public elem-wise operation")
        
        col_end = 0
        if self.is_local():
            _local_data = elem_wise_op(mpc, self._local_data, other_data)
        elif self.has_unified_encryption():
            _encryption_unified = elem_wise_op(mpc, self._encryption_unified, other_data)
        elif self.has_partial_encryption():
            if self._encryption_left:
                col_end = self._encryption_left.shape[-1]
                _encryption_left = elem_wise_op(mpc, self._encryption_left, other_data._slice_cols(0, col_end))
            assert self.has_local_data(), "MPP must have local data if it has partial encryption"
            col_start = col_end
            col_end = col_start + self._local_data.shape[-1]
            _local_data = elem_wise_op(mpc, self._local_data, other_data._slice_cols(col_start, col_end))
            if self._encryption_right:
                col_start = col_end
                _encryption_right = elem_wise_op(mpc, self._encryption_right, other_data._slice_cols(col_start, other_data.shape[-1]))
        else:
            raise ValueError("MPP: Invalid partition")

        return (_local_data, _encryption_left, _encryption_right, _encryption_unified)
    
    def _do_elem_wise_op(self, other, elem_wise_op, MUL: Static[int] = 0) -> MPP:
        if MUL == 1:
            # Results in compile-time error if False
            elem_wise_op == secure_operator.mul
        
        mpc = self._mpc
        
        if not self.is_local():
            if isinstance(other, int) and other < MHE_MUL_TO_ADD_THRESHOLD and MUL == 1:
                # Do series of additions instead of single multiplication if other operand is small int constant
                _sum = self.copy()
                for _ in range(other - 1):
                    _sum = secure_operator.add(mpc, _sum, self)
                return _sum
        
        _self, _other = self._check_binary_operands(other)
        ac_type = _self.dtype

        if mpc.pid == 0:
            return MPP[S, ac_type](
                _mpc=_self._mpc,
                _ratios=_self._ratios.copy(),
                _local_data=_self._local_data)
        
        self_aligner = _self.partition_aligner()
        other_aligner = _other.partition_aligner() if isinstance(_other, MPP) else EmptyWith()
        
        if MUL == 1:
            self_aligner.__enter__()
            other_aligner.__enter__()

        _local_data = ndarray[S, ac_type]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()
        
        if not _self.is_empty():
            other_broadcast = _other.check_broadcast(_self.shape)
            
            if isinstance(other_broadcast, ndarray):
                _local_data, _encryption_left, _encryption_right, _encryption_unified = _self._do_elem_wise_op_public(other_broadcast, elem_wise_op)
            elif isinstance(other_broadcast, MPP):
                assert not other_broadcast.is_empty(), "MPP: cannot do elem-wise operation with an empty partition"

                if staticlen(S) > 1:
                    assert _self.cohort_shape == other_broadcast.cohort_shape, f"MPP: Shapes mismatch in elem-wise operation. {_self.cohort_shape} != {other_broadcast.cohort_shape}"
                else:
                    assert _self.shape == other_broadcast.shape, f"MPP: Shapes mismatch in elem-wise operation. {_self.shape} != {other_broadcast.shape}"

                if _self._transposed ^ other_broadcast._transposed:
                    transpose_encryption = False
                    if not _self.is_local():
                        _self.unify_encryption()
                        transpose_encryption = _self._encryption_unified._transposed
                    
                    other_encryption_unified = other_broadcast.to_mpc().T.to_mpp(mpc, _self._ratios, transpose_encryption=transpose_encryption, dtype=ac_type)._encryption_unified
                    
                    if _self.is_local():
                        _encryption_unified = elem_wise_op(mpc, _self._local_data, other_encryption_unified)
                    else:
                        _encryption_unified = elem_wise_op(mpc, _self._encryption_unified, other_encryption_unified)
                elif _self.is_local() and other_broadcast.is_local():
                    _local_data = elem_wise_op(mpc, _self._local_data, other_broadcast._local_data)
                elif other_broadcast.is_local():
                    _local_data, _encryption_left, _encryption_right, _encryption_unified = _self._do_elem_wise_op_public(other_broadcast._local_data, elem_wise_op)
                elif _self.is_local():
                    _local_data, _encryption_left, _encryption_right, _encryption_unified = _self._local_data._do_elem_wise_op_public(other_broadcast, elem_wise_op)
                elif _self.has_unified_encryption() and not other_broadcast.has_unified_encryption():
                    assert other_broadcast.is_semi_encrypted(), "MPP: Operand expected to be semi-encrypted"
                    other_broadcast.unify_encryption()
                    _encryption_unified = elem_wise_op(mpc, _self._encryption_unified, other_broadcast._encryption_unified)
                elif not _self.has_unified_encryption() and other_broadcast.has_unified_encryption():
                    assert _self.is_semi_encrypted(), "MPP: Operand expected to be semi-encrypted"
                    _self.unify_encryption()
                    _encryption_unified = elem_wise_op(mpc, _self._encryption_unified, other_broadcast._encryption_unified)
                else:
                    if _self.has_local_data() and other_broadcast.has_local_data():
                        _local_data = elem_wise_op(mpc, _self._local_data, other_broadcast._local_data)
                    if _self._encryption_left and other_broadcast._encryption_left:
                        _encryption_left = elem_wise_op(mpc, _self._encryption_left, other_broadcast._encryption_left)
                    if _self._encryption_right and other_broadcast._encryption_right:
                        _encryption_right = elem_wise_op(mpc, _self._encryption_right, other_broadcast._encryption_right)
                    if _self.has_unified_encryption() and other_broadcast.has_unified_encryption():
                        _encryption_unified = elem_wise_op(mpc, _self._encryption_unified, other_broadcast._encryption_unified)
            else:
                compile_error("Invalid operand type for MPP elem-wise operation")
        
        if MUL == 1:
            self_aligner.__exit__()
            other_aligner.__exit__()
        
            return self_aligner.new_mpp(
                _local_data=_local_data,
                _encryption_left=_encryption_left,
                _encryption_right=_encryption_right,
                _encryption_unified=_encryption_unified)

        return MPP[S, ac_type](
            _mpc=_self._mpc,
            _ratios=_self._ratios.copy(),
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified,
            _transposed=_self._transposed)
    
    @sequre
    def _getitem_2_dim_core[S1](mpc, mpp: MPP[S, dtype], adjusted_idx, ratios: List[int]) -> MPP[S1, dtype]:
        _local_data = ndarray[S1, dtype]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()
        
        if mpp.is_local():
            _local_data = mpp._local_data[adjusted_idx]
        elif mpp.is_semi_encrypted():
            assert not mpp._encryption_left._transposed and not mpp._encryption_right._transposed, "Not implemented yet: getitem from transposed ciphertensor"
            _local_data = mpp._local_data[adjusted_idx]
            _encryption_left = mpp._encryption_left[adjusted_idx]
            _encryption_right = mpp._encryption_right[adjusted_idx]
        else:
            assert mpp.has_unified_encryption(), "MPP: must have unified encryption if not local and semi encrypted"
            assert not mpp._encryption_unified._transposed, "Not implemented yet: getitem from transposed ciphertensor"
            _encryption_unified = mpp._encryption_unified[adjusted_idx]
        
        return MPP[S1, dtype](
            _mpc=mpc,
            _ratios=ratios,
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified)
    
    @sequre
    def _setitem_2_dim_core(mpc, mpp: MPP[S, dtype], adjusted_idx, value: MPP):
        if mpp.is_full_encrypted() or value.is_full_encrypted():
            _value_cp = value.copy()
            mpp.unify_encryption()
            _value_cp.unify_encryption()
            mpp._encryption_unified[adjusted_idx] = _value_cp._encryption_unified
        elif mpp.is_local() and value.is_local():
            mpp._local_data[adjusted_idx] = value._local_data
        else:
            value_enc_left, value_local, value_enc_right = mpp._align_semi_encryptions(value)
            if mpp._encryption_left: mpp._encryption_left[adjusted_idx] = value_enc_left
            mpp._local_data[adjusted_idx] = value_local
            if mpp._encryption_right: mpp._encryption_right[adjusted_idx] = value_enc_right
    
    def _getitem_2_dim(self, idx: int) -> MPP[Tuple[int], dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"
        assert 0 <= idx < self._ratios.sum(), "MPP: getitem - index out of bound"

        _ratio_idx = self._find_idx_in_ratios(idx)
        _ratios = one_hot_vector(idx=_ratio_idx, size=len(self._ratios), TP=int)

        if mpc.pid == 0:
            return MPP[Tuple[int], dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[idx])

        if mpc.pid == _ratio_idx + 1:
            adjusted_idx = idx - self._ratios[:_ratio_idx].sum()
            return MPP._getitem_2_dim_core(mpc, self, adjusted_idx, _ratios, S1=Tuple[int])
            
        return MPP[Tuple[int], dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
    
    def _getitem_2_dim(self, s: slice) -> MPP[S, dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"

        start, stop, _, _ = s.adjust_indices(self.cohort_shape[0])
        
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        _ratios = self._get_sliced_ratios(_start_ratio_idx, _stop_ratio_idx, start, stop)

        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[s])

        reference_pid = mpc.pid - 1
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_slice = self._adjust_row_slice(start, stop)
            return MPP._getitem_2_dim_core(mpc, self, adjusted_slice, _ratios, S1=S)
            
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
    
    def _getitem_2_dim(self, slices: Tuple[slice, slice]) -> MPP[S, dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"

        rs, cs = slices
        start, stop, _, _ = rs.adjust_indices(self.cohort_shape[0])
        
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        _ratios = self._get_sliced_ratios(_start_ratio_idx, _stop_ratio_idx, start, stop)

        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[slices])

        reference_pid = mpc.pid - 1
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_rs = self._adjust_row_slice(start, stop)
            return MPP._getitem_2_dim_core(mpc, self, (adjusted_rs, cs), _ratios, S1=S)
            
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
    
    def _getitem_2_dim(self, slices: Tuple[slice, int]) -> MPP[S, dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"

        rs, c_idx = slices
        cs = slice(start=c_idx, stop=c_idx + 1, step=1)
        start, stop, _, _ = rs.adjust_indices(self.cohort_shape[0])
        
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        _ratios = self._get_sliced_ratios(_start_ratio_idx, _stop_ratio_idx, start, stop)

        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[rs, cs])

        reference_pid = mpc.pid - 1
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_rs = self._adjust_row_slice(start, stop)
            return MPP._getitem_2_dim_core(mpc, self, (adjusted_rs, cs), _ratios, S1=S)
            
        return MPP[S, dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
    
    def _getitem_2_dim(self, slices: Tuple[int, slice]) -> MPP[Tuple[int], dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"

        r_idx, cs = slices
        
        assert 0 <= r_idx < self._ratios.sum(), "MPP: getitem - index out of bound"

        _ratio_idx = self._find_idx_in_ratios(r_idx)
        _ratios = one_hot_vector(idx=_ratio_idx, size=len(self._ratios), TP=int)

        if mpc.pid == 0:
            return MPP[Tuple[int], dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[slices])

        if mpc.pid == _ratio_idx + 1:
            adjusted_idx = r_idx - self._ratios[:_ratio_idx].sum()
            return MPP._getitem_2_dim_core(mpc, self, (adjusted_idx, cs), _ratios, S1=Tuple[int])
            
        return MPP[Tuple[int], dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
    
    def _getitem_2_dim(self, slices: Tuple[int, int]) -> MPP[Tuple[int], dtype]:
        mpc = self._mpc
        assert self.ndim == 2, "MPP: cannot do 2-dim-getitem from non-2-dimensional MPP"
        assert not self._transposed, "Not implemented yet: getitem from transposed MPP"

        r_idx, c_idx = slices
        cs = slice(start=c_idx, stop=c_idx + 1, step=1)
        
        assert 0 <= r_idx < self._ratios.sum(), "MPP: getitem - index out of bound"

        _ratio_idx = self._find_idx_in_ratios(r_idx)
        _ratios = one_hot_vector(idx=_ratio_idx, size=len(self._ratios), TP=int)

        if mpc.pid == 0:
            return MPP[Tuple[int], dtype](
                _mpc=self._mpc,
                _ratios=_ratios,
                _local_data=self._local_data[r_idx, cs])

        if mpc.pid == _ratio_idx + 1:
            adjusted_idx = r_idx - self._ratios[:_ratio_idx].sum()
            return MPP._getitem_2_dim_core(mpc, self, (adjusted_idx, cs), _ratios, S1=Tuple[int])
            
        return MPP[Tuple[int], dtype](
            _mpc=self._mpc,
            _ratios=_ratios)
        
    def _setitem_2_dim(self, idx: int, value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 1:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        assert value._ratios.sum() == 1, "Not implemented yet: setitem operands should be at the same partition/party for now"
        
        reference_pid = mpc.pid - 1  # Skip CP0
        
        if reference_pid == argmax(value._ratios):
            adjusted_idx = idx - self._ratios[:reference_pid].sum()
            assert 0 <= adjusted_idx < self._ratios[reference_pid], "MPP: setitem index out of bound"
            MPP._setitem_2_dim_core(mpc, self, adjusted_idx, value)
    
    def _setitem_2_dim(self, s: slice, value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 2:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        
        start, stop, _, _ = s.adjust_indices(self.cohort_shape[0])
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        reference_pid = mpc.pid - 1
        
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_slice = self._adjust_row_slice(start, stop)
            MPP._setitem_2_dim_core(mpc, self, adjusted_slice, value)
    
    def _setitem_2_dim(self, s: Tuple[slice, slice], value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 2:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        
        rs, cs = s
        start, stop, _, _ = rs.adjust_indices(self.cohort_shape[0])
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        reference_pid = mpc.pid - 1
        
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_rs = self._adjust_row_slice(start, stop)
            MPP._setitem_2_dim_core(mpc, self, (adjusted_rs, cs), value)
    
    def _setitem_2_dim(self, s: Tuple[slice, int], value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 2:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        
        rs, c_idx = s
        start, stop, _, _ = rs.adjust_indices(self.cohort_shape[0])
        _start_ratio_idx = self._find_idx_in_ratios(start)
        _stop_ratio_idx = self._find_idx_in_ratios(stop)
        reference_pid = mpc.pid - 1
        
        if _start_ratio_idx <= reference_pid <= _stop_ratio_idx:
            adjusted_rs = self._adjust_row_slice(start, stop)
            MPP._setitem_2_dim_core(mpc, self, (adjusted_rs, c_idx), value)
    
    def _setitem_2_dim(self, s: Tuple[int, slice], value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 1:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        assert value._ratios.sum() == 1, "Not implemented yet: setitem operands should be at the same partition/party for now"
        
        r_idx, cs = s
        reference_pid = mpc.pid - 1  # Skip CP0
        
        if reference_pid == argmax(value._ratios):
            adjusted_r_idx = r_idx - self._ratios[:reference_pid].sum()
            assert 0 <= adjusted_r_idx < self._ratios[reference_pid], "MPP: setitem index out of bound"
            MPP._setitem_2_dim_core(mpc, self, (adjusted_r_idx, cs), value)
    
    def _setitem_2_dim(self, s: Tuple[int, int], value: MPP):
        mpc = self._mpc
        if staticlen(S) != 2 or staticlen(value.S) != 1:
            compile_error("MPP: invalid shapes for setitem")

        assert not self._transposed, "Not implemented yet: setitem for transposed MPP"
        assert value._ratios.sum() == 1, "Not implemented yet: setitem operands should be at the same partition/party for now"
        
        r_idx, c_idx = s
        reference_pid = mpc.pid - 1  # Skip CP0
        
        if reference_pid == argmax(value._ratios):
            adjusted_r_idx = r_idx - self._ratios[:reference_pid].sum()
            assert 0 <= adjusted_r_idx < self._ratios[reference_pid], "MPP: setitem index out of bound"
            cs = slice(start=c_idx, stop=c_idx + 1, step=1)
            MPP._setitem_2_dim_core(mpc, self, (adjusted_r_idx, cs), value)

    def _getitem_1_dim(self, indices) -> MPP[S, dtype]:
        if isinstance(indices, slice):
            compile_error("MPP: slicing 1-dim MPP is not implemented yet")
        
        if isinstance(indices, tuple):
            compile_error("MPP: cannot slice 1-dim MPP --- too many indices")
        
        idx = indices
        mpc = self._mpc
        if staticlen(S) != 1: compile_error("MPP: cannot do 1-dim getitem from non-1-dim MPP")
        assert self._ratios.sum() == 1, "MPP: 1-dimensional MPP should be present at one party only"

        _local_data = ndarray[S, dtype]()
        _encryption_unified = Ciphertensor[Ciphertext]()

        if mpc.pid == 0:
            return MPP[S, dtype](
                _mpc=self._mpc,
                _ratios=self._ratios.copy(),
                _local_data=self._local_data[idx:idx+1])

        with self.partition_aligner() as aligner:
            if not self.is_empty():
                if self.is_local():
                    _local_data = self._local_data[idx:idx+1]
                elif self.is_semi_encrypted():
                    idx_up_bound = 0
                    if self._encryption_left:
                        assert self._encryption_left.ndim == 1, "MPP: invalid dimension of ciphertensor"
                        idx_up_bound += self._encryption_left.shape[-1]
                        if idx < idx_up_bound:
                            _encryption_unified = self._encryption_left._getitem_1_dim(mpc, idx)

                            return MPP[S, dtype](
                                _mpc=self._mpc,
                                _ratios=self._ratios.copy(),
                                _encryption_unified=_encryption_unified)
                    
                    idx_low_bound = idx_up_bound
                    idx_up_bound += self._local_data.shape[-1]
                    if idx < idx_up_bound:
                        _local_data = self._local_data[idx - idx_low_bound:idx - idx_low_bound + 1]

                        return MPP[S, dtype](
                            _mpc=self._mpc,
                            _ratios=self._ratios.copy(),
                            _local_data=_local_data)
                    
                    idx_low_bound = idx_up_bound
                    if self._encryption_right:
                        assert self._encryption_right.ndim == 1, "MPP: invalid dimension of ciphertensor"
                        idx_up_bound += self._encryption_right.shape[-1]
                        if idx < idx_up_bound:
                            _encryption_unified = self._encryption_right._getitem_1_dim(mpc, idx - idx_low_bound)

                            return MPP[S, dtype](
                                _mpc=self._mpc,
                                _ratios=self._ratios.copy(),
                                _encryption_unified=_encryption_unified)
                    
                    raise ValueError("MPP: index out of bound")
                else:
                    assert self.has_unified_encryption(), "MPP: must have unified encryption if not local and semi encrypted"
                    _encryption_unified = self._encryption_unified._getitem_1_dim(mpc, idx)
        
            return aligner.new_mpp(
                _local_data=_local_data,
                _encryption_unified=_encryption_unified)
    
    def _setitem_1_dim(self, indices, value: MPP):
        if isinstance(indices, slice):
            compile_error("MPP: slicing 1-dim MPP is not implemented yet")
        
        if isinstance(indices, tuple):
            compile_error("MPP: cannot slice 1-dim MPP --- too many indices")

        idx = indices
        mpc = self._mpc
        assert staticlen(S) == staticlen(value.S) == 1, "MPP: 1-dim setitem expects 1-dim operands"
        assert self._ratios == value._ratios, "MPP: partitioning missmatch in 1-dim setitem"
        assert self._ratios.sum() == value._ratios.sum(), "MPP: invalid partition ratios for 1-dim setitem"
        
        if mpc.pid == 0:
            self._local_data[idx] = value._local_data[0]
            return

        with self.partition_aligner(), value.partition_aligner():
            if not self.is_empty():
                assert value.shape == (1,), "MPP: 1-dim setitem operand should contain a single value"
                assert not value.is_semi_encrypted(), "MPP: single-element setitem value should not be semi-encrypted"

                if self.is_full_encrypted() or value.is_full_encrypted():
                    self.unify_encryption()
                    _value_cp = value.copy()
                    _value_cp.unify_encryption()
                    self._encryption_unified._setitem(mpc, idx, _value_cp._encryption_unified)
                else:
                    assert self.is_local() or self.is_semi_encrypted(), "MPP: ivalid self operand in 1-dim setitem"
                    assert value.is_local(), "MPP: ivalid value operand in 1-dim setitem"
                    
                    border = 0
                    if self._encryption_left:
                        border = self._encryption_left.shape[-1]
                        if idx < border:
                            _value_cp = value.copy()
                            _value_cp.unify_encryption()
                            self._encryption_left._setitem(mpc, idx, _value_cp._encryption_unified)
                            return
                    
                    if idx < border + self._local_data.shape[-1]:
                        self._local_data[idx - border] = value._local_data[0]
                        return
                    border += self._local_data.shape[-1]

                    assert bool(self._encryption_right) and idx < border + self._encryption_right.shape[-1], "MPP: 1-dim setitem index out of bound"
                    _value_cp = value.copy()
                    _value_cp.unify_encryption()
                    self._encryption_right._setitem(mpc, idx - border, _value_cp._encryption_unified)

    def _align_semi_encryptions(self, other: MPP) -> Tuple[Ciphertensor[Ciphertext], ndarray, Ciphertensor[Ciphertext]]:
        mpc = self._mpc
        assert self.is_semi_encrypted() or other.is_semi_encrypted(), "MPP: at least on of the MPPs needs to be semi-encrypted to align the semi ancryptions"

        if self.is_semi_encrypted() and other.is_semi_encrypted():
            if self._encryption_left:
                assert bool(other._encryption_left) and self._encryption_left.shape[-1] == other._encryption_left.shape[-1], "MPP: left semi encryption shape missmatch"
            if self._encryption_right:
                assert bool(other._encryption_right) and self._encryption_right.shape[-1] == other._encryption_right.shape[-1], "MPP: right semi encryption shape missmatch"
            
            assert self.has_local_data() and other.has_local_data(), "MPP: semi-encrypted MPP should have local data"
            return other._encryption_left, other._local_data, other._encryption_right
        
        elif self.is_local():
            if other._encryption_left:
                left_border = other._encryption_left.shape[-1]
                self._encryption_left = Ciphertensor[Ciphertext].enc(mpc, self._local_data._slice_cols(0, left_border))
                self._local_data = self._local_data._slice_cols(left_border, self._local_data.shape[-1])
            if other._encryption_right:
                right_border = -other._encryption_right.shape[-1]
                self._encryption_right = Ciphertensor[Ciphertext].enc(mpc, self._local_data._slice_cols(right_border, self._local_data.shape[-1]))
                self._local_data = self._local_data._slice_cols(0, right_border)
            
            return other._encryption_left, other._local_data, other._encryption_right
        
        else:  # other is local
            _encryption_left = Ciphertensor[Ciphertext]()
            _local_data = other._local_data
            _encryption_right = Ciphertensor[Ciphertext]()

            if self._encryption_left:
                left_border = self._encryption_left.shape[-1]
                _encryption_left = Ciphertensor[Ciphertext].enc(mpc, other._local_data._slice_cols(0, left_border))
                _local_data = _local_data._slice_cols(left_border, _local_data.shape[-1])
            if self._encryption_right:
                right_border = -self._encryption_right.shape[-1]
                _encryption_right = Ciphertensor[Ciphertext].enc(mpc, _local_data._slice_cols(right_border, _local_data.shape[-1]))
                _local_data = _local_data._slice_cols(0, right_border)
            
            return _encryption_left, _local_data, _encryption_right

    def _rows_count(self) -> int:
        if self._mpc.pid == 0: return self._ratios.sum()
        return self._ratios[self._mpc.pid - 1]
    
    def _find_idx_in_ratios(self, idx: int) -> int:
        _ratio_idx = 0
        _ratio_sum = 0
        for count in self._ratios:
            _ratio_sum += count
            if idx >= _ratio_sum:
                _ratio_idx += 1
            else: break
        return _ratio_idx

    def _adjust_row_slice(self, start, stop):
        reference_pid = self._mpc.pid - 1
        ratios_sum = self._ratios[:reference_pid].sum()
        adjusted_start = max(start - ratios_sum, 0)
        adjusted_stop = min(stop - ratios_sum, self._ratios[reference_pid])

        assert 0 <= adjusted_start < self._ratios[reference_pid], "MPP: index out of bound"
        assert 0 <= adjusted_stop <= self._ratios[reference_pid], "MPP: index out of bound"
        
        return slice(start=adjusted_start, stop=adjusted_stop, step=1)
    
    def _get_sliced_ratios(self, _start_ratio_idx: int, _stop_ratio_idx: int, start: int, stop: int) -> List[int]:
        _ratios = []
        _ratios_sum = 0
        
        for i, ratio in enumerate(self._ratios):
            _ratios_sum += ratio
            if i < _start_ratio_idx or i > _stop_ratio_idx:
                _ratios.append(0)
            elif i == _start_ratio_idx:
                _ratios.append(start - _ratios_sum)
            elif i == _stop_ratio_idx:
                _ratios.append(stop - _ratios_sum)
            else:
                _ratios.append(self._ratios[i])
        
        return _ratios
    
    # Internal typechecker hack
    @property
    def _internal_type(self) -> dtype:
        return dtype()


class MPPAligner[S, dtype]:
    mpp: MPP[S, dtype]

    def __init__(self, mpp: MPP[S, dtype]):
        assert mpp._mpc.pid, "MPPAligner should not be called at CP0"
        self.mpp = mpp

    def __enter__(self):
        if not self.mpp.cohort_is_aligned():
            MPPAligner._align(self.mpp)

    def __exit__(self):
        if not self.mpp.cohort_is_aligned():
            MPPAligner._revert(self.mpp)
    
    def new_mpp(self,
            _local_data=ndarray[S, dtype](),
            _encryption_left=Ciphertensor[Ciphertext](),
            _encryption_right=Ciphertensor[Ciphertext](),
            _encryption_unified=Ciphertensor[Ciphertext]()) -> MPP[S, dtype]:
        
        if _encryption_left:
            _encryption_left = MPPAligner._revert_encryption(self.mpp._mpc, _encryption_left, self.mpp._ratios, S=self.mpp.S)
        if _encryption_right:
            _encryption_right = MPPAligner._revert_encryption(self.mpp._mpc, _encryption_right, self.mpp._ratios, S=self.mpp.S)
        if _encryption_unified:
            _encryption_unified = MPPAligner._revert_encryption(self.mpp._mpc, _encryption_unified, self.mpp._ratios, S=self.mpp.S)
        
        return MPP[S, dtype](
            _mpc=self.mpp._mpc,
            _ratios=self.mpp._ratios.copy(),
            _local_data=_local_data,
            _encryption_left=_encryption_left,
            _encryption_right=_encryption_right,
            _encryption_unified=_encryption_unified,
            _transposed=self.mpp._transposed)
    
    @staticmethod
    def _align(mpp: MPP[S, dtype]):
        mpc = mpp._mpc
        if mpc.council(mpp._encryption_unified).any():
            mpp._encryption_unified = MPPAligner._align_encryption(mpc, mpp._encryption_unified, mpp._ratios, S=S)
        if mpc.council(mpp._encryption_left).any():
            mpp._encryption_left = MPPAligner._align_encryption(mpc, mpp._encryption_left, mpp._ratios, S=S)
        if mpc.council(mpp._encryption_right).any():
            mpp._encryption_right = MPPAligner._align_encryption(mpc, mpp._encryption_right, mpp._ratios, S=S)
    
    @staticmethod
    def _revert(mpp: MPP[S, dtype]):
        mpc = mpp._mpc
        if mpp._encryption_unified:
            mpp._encryption_unified = MPPAligner._revert_encryption(mpc, mpp._encryption_unified, mpp._ratios, S=S)
        if mpp._encryption_left:
            mpp._encryption_left = MPPAligner._revert_encryption(mpc, mpp._encryption_left, mpp._ratios, S=S)
        if mpp._encryption_right:
            mpp._encryption_right = MPPAligner._revert_encryption(mpc, mpp._encryption_right, mpp._ratios, S=S)
    
    @staticmethod
    def _align_encryption[S](mpc, encryption: Ciphertensor[Ciphertext], ratios: List[int]):
        assert ratios.sum() > 0, "MPPAligner: nothing to align -- MPP empty"
        slots = mpc.he.crypto_params.params.slots()
        ref_pid = argmax(ratios) + 1
        cols = mpc.comms.broadcast_from(encryption.shape, ref_pid)[-1]
        
        if staticlen(S) == 1:
            return encryption if mpc.pid == ref_pid else Ciphertensor[Ciphertext].placeholder([cols], slots)
        
        if staticlen(S) != 2:
            compile_error("MPPAligner: invalid dimension")

        if ratios[mpc.pid - 1] == max(ratios):
            return encryption
        
        _encryption_placeholder = Ciphertensor[Ciphertext].placeholder([max(ratios), cols], slots)
        
        assert not (ratios[mpc.pid - 1] > 0 ^ len(encryption._data) > 0), "MPPAligner: invalid encryption"
        
        for i, cipher in enumerate(encryption._data):
            _encryption_placeholder._data[i] = cipher

        return _encryption_placeholder
    
    @staticmethod
    def _revert_encryption[S](mpc, encryption: Ciphertensor[Ciphertext], ratios: List[int]):
        assert ratios.sum() > 0, "MPPAligner: nothing to align -- MPP empty"
        ref_pid = argmax(ratios) + 1
        
        if staticlen(S) == 1:
            return encryption if mpc.pid == ref_pid else Ciphertensor[Ciphertext]()
        
        if staticlen(S) != 2:
            compile_error("MPPAligner: invalid dimension")
        
        if ratios[mpc.pid - 1] == max(ratios):
            return encryption
        if ratios[mpc.pid - 1] == 0:
            return Ciphertensor[Ciphertext]()

        return encryption[:ratios[mpc.pid - 1]]


@extend
class MPP:
    def partition_aligner(self):
        return MPPAligner(self)


@extend
class ndarray:
    def _do_elem_wise_op_public(self, other_mpp: MPP[S, T], elem_wise_op) -> Tuple[ndarray[S, T], Ciphertensor[Ciphertext], Ciphertensor[Ciphertext], Ciphertensor[Ciphertext]]:
        mpc = other_mpp._mpc
        assert self.shape[-1] == other_mpp.shape[-1], "ndarray: shapes missmatch in public elem-wise MPP operation"
        _local_data = ndarray[S, T]()
        _encryption_left = Ciphertensor[Ciphertext]()
        _encryption_right = Ciphertensor[Ciphertext]()
        _encryption_unified = Ciphertensor[Ciphertext]()

        if mpc.pid == 0:
            return (self, _encryption_left, _encryption_right, _encryption_unified)

        if staticlen(S) == 2:
            if self.shape[0] == other_mpp._ratios.sum():
                reference_pid = mpc.pid - 1  # Avoid CP0
                start = other_mpp._ratios[:reference_pid].sum()
                end = start + other_mpp._ratios[reference_pid]
                self = self[start:end]
            elif not self.shape[0] == other_mpp.shape[0]:
                raise ValueError("ndarray: shapes missmatch in public elem-wise MPP operation")
        
        col_end = 0
        if other_mpp.is_local():
            _local_data = elem_wise_op(mpc, self, other_mpp._local_data)
        elif other_mpp.has_unified_encryption():
            _encryption_unified = elem_wise_op(mpc, self, other_mpp._encryption_unified)
        elif other_mpp.has_partial_encryption():
            if other_mpp._encryption_left:
                col_end = other_mpp._encryption_left.shape[-1]
                _encryption_left = elem_wise_op(mpc, self._slice_cols(0, col_end), other_mpp._encryption_left)
            assert other_mpp.has_local_data(), "ndarray: MPP must have local data if it has partial encryption"
            col_start = col_end
            col_end = col_start + other_mpp._local_data.shape[-1]
            _local_data = elem_wise_op(mpc, self._slice_cols(col_start, col_end), other_mpp._local_data)
            if other_mpp._encryption_right:
                col_start = col_end
                _encryption_right = elem_wise_op(mpc, self._slice_cols(col_start, self.shape[-1]), other_mpp._encryption_right)
        else:
            raise ValueError("ndarray: invalid MPP partition")

        return (_local_data, _encryption_left, _encryption_right, _encryption_unified)
