from sequre import sequre_beaver


@sequre_beaver
def householder(mpc, x):
    xdot = mpc.dot(x, x)
    shift = mpc.sqrt(xdot) * ((x[0] > 0) * 2 - 1)
    v = x.copy()
    v[0] = v[0] + shift
    return  v / mpc.sqrt((xdot + x[0] * shift) * 2)


@sequre_beaver
def qr_fact_square(mpc, A):
        n = len(A)
        R = A.zeros()
        Q = A.zeros()
        B = A.zeros()

        # Ap = A if self.pid != 0 else [[TP(0) for _ in range(n)] for _ in range(n)]
        # one = TypeOps.double_to_fp(1.0, NBIT_K, NBIT_F)
        Ap = A

        for i in range(n - 1):
            # v = [self.householder(Ap[0])]
            # vt = v.transpose() if self.pid != 0 else [[TP(0)] for _ in range(len(Ap[0]))]

            # P = self.arithmetic.multiply_matmul(vt, v)
            # P = self.fp.trunc(P, NBIT_K + NBIT_F, NBIT_F)

            # if self.pid > 0:
            #     P *= -2
            #     P %= field
            #     if self.pid == 1:
            #         for i in range(P.shape()[1]):
            #             P[i][i] += one
            #             P[i][i] %= field
            v = householder(mpc, Ap[0]).expand_dims()
            print i, 5, mpc.pid
            P = Ap.I - mpc.matmul(v.T, v) * 2

            print i, 10, mpc.pid

            # B = [[TP(0) for _ in range(n - i)] for _ in range(n - i)]  # zeros((n - i, n - i))
            # if i == 0:
            #     Q = P
            #     B = self.arithmetic.multiply_matmul(Ap, P)
            #     B = self.fp.trunc(B, NBIT_K + NBIT_F, NBIT_F)
            # else:
            #     Qsub = [[TP(0) for _ in range(n)] for _ in range(n - i)]  # zeros((n - i, n))
            #     if self.pid > 0:
            #         Qsub[:n - i] = Q[i:n]

            #     left = [P, Ap]
            #     right = [Qsub, P]

            #     prod = self.arithmetic.multiply_mat_bulk(left, right)
            #     # TODO: parallelize Trunc
            #     prod[0] = self.fp.trunc(prod[0], NBIT_K + NBIT_F, NBIT_F)
            #     prod[1] = self.fp.trunc(prod[1], NBIT_K + NBIT_F, NBIT_F)

            #     if self.pid > 0:
            #         Q[i:n] = prod[0][:n - i]
            #         B = prod[1]
            Q[i:] = P if i == 0 else mpc.matmul(P, Q[i:])[:-i]

            print i, 20, mpc.pid

            # Ap = [[TP(0) for _ in range(n - i - 1)] for _ in range(n - i - 1)]  # zeros((n - i - 1, n - i - 1))
            # if self.pid > 0:
            #     # R[i:n, i] = B[:n-i, 0]  # TODO: Implement support for advanced slicing
            #     for j in range(n - i):
            #         R[j + i][i] = B[j][0]
            #     if i == n - 2: R[n - 1][n - 1] = B[1][1]
            #     # Ap[:n - i - 1, :n - i - 1] = B[1:n - i, 1:n - i]  TODO: Implement support for advanced slicing
            #     for j in range(n - i - 1):
            #         for k in range(n - i - 1):
            #             Ap[j][k] = B[j + 1][k + 1]
            B = mpc.matmul(Ap, P)  
            R[i:, i] = B[:, 0]
            Ap = B[1:, 1:]

            print i, 30, mpc.pid
        
        R[-1][-1] = B[1][1]

        return Q, R
