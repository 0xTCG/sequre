@sequre
def householder(mpc, x):
    # xr, xm = self.arithmetic.__beaver_partition(x)

    # xdot = [self.arithmetic.beaver_inner_prod(xr, xm)]
    # xdot = self.arithmetic.__beaver_reconstruct(xdot)
    # xdot = self.fp.trunc(xdot)
    xdot = mpc.dot(x, x)

    # Bottleneck
    # xnorm, _ = self.fp.fp_sqrt(xdot)
    xnorm = mpc.sqrt(xdot)

    # x1 = [x[0]]
    # x1sign = self.boolean.is_positive(x1)
    # x1sign = (x1sign + x1sign) % field
    # if self.pid == 1:
    #     x1sign[0] = (x1sign[0] - 1) % field
    x1sign = (x[0] > 0) * 2 - 1

    # shift = self.arithmetic.multiply(xnorm, x1sign)
    shift = xnorm * x1sign
    
    # sr, sm = self.arithmetic.__beaver_partition(shift[0])
    # xr_0 = [xr[0]]
    # xm_0 = [xm[0]]
    # dot_shift = self.arithmetic.__beaver_mult(xr_0, xm_0, sr, sm)
    # dot_shift = self.arithmetic.__beaver_reconstruct(dot_shift)
    # dot_shift = self.fp.trunc(dot_shift)
    dot_shift = x[0] * shift

    # vdot = (((xdot + dot_shift) % field) * 2) % field if self.pid > 0 else [TP(0)]
    vdot = (xdot + dot_shift) * 2

    # Bottleneck
    # _, vnorm_inv = self.fp.fp_sqrt(vdot)
    vnorm_inv = 1 / sq.sqrt(vdot)

    # if self.pid > 0:
    #     xr[0] = (xr[0] + sr) % field
    # xm[0] = (xm[0] + sm) % field
    v = x.copy()
    v[0] = v[0] + shift

    # invr, invm = self.arithmetic.__beaver_partition(vnorm_inv[0])
    # v = self.arithmetic.__beaver_mult(xr, xm, invr, invm)
    # v = self.arithmetic.__beaver_reconstruct(v)
    # v = self.fp.trunc(v)

    return v * vnorm_inv
