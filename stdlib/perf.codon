import time


@extend
class Dict:
    def pprint(self):
        for k, v in self.items():
            print(f"\t{k}:\t{v}")


class PerfInterval(time.TimeInterval):
    """
    Utility class for performance logging
    """

    sep: str
    prefix: str
    log_path: str

    def __init__(self, msg: str, sep: str, prefix: str, log_path: str = "perf.txt"):
        super().__init__(0, msg)

        self.sep = sep
        self.prefix = prefix
        self.log_path = log_path

    def __exit__(self):
        print(self.report(self.msg))

        with open(self.log_path, "a+") as f:
            f.write(f"{self.prefix}{round(self.elapsed(), 7):.7f}{self.sep}")
            

def perf_timing(msg: str = "", sep: str = " | ", prefix: str = "") -> PerfInterval:
    """
    Example usage:

    .. code-block:: python

        from time import timing
        with perf_timing('foo function'):
            foo()  # prints runtime of foo
    """
    return PerfInterval(msg, sep, prefix)


GLOBAL_RUNTIME = Dict[str, float]()
GLOBAL_COUNTER = Dict[str, int]()


def perf_profile(name):
    def decorator_profile(func):
        def wrapper(*args, **kwargs):
            s = time.time()
            value = func(*args, **kwargs)
            e = time.time()
            if name in GLOBAL_RUNTIME: GLOBAL_RUNTIME[name] += (e - s)
            else: GLOBAL_RUNTIME[name] = (e - s)
            if name in GLOBAL_COUNTER: GLOBAL_COUNTER[name] += 1
            else: GLOBAL_COUNTER[name] = 1
            return value
        return wrapper
    return decorator_profile


def perf_print_stats():
    print("Runtime:")
    GLOBAL_RUNTIME.pprint()
    print("Invocation count:\n")
    GLOBAL_COUNTER.pprint()
