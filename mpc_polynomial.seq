import utils.param as param

from mpc_prg import MPCPRG
from mpc_comms import MPCComms
from mpc_arithmetic import MPCArithmetic
from utils.type_ops import TypeOps
from utils.utils import rand_mat


class MPCPolynomial[TP]:
    # Performance warning: See if explicit TP(number) conversions introduce overhead.
    # Performance warning: See if list comprehensions instead of allocate/append introduce overhead.
    pid: int
    primes: dict[int, TP]
    prg: MPCPRG
    comms: MPCComms[TP]
    arithmetic: MPCArithmetic[TP]

    pascal_cache: dict[int, list[list[int]]]
    table_cache: dict[int, list[list[TP]]]
    table_type_modular: dict[int, bool]
    table_field_index: dict[int, int]
    lagrange_cache: dict[int, list[list[TP]]]

    def __init__(self: MPCPolynomial[TP],
                 pid: int, primes: dict[int, TP],
                 prg: MPCPRG,
                 comms: MPCComms[TP],
                 arithmetic: MPCArithmetic[TP]):
        self.pid = pid
        self.primes = primes
        self.prg = prg
        self.comms = comms
        self.arithmetic = arithmetic

        self.pascal_cache = dict[int, list[list[int]]]()
        self.table_cache = dict[int, list[list[TP]]]()
        self.table_type_modular = dict[int, bool]()
        self.table_field_index = dict[int, int]()
        self.lagrange_cache = dict[int, list[list[TP]]]()

        self.__setup_tables()
    
    def lagrange_interp_simple(self: MPCPolynomial[TP], y: list[TP], field: TP) -> list[TP]:
        n: int = len(y)
        x: list[int] = [i for i in range(1, n + 1)]

        return self.lagrange_interp(x, y, field)

    def table_lookup(self: MPCPolynomial[TP], x: list[TP], table_id: int, field: TP = param.BASE_P) -> list[list[TP]]:
        # TODO: Warning! Negative x value might cause bad results
        return self.evaluate_poly(x, self.lagrange_cache[table_id], field=field)
    
    def lagrange_interp(self: MPCPolynomial[TP], x: list[int], y: list[TP], field: TP = param.BASE_P) -> list[TP]:
        n: int = len(y)

        inv_table = dict[int, TP]()
        for i in range(n):
            for j in range(n):
                if i == j:
                    continue

                key: int = abs(x[i] - x[j])
                if key not in inv_table:
                    inv_table[key] = TypeOps.mod_inv(key, field)
        
        # Initialize numer and denom_inv
        numer: list[list[TP]] = [[TP(0) for _ in range(n)] for _ in range(n)]  # zeros((n, n))
        denom_inv: list[TP] = [TP(1) for _ in range(n)]  # ones(n)
        numer[0][:] = y % field

        for i in range(n):
            for j in range(n):
                if i == j:
                    continue

                for k in range(n - 1, -1, -1):
                    numer[k][j] = ((TP(0) if k == 0 else numer[k - 1][j]) - numer[k][j] * x[i]) % field
                denom_inv[i] = (denom_inv[i] * (TP(1) if x[i] > x[j] else TP(-1)) * inv_table[abs(x[i] - x[j])]) % field

        numer_dot: list[list[TP]] = [(n * denom_inv) % field for n in numer]
        numer_sum: list[TP] = [TP(0) for _ in range(n)]  # ones(n)

        for i in range(n):
            for e in numer_dot[i]:
                numer_sum[i] = (numer_sum[i] + e) % field

        return numer_sum
 
    def get_pascal_matrix(self: MPCPolynomial[TP], power: int) -> list[list[int]]:
        if power not in self.pascal_cache:
            pascal_matrix: list[list[int]] = self.calculate_pascal_matrix(power)
            self.pascal_cache[power] = pascal_matrix

        return self.pascal_cache[power]
    
    def calculate_pascal_matrix(self: MPCPolynomial[TP], pow: int) -> list[list[int]]:
        t: list[list[int]] = [[0 for _ in range(pow + 1)] for _ in range(pow + 1)]  # zeros((pow + 1, pow + 1))
        for i in range(pow + 1):
            for j in range(pow + 1):
                if j > i:
                    t[i][j] = 0
                elif j == 0 or j == i:
                    t[i][j] = 1
                else:
                    t[i][j] = t[i - 1][j - 1] + t[i - 1][j]
        
        return t

    def powers(self: MPCPolynomial[TP], x: list[TP], power: int, field: TP = param.BASE_P) -> list[list[TP]]:
        assert power >= 1

        n: int = len(x)
        b: list[list[TP]] = [[TP(0) for _ in range(n)] for _ in range(power + 1)]  # zeros((power + 1, n))
        ones: list[TP] = [TP(1) for _ in range(n)]
        
        if power == 1:
            if self.pid > 0:
                if self.pid == 1:
                    b[0] += ones
                b[1][:] = x
        else:  # power > 1
            x_r, r = self.arithmetic.beaver_partition_vec(x, field=field)
            r_pow: list[list[TP]] = [[TP(0) for _ in range(n)] for _ in range(power - 1)]

            if self.pid == 0:
                r_pow[0][:] = (r * r) % field
                
                for p in range(1, len(r_pow)):
                    r_pow[p][:] = (r_pow[p - 1] * r) % field

                self.prg.switch_seed(1)
                r_: list[list[TP]] = rand_mat([power - 1, n], field)
                self.prg.restore_seed(1)

                r_pow = (r_pow - r_) % field
                self.comms.send_data(r_pow, 2)
            else:
                if self.pid == 1:
                    self.prg.switch_seed(0)
                    r_pow: list[list[TP]] = rand_mat([power - 1, n], field)
                    self.prg.restore_seed(0)
                else:
                    r_pow = self.comms.receive_matrix(0, [power - 1, n])

                x_r_pow: list[list[TP]] = [[TP(0) for _ in range(n)] for _ in range(power - 1)]
                x_r_pow[0][:] = (x_r * x_r) % field
                
                for p in range(1, len(x_r_pow)):
                    x_r_pow[p][:] = (x_r_pow[p - 1] * x_r) % field

                pascal_matrix: list[list[int]] = self.get_pascal_matrix(power)

                if self.pid == 1:
                    b[0][:] = (b[0] + ones) % field
                b[1][:] = x

                for p in range(2, power + 1):
                    if self.pid == 1:
                        b[p][:] = x_r_pow[p - 2]

                    if p == 2:
                        b[p] = (b[p] + (((x_r * r) % field) * pascal_matrix[p][1]) % field) % field
                    else:
                        b[p] = (b[p] + (((x_r_pow[p - 3] * r) % field) * pascal_matrix[p][1]) % field) % field

                        for j in range(2, p - 1):
                            b[p] = (b[p] + (((x_r_pow[p - 2 - j] * r_pow[j - 2]) % field) * pascal_matrix[p][j]) % field) % field
                        
                        b[p] = (b[p] + (((x_r * r_pow[p - 3]) % field) * pascal_matrix[p][p - 1]) % field) % field

                    b[p] = (b[p] + r_pow[p - 2]) % field
        
        return b
    
    def evaluate_poly(self: MPCPolynomial[TP], x: list[TP], coeff: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        n: int = len(x)
        npoly: int = len(coeff)
        deg: int = len(coeff[0]) - 1

        pows: list[list[TP]] = self.powers(x, deg, field)

        if self.pid > 0:
            return coeff.mult(pows, field)

        return [[TP(0) for _ in range(n)] for _ in range(npoly)]  # zeros((npoly, n))
    
    def __setup_tables(self: MPCPolynomial[TP]):
        # Table 0
        table: list[list[TP]] = [[TP(1), TP(0)]] if self.pid > 0 else [[TP(0), TP(0)]]

        self.table_type_modular[0] = True
        self.table_cache[0] = copy(table)
        self.table_field_index[0] = 2

        # Table 1
        half_len: int = param.NBIT_K // 2
        table = [list[TP](half_len + 1), list[TP](half_len + 1)]  # zeros((2, half_len + 1))
        table[0].append(TP(1))
        table[1].append(TP(1))
        # Warning: Not having table instantiated to zeros might be problematic for CP0
        if self.pid > 0:
            for i in range(1, half_len + 1):
                table[0].append(table[0][i - 1] * 2)
                table[1].append(table[1][i - 1] * 4)
        else:
            for i in range(1, half_len + 1):
                table[0].append(TP(0))
                table[1].append(TP(0))

        self.table_type_modular[1] = True
        self.table_cache[1] = copy(table)
        self.table_field_index[1] = 1

        # Table 2: parameters (intercept, slope) for piecewise-linear approximation
        # of negative log-sigmoid function
        table = [list[TP](64), list[TP](64)]  # zeros((2, 64))
        # Warning: Not having table instantiated to zeros might be problematic for CP0
        if self.pid > 0:
            with open(param.SIGMOID_APPROX_PATH) as f:
                for line, _ in zip(f, range(64)):
                    intercept, slope = line.split()
                    fp_intercept: int = TypeOps.double_to_fp(
                        float(intercept), param.NBIT_K, param.NBIT_F)
                    fp_slope: int = TypeOps.double_to_fp(float(slope), param.NBIT_K, param.NBIT_F)

                    table[0].append(fp_intercept)
                    table[1].append(fp_slope)
        else:
            for i in range(64):
                table[0].append(TP(0))
                table[1].append(TP(0))

        self.table_type_modular[2] = False
        self.table_cache[2] = copy(table)
        self.table_field_index[2] = 0

        for cid in range(len(self.table_cache)):
            nrow: int = len(self.table_cache[cid])
            ncol: int = len(self.table_cache[cid][0])

            self.lagrange_cache[cid] = list[list[TP]](nrow)

            if self.pid > 0:
                for i in range(nrow):
                    x = [0 for _ in range(ncol * (2 if self.table_type_modular[cid] else 1))]
                    y = [TP(0) for _ in range(ncol * (2 if self.table_type_modular[cid] else 1))]

                    for j in range(ncol):
                        x[j] = j + 1
                        y[j] = self.table_cache[cid][i][j]
    
                        if (self.table_type_modular[cid]):
                            x[j + ncol] = x[j] + self.primes[self.table_field_index[cid]]
                            y[j + ncol] = self.table_cache[cid][i][j]
                    
                    self.lagrange_cache[cid].append(self.lagrange_interp(x, y))
            else:
                for _ in range(nrow):
                    self.lagrange_cache[cid].append([TP(0) for _ in range(ncol * (2 if self.table_type_modular[cid] else 1))])
