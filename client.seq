""" GWAS client module """
cimport fork() -> int

import utils.param as param
from mpc_env import MPCEnv
from utils.utils import get_address

from test_protocol import test_protocol
from legacy.py_code import path_exists, unlink


protocols: dict[str, function[bool, MPCEnv, int]] = {
    # 'gwas': None,
    # 'logireg': None,
    'test': test_protocol
}


def client(pid: int, protocol_func: function[bool, MPCEnv, int]):
    # Initialize MPC environment
    mpc = MPCEnv[int](pid)
    print(f"Initialized MPC for {pid}")

    # success: bool = protocol_func(mpc, pid)

    # This is here just to keep P0 online until the end for data transfer
    # In practice, P0 would send data in advance before each phase and go offline
    # if (pid == 0): mpc.comms.receive_bool(2)
    # elif (pid == 2): mpc.comms.send_bool(True, 0)

    # mpc.comms.clean_up()

    # if (success): print(f"Protocol successfully completed for {pid}")
    # else: raise ValueError(f"Protocol abnormally terminated for {pid}")

    print(f'{pid} is alive!')


def invoke(protocol_func: function[bool, MPCEnv, int]):
    for port in param.ALL_PORTS:
        address: str = get_address(port)
        if path_exists(address):
            unlink(address)

    client_func = client(..., protocol_func=protocol_func)
    pid: int = fork()

    if (pid == 0):

        client_func(0)
    else:
        pid: int = fork()
        if (pid == 0): client_func(1)
        else: client_func(2)


import sys
args = sys.argv[1:]

# invoke(protocols[args[0]])


# cimport connect(int, tuple[int, int], int) -> int
cimport socket(int, int, int) -> int
sd = socket(param.AF_UNIX, param.SOCK_STREAM, 0)
if sd < 0: raise ValueError('Socket init failed')

SERVER_PATH: str = "/tmp/server"
serveraddr: tuple[str, int] = (SERVER_PATH, param.AF_UNIX)
cimport bind(int, ptr[tuple[str, int]], int) -> int
a = bind(sd, __ptr__(serveraddr), 1 << 16)
print(a)
