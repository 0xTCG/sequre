import sequre.utils.param as param
from sequre.mpc.env import MPCEnv
from sequre.utils.utils import get_address

from protocols.test import all_test_protocol, lite_test_protocol
from protocols.seq_gwas import gwas_protocol as seq_gwas
from protocols.seq_logireg import logireg_protocol as seq_logireg
from protocols.seq_nn import neural_net_protocol as seq_nn
from protocols.sequre_gwas import gwas_protocol as sequre_gwas
from protocols.sequre_logireg import logireg_protocol as sequre_logireg
from protocols.sequre_nn import neural_net_protocol as sequre_nn

from C import fork() -> int
from C import wait(cobj) -> int
from C import unlink(str) -> int


def client[TP](pid, protocol_func, test_env, modulus):
    # Initialize MPC environment
    mpc = MPCEnv[TP](pid)
    print(f"Initialized MPC for {pid}")

    protocol_func(mpc, test_env, modulus)

    # This is here just to keep P0 online until the end for data transfer
    # In practice, P0 would send data in advance before each phase and go offline
    mpc.comms.sync_parties()
    mpc.comms.clean_up()

    print(f'CP{pid} is done!')


def invoke[TP](protocol_func, test_env, modulus):
    for port in param.ALL_PORTS:
        address = get_address(port)
        unlink(address)

    pid_0 = fork()
    status = 0

    if (pid_0 == 0): client[TP](0, protocol_func, test_env, modulus)
    else:
        pid_1: int = fork()
        if (pid_1 == 0): client[TP](1, protocol_func, test_env, modulus)
        else:
            import time
            s = time.time()
            client[TP](2, protocol_func, test_env, modulus)
            e = time.time()
            print(f'Total client runtime: {e - s}s')
            wait(ptr[byte](__ptr__(status).as_byte()))

import sys
args = sys.argv[1:]
predefined_flags: list[str] = ['--test-run', '--use-ring']
test_env: bool = '--test-run' in args
use_ring: bool = '--use-ring' in args
modulus: param.int_t = param.RING_SIZE if use_ring else param.FIELD_SIZE

args: list[str] = [arg for arg in args if arg not in predefined_flags]
supported_calls = ['test-all', 'test-unit', 'seq-gwas', 'seq-logireg', 'seq-nn', 'sequre-gwas', 'sequre-logireg', 'sequre-nn']

match args[0]:
    case supported_calls[0]: invoke[param.int_t](all_test_protocol[param.int_t], test_env, modulus)
    case supported_calls[1]: invoke[param.int_t](lite_test_protocol[param.int_t], test_env, modulus)
    case supported_calls[2]: invoke[param.int_t](seq_gwas[param.int_t], test_env, modulus)
    case supported_calls[3]: invoke[param.int_t](seq_logireg[param.int_t], test_env, modulus)
    case supported_calls[4]: invoke[param.int_t](seq_nn, test_env, modulus)
    case supported_calls[5]: invoke[param.int_t](sequre_gwas, test_env, modulus)
    case supported_calls[6]: invoke[param.int_t](sequre_logireg, test_env, modulus)
    case supported_calls[7]: invoke[param.int_t](sequre_nn, test_env, modulus)
    case _: raise NotImplementedError(f'Invalid client call: {args[0]}. Should be in {supported_calls}')
