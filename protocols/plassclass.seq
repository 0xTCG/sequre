def kmers_count(fasta, kmer_lens):
    for k in kmer_lens:
        for seq in fasta:
            for kmer in seq:
                counter[k][cannonical(kmer)] += 1
    
    return vectorize(counter)  # concatenate over k's

kmer_len = 5
features = [[0] * 2 ** kmer_len] * len(labels)

def update(label_idx, kmer):
    features[label_idx][min(kmer, ~kmer).as_int()] += 1

for fasta_path, label in zip(fastas, labels):
    FASTA(path_to_fasta) |> seqs |> kmers(1, k=kmer_len) |> update(label_idx, ...)

from sequre import secret_share
secret_share(counter)

from sequre import pool_shares, logireg
features, labels = pool_shares()
weights = logireg(
    mpc, features, labels,
    eta=0.01, epochs=10, relu_alpha=0.1, relu_beta=1)