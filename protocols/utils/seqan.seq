from bio.kmer import Kmer


RANK = {
    'A': 0,
    'C': 1,
    'G': 2,
    'N': 3,
    'T': 4
}

SEQAN_HASH_SEEDS = [
    13572355802537770549u,  # 2**64 / (e/2)
    13043817825332782213u,  # 2**64 / sqrt(2)
    10650232656628343401u,  # 2**64 / sqrt(3)
    16499269484942379435u,  # 2**64 / (sqrt(5)/2)
    4893150838803335377u    # 2**64 / (3*pi/5)
]

def _bit_decompose(value, number_of_bits):
    return [int(bool(value & (1 << i))) for i in range(number_of_bits)]

def _transpose(mat):
    rows, cols = len(mat), len(mat[0])
    new_mat = list[list[int]](cols)

    for i in range(cols):
        row = list[int](rows)
        for j in range(rows):
            row.append(mat[j][i])
        new_mat.append(row)

    return new_mat

def seqan_kmer_encode(kmer, sigma):
    if sigma == 4:
        return u64(int(kmer.as_int()))
    
    hash_value = 0

    for nucleotide in str(kmer):
        hash_value *= sigma
        hash_value += RANK[nucleotide]
    
    return u64(hash_value)

def seqan_ungapped_kmer_encode(seq, sigma):
    for kmer in seq.kmers[Kmer[19]](1):
        yield seqan_kmer_encode(kmer, sigma)

def seqan_ungapped_minimizer_encode(seq, sigma):
    window_size = 0
    seed=0x8F3F73B5CF1C9ADE  # Seed taken from official SeqAn documentation for minimiser_hash
    
    for window in seq.split(window_size, 1):
        kmers = list(window.kmers(1, k=19))
        kmers.extend(list((~window).kmers(1, k=19)))

        hashes = [seqan_kmer_encode(kmer, sigma) for kmer in kmers]
        hashes_pertubed = [hash ^ seed for hash in hashes]

        min_hash_idx = 0
        min_hash_pertubed = hashes_pertubed[0]
        for i, hash_pertubed in enumerate(hashes_pertubed):
            if hash_pertubed < min_hash_pertubed:
                min_hash_idx = i
                min_hash_pertubed = hashes_pertubed[i]
        
        yield hashes[min_hash_idx]

def seqan_ibf_hash(value, seed, bin_size):
    hash_shift = 47u  # Hardcoded for now: the number of leading zeros in bin_size
    # assert hash_shift < 64u
    value *= seed
    value ^= (value >> hash_shift)  # XOR and shift higher bits into lower bits
    value *= 11400714819323198485u  # = 2^64 / golden_ration, to expand h to 64 bit range
    value %= bin_size
    return int(value)

def query_ibf(ibf, hash_f, ibf_hash_count, ibf_bin_size):
    query_result = -1

    for i in range(ibf_hash_count):
        query_result &= ibf[seqan_ibf_hash(hash_f, SEQAN_HASH_SEEDS[i], ibf_bin_size)]
    
    return query_result

def bulk_count(ibf, hashes_f, bin_count, ibf_hash_count, ibf_bin_size):
    bin_queries = _transpose([_bit_decompose(query_ibf(ibf, hash_f, ibf_hash_count, ibf_bin_size), bin_count) for hash_f in hashes_f])
    return [sum(row) for row in bin_queries]

def load_ibf(ibf_path, bin_count):
        technical_bin_count = ((bin_count + 63) // 64) * 64
        bytes_per_bin = (bin_count + 7) // 8
        bytes_count = 0
        next_value = 0
        ibf = []
        ibf_decomposed = []
        
        with open(ibf_path, 'rb') as f:
            while True:
                next_byte = f.read(1)
                
                if not next_byte:
                    break
                
                next_value <<= 8
                next_value += ord(next_byte)
                bytes_count += 1
                
                if bytes_count == bytes_per_bin:
                    ibf.append(next_value)
                    ibf_decomposed.append(_bit_decompose(next_value, technical_bin_count))
                    bytes_count = 0
                    next_value = 0

        return ibf, ibf_decomposed, technical_bin_count
