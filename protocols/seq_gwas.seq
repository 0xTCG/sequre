from sequre.utils.param import *
from sequre.utils.io import \
    read_vector, \
    read_matrix, \
    skip_data
from sequre.utils.primitives import mod_inv
from sequre.types.utils import double_to_fp
from sequre.mpc.env import MPCEnv

from utils.data_sharing import shares_paths
from utils.param import SNP_POS_TEST_FILE, SNP_POS_FILE


def gwas_protocol[TP](mpc: MPCEnv[TP], test_run: bool, modulus: TP = FIELD_PRIME):
    __, pheno_path, __ = shares_paths(mpc, 'gwas', 'pheno', test_run)
    __, cov_path, __ = shares_paths(mpc, 'gwas', 'cov', test_run)
    __, geno_mask_path, geno_path = shares_paths(mpc, 'gwas', 'geno', test_run)
    __, miss_mask_path, miss_path = shares_paths(mpc, 'gwas', 'miss', test_run)
    snp_pos_path = SNP_POS_TEST_FILE if test_run else SNP_POS_FILE
    
    n0 = NUM_INDS
    m0 = NUM_SNPS
    k = NUM_DIM_TO_REDUCE_TO
    kp = k + NUM_OVERSAMPLE
    prime_bytes = mpc.boolean.primes_bytes[0]

    f_geno = open(geno_path)
    f_miss = open(miss_path)
    f_geno_mask = open(geno_mask_path)
    f_miss_mask = open(miss_mask_path)

    temp_vec = list[TP]()
    temp_mat = list[list[TP]]()

    # Read in SNP list
    snp_pos = [0 for _ in range(m0)]

    with open(snp_pos_path) as f:
        for i, line in zip(range(m0), f):
            chrom, pos = line.split()
            snp_pos[i] = int(chrom.strip()) * 10 ** 9 + int(pos.strip())

    # Useful constants
    two = TP(2)
    twoinv = mod_inv(two, modulus)
    fp_one = double_to_fp(1.0, modulus)

    f_pheno = open(pheno_path)
    f_cov = open(cov_path)
    
    pheno = read_vector[TP](f_pheno, n0)
    cov = read_matrix[TP](f_cov, n0, NUM_COVS)

    print("Phenotypes and covariates loaded")

    gkeep1 = [1 for _ in range(m0)]

    if not SKIP_QC:
        print("Taking a pass to calculate locus missing rates")
        gmiss = [TP(0) for _ in range(m0)]
        miss = read_vector[TP](f_miss_mask, m0)
        if mpc.pid == 1:
            miss += read_vector[TP](f_miss, m0)
        
        miss %= modulus
        gmiss += miss
        gmiss %= modulus

        gmiss_ub = (double_to_fp(GMISS_UB, modulus) * n0) % modulus
        secure_gkeep1 = mpc.boolean.less_than_public(gmiss, gmiss_ub, modulus)
        gkeep1 = [int(e) for e in mpc.comms.reveal(secure_gkeep1, modulus)]

        if mpc.pid == 2:
            mpc.comms.send(gkeep1, 0)
        elif mpc.pid == 0:
            gkeep1 = mpc.comms.receive[int](2, m0)
        
        f_miss.seek(0, 0)
        f_miss_mask.seek(0, 0)

    m1 = sum(gkeep1)
    print("n0:", n0, ",", "m1:", m1)

    print("Filtering SNP position vector")
    snp_pos = [snp_pos[i] for i in range(len(snp_pos)) if gkeep1[i]]

    ikeep = [1 for _ in range(n0)]

    if not SKIP_QC:
        print("Taking a pass to calculate individual missing rates and het rates:")
        imiss = [TP(0) for _ in range(n0)]
        ihet = [TP(0) for _ in range(n0)]

        for i in range(n0):
            g = read_matrix[TP](f_geno_mask, 3, m0)
            miss = read_vector[TP](f_miss_mask, m0)

            # Recover secret shares from Beaver partition
            if mpc.pid == 1:
                g += read_matrix(f_geno, 3, m0)
                miss += read_vector[TP](f_miss, m0)
            
            g %= modulus
            miss %= modulus

            # Add to running sum
            for j in range(m0):
                if gkeep1[j] == 1:
                    imiss[i] += miss[j]
                    ihet[i] += g[1][j]
                    imiss[i] %= modulus
                    ihet[i] %= modulus

        # Individual missingness filter
        print("Individual missing rate filter ... ")
        imiss_ub = (double_to_fp(IMISS_UB, modulus) * m1) % modulus
        secure_ikeep = mpc.boolean.less_than_public(imiss, imiss_ub, modulus)

        # Individual heterozygosity filter
        print("Individual heterozygosity rate filter ... ")
        ihet_ub_frac = double_to_fp(HET_UB, modulus)
        ihet_lb_frac = double_to_fp(HET_LB, modulus)

        # Number of observed SNPs per individual
        m1_obs = [TP(0) for _ in range(n0)]
        if mpc.pid > 0:
            for i in range(n0):
                m1_obs[i] = -imiss[i]
                if mpc.pid == 1:
                    m1_obs[i] += m1
                m1_obs[i] %= modulus

        ihet_ub = [TP(0) for _ in range(n0)]
        ihet_lb = [TP(0) for _ in range(n0)]

        if mpc.pid > 0:
            for i in range(n0):
                ihet_ub[i] = (m1_obs[i] * ihet_ub_frac) % modulus
                ihet_lb[i] = (m1_obs[i] * ihet_lb_frac) % modulus
                ihet[i] = (ihet[i] * fp_one) % modulus

        het_filt = mpc.boolean.less_than(ihet, ihet_ub, modulus)
        tmp_vec = mpc.boolean.not_less_than(ihet, ihet_lb, modulus)
        het_filt = mpc.arithmetic.multiply(het_filt, tmp_vec, modulus)

        secure_ikeep = mpc.arithmetic.multiply(secure_ikeep, het_filt, modulus)

        # Reveal samples to be filtered
        ikeep = [int(e) for e in mpc.comms.reveal(secure_ikeep, modulus)]

        if mpc.pid == 2:
            mpc.comms.send(ikeep, 0)
        elif mpc.pid == 0:
            ikeep = mpc.comms.receive[int](2, n0)
        
        f_geno.seek(0, 0)
        f_geno_mask.seek(0, 0)
        f_miss.seek(0, 0)
        f_miss_mask.seek(0, 0)

    n1 = sum(ikeep)
    print("n1:", n1, ",", "m1:", m1)

    print("Filtering phenotypes and covariates")
    pheno = [pheno[i] for i in range(len(pheno)) if ikeep[i]]
    cov = [cov[i] for i in range(len(cov)) if ikeep[i]]

    ctrl = mpc.boolean.flip_bit(pheno, modulus)
    ctrl, ctrl_mask = mpc.arithmetic.__beaver_partition(ctrl, modulus)

    dosage_sum = [TP(0) for _ in range(m1)]
    gmiss = [TP(0) for _ in range(m1)]
    gmiss_ctrl = [TP(0) for _ in range(m1)]
    dosage_sum_ctrl = [TP(0) for _ in range(m1)]
    g_count_ctrl = [[TP(0) for _ in range(m1)] for _ in range(3)]
    n1_ctrl = TP(0)

    print("Genotype statistics pass")
    bsize = PITER_BATCH_SIZE

    # Containers for batching the computation
    g_container = list[list[list[TP]]]()
    g_mask_container = list[list[list[TP]]]()
    dosage_container = [[TP(0) for _ in range(m1)] for _ in range(bsize)]
    dosage_mask_container = [[TP(0) for _ in range(m1)] for _ in range(bsize)]
    miss_container = [[TP(0) for _ in range(m1)] for _ in range(bsize)]
    miss_mask_container = [[TP(0) for _ in range(m1)] for _ in range(bsize)]

    for k in range(3):
        g_container.append([[TP(0) for _ in range(m1)] for _ in range(bsize)])
        g_mask_container.append([[TP(0) for _ in range(m1)] for _ in range(bsize)])

    ctrl_vec = [TP(0) for _ in range(bsize)]
    ctrl_mask_vec = [TP(0) for _ in range(bsize)]

    ind = -1

    for i in range(n1):
        ind += 1

        while (ikeep[ind] != 1):
            skip_data(f_geno, 3)
            skip_data(f_geno_mask, 3)
            skip_data(f_miss, 1)
            skip_data(f_miss_mask, 1)
            ind += 1

        g0 = read_matrix[TP](f_geno, 3, m0)
        miss0 = read_vector[TP](f_miss, m0)
        g0_mask = read_matrix[TP](f_geno_mask, 3, m0)
        miss0_mask = read_vector[TP](f_miss_mask, m0)

        # Filter out loci that failed missing rate filter
        ind2 = 0
        for j in range(m0):
            if gkeep1[j] == 1:
                for k in range(3):
                    g_container[k][i % bsize][ind2] = g0[k][j]
                    g_mask_container[k][i % bsize][ind2] = g0_mask[k][j]
                miss_container[i % bsize][ind2] = miss0[j]
                miss_mask_container[i % bsize][ind2] = miss0_mask[j]
                ind2 += 1

        dosage_container[i % bsize] = g_container[1][i % bsize] + g_container[2][i % bsize] * 2
        dosage_mask_container[i % bsize] = g_mask_container[1][i % bsize] + g_mask_container[2][i % bsize] * 2

        ctrl_vec[i % bsize] = ctrl[i]
        ctrl_mask_vec[i % bsize] = ctrl_mask[i]

        # Update running sums
        if mpc.pid > 0:
            n1_ctrl += ctrl_mask[i]
            gmiss += miss_mask_container[i % bsize]
            dosage_sum += dosage_mask_container[i % bsize]

            if mpc.pid == 1:
                n1_ctrl += ctrl[i]
                gmiss += miss_container[i % bsize]
                dosage_sum += dosage_container[i % bsize]

        if (i % bsize == bsize - 1 or i == n1 - 1):
            if i % bsize < bsize - 1:
                new_bsize = (i % bsize) + 1

                for k in range(3):
                    g_container[k] = g_container[k].pad(new_bsize, m1)
                    g_mask_container[k] = g_mask_container[k].pad(new_bsize, m1)

                dosage_container = dosage_container.pad(new_bsize, m1)
                dosage_mask_container = dosage_mask_container.pad(new_bsize, m1)
                miss_container = miss_container.pad(new_bsize, m1)
                miss_mask_container = miss_mask_container.pad(new_bsize, m1)
                ctrl_vec = ctrl_vec.pad_vec(new_bsize)
                ctrl_mask_vec = ctrl_mask_vec.pad_vec(new_bsize)

            gmiss_ctrl += mpc.arithmetic.__beaver_mult(
                ctrl_vec, ctrl_mask_vec, miss_container, miss_mask_container, modulus)
            dosage_sum_ctrl += mpc.arithmetic.__beaver_mult(
                ctrl_vec, ctrl_mask_vec, dosage_container, dosage_mask_container, modulus)
            for k in range(3):
                g_count_ctrl[k] += mpc.arithmetic.__beaver_mult(
                    ctrl_vec, ctrl_mask_vec, g_container[k], g_mask_container[k], modulus)

    f_geno.seek(0, 0)
    f_geno_mask.seek(0, 0)
    f_miss.seek(0, 0)
    f_miss_mask.seek(0, 0)

    gmiss_ctrl = mpc.arithmetic.__beaver_reconstruct(gmiss_ctrl, modulus)
    dosage_sum_ctrl = mpc.arithmetic.__beaver_reconstruct(dosage_sum_ctrl, modulus)
    g_count_ctrl = mpc.arithmetic.__beaver_reconstruct(g_count_ctrl, modulus)

    # SNP MAF filter
    print("Locus minor allele frequency (MAF) filter ... ")
    maf_lb = double_to_fp(MAF_LB, modulus)
    maf_ub = double_to_fp(MAF_UB, modulus)

    dosage_tot = [TP(0) for _ in range(len(gmiss))]
    dosage_tot_ctrl = [TP(0) for _ in range(len(gmiss_ctrl))]
    if mpc.pid > 0:
        dosage_tot = -gmiss
        dosage_tot_ctrl = -gmiss_ctrl
        dosage_tot = mpc.arithmetic.add_public(dosage_tot, n1, modulus)
        if mpc.pid > 0: dosage_tot_ctrl += n1_ctrl
        dosage_tot *= 2
        dosage_tot_ctrl *= 2
    dosage_tot %= modulus
    dosage_tot_ctrl %= modulus

    print("Calculating MAFs ... ")
    dosage_tot_len = len(dosage_tot)
    dosage_tot_ctrl_len = len(dosage_tot_ctrl)
    maf = mpc.fp.fp_div(dosage_sum, dosage_tot, modulus)
    maf_ctrl = mpc.fp.fp_div(dosage_sum_ctrl, dosage_tot_ctrl, modulus)
    
    Maf = [TP(0) for _ in range(m1)]
    Maf_ctrl = [TP(0) for _ in range(m1)]
    if mpc.pid > 0:
        Maf = -maf
        Maf_ctrl = -maf_ctrl
        Maf = mpc.arithmetic.add_public(Maf, fp_one, modulus)
        Maf_ctrl = mpc.arithmetic.add_public(Maf_ctrl, fp_one, modulus)

    # Variance based on Bernoulli distribution over each allele
    g_var_bern = mpc.arithmetic.multiply(maf, Maf, modulus)
    g_var_bern = mpc.fp.trunc(g_var_bern, modulus)

    gkeep2 = [1 for _ in range(m1)]

    if not SKIP_QC:
        secure_gkeep2 = mpc.boolean.less_than_public(maf, maf_ub, modulus)
        tmp_vec = mpc.boolean.not_less_than_public(maf, maf_lb, modulus)
        secure_gkeep2 = mpc.arithmetic.multiply(secure_gkeep2, tmp_vec, modulus)

        print("Locus Hardy-Weinberg equilibrium (HWE) filter")
        hwe_ub = double_to_fp(HWE_UB, modulus)  # p < 1e-7

        # Calculate expected genotype distribution in control group
        g_exp_ctrl = []
        g_exp_ctrl.append(mpc.arithmetic.multiply(Maf_ctrl, Maf_ctrl, modulus))
        g_exp_ctrl.append(mpc.arithmetic.multiply(Maf_ctrl, maf_ctrl, modulus))
        if mpc.pid > 0:
            g_exp_ctrl[1] *= 2
            g_exp_ctrl[1] %= modulus
        g_exp_ctrl.append(mpc.arithmetic.multiply(maf_ctrl, maf_ctrl, modulus))

        for i in range(3):
            g_exp_ctrl[i] = mpc.arithmetic.multiply(g_exp_ctrl[i], dosage_tot_ctrl, modulus)

        g_exp_ctrl *= twoinv  # dosage_tot_ctrl is twice the # individuals we actually want
        g_exp_ctrl %= modulus
        g_exp_ctrl = mpc.fp.trunc(g_exp_ctrl, modulus)

        print("Calculated expected genotype counts")

        hwe_chisq = [TP(0) for _ in range(m1)]

        for i in range(3):
            diff = [TP(0) for _ in range(m1)]
            if mpc.pid > 0:
                diff = ((g_count_ctrl[i] * fp_one) % modulus - g_exp_ctrl[i]) % modulus

            diff = mpc.arithmetic.multiply(diff, diff, modulus)
            diff = mpc.fp.trunc(diff, modulus)

            tmp_vec = mpc.fp.fp_div(diff, g_exp_ctrl[i], modulus)
            hwe_chisq = (hwe_chisq + tmp_vec) % modulus

        hwe_filt = mpc.boolean.less_than_public(hwe_chisq, hwe_ub, modulus)
        secure_gkeep2 = mpc.arithmetic.multiply(secure_gkeep2, hwe_filt, modulus)

        # Reveal which SNPs to discard
        gkeep2 = [int(e) for e in mpc.comms.reveal(secure_gkeep2, modulus)]

        if mpc.pid == 2:
            mpc.comms.send(gkeep2, 0)
        elif mpc.pid == 0:
            gkeep2 = mpc.comms.receive[int](2, m1)

    m2 = sum(gkeep2)
    print("n1: ", n1, ", ", "m2: ", m2)

    print("Filtering genotype statistics")
    g_var_bern = [g_var_bern[i] for i in range(len(g_var_bern)) if gkeep2[i]]
    maf = [maf[i] for i in range(len(maf)) if gkeep2[i]]
    snp_pos = [snp_pos[i] for i in range(len(snp_pos)) if gkeep2[i]]

    print("Calculating genotype standard deviations (inverse)")
    g_std_bern_inv = [TP(0) for _ in range(len(g_var_bern))]
    _, g_std_bern_inv = mpc.fp.fp_sqrt(g_var_bern, modulus)

    g_mean = [TP(0) for _ in range(m2)]
    if mpc.pid > 0: g_mean = maf * 2

    print(f"Starting population stratification analysis for {m2} elements")

    selected = [-1 for _ in range(m2)]  # 1 selected, 0 unselected, -1 TBD
    dist_thres = LD_DIST_THRES

    prev = -1
    for i in range(m2):
        selected[i] = 0
        if (prev < 0) or (snp_pos[i] - prev > dist_thres):
            selected[i] = 1
            prev = snp_pos[i]

    # At this point "selected" contains the SNP filter for PCA, shared across all parties
    m3 = 0
    for i in range(len(selected)):
        if selected[i] == 1:
            m3 += 1

    print("SNP selection complete: ", m3, " / ", m2, " selected")

    pca_g_mat = []
    pca_g_mask_mat = []
    pca_miss_mat = []
    pca_miss_mask_mat = []

    gkeep3 = [False for _ in range(m0)]
    for j in range(m0):
        gkeep3[j] = (gkeep1[j] == 1)

    ind = 0
    for j in range(m0):
        if gkeep3[j]:
            gkeep3[j] = (gkeep2[ind] == 1)
            ind += 1

    ind = 0
    for j in range(m0):
        if gkeep3[j]:
            gkeep3[j] = (selected[ind] == 1)
            ind += 1

    bsize: int = n1 // 10

    ind = -1
    for i in range(n1):
        ind += 1

        g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]
        g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]
        miss0 = [TP(0) for _ in range(m0)]
        miss0_mask = [TP(0) for _ in range(m0)]

        while ikeep[ind] != 1:
            skip_data(f_geno, 3)
            skip_data(f_geno_mask, 3)
            skip_data(f_miss, 1)
            skip_data(f_miss_mask, 1)
            ind += 1

        if mpc.pid > 0:
            g0 = read_matrix[TP](f_geno, 3, m0)
            miss0 = read_vector[TP](f_miss, m0)
        g0_mask = read_matrix[TP](f_geno_mask, 3, m0)
        miss0_mask = read_vector[TP](f_miss_mask, m0)

        # Filter out loci that failed missing rate filter
        g = [[TP(0) for _ in range(m0)] for _ in range(3)]
        g_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]
        miss = [TP(0) for _ in range(m0)]
        miss_mask = [TP(0) for _ in range(m0)]
        ind2: int = 0
        for j in range(m0):
            if gkeep3[j]:
                for k in range(3):
                    g[k][ind2] = g0[k][j]
                    g_mask[k][ind2] = g0_mask[k][j]
                miss[ind2] = miss0[j]
                miss_mask[ind2] = miss0_mask[j]
                ind2 += 1

        dosage = (g[1] + (g[2] * 2) % modulus) % modulus
        dosage_mask = (g_mask[1] + (g_mask[2] * 2) % modulus) % modulus

        pca_g_mat.append(dosage)
        pca_g_mask_mat.append(dosage_mask)
        pca_miss_mat.append(miss)
        pca_miss_mask_mat.append(miss_mask)

    f_geno.seek(0, 0)
    f_geno_mask.seek(0, 0)
    f_miss.seek(0, 0)
    f_miss_mask.seek(0, 0)

    g_mean_pca = [g_mean[i] for i in range(len(g_mean)) if selected[i]]
    g_stdinv_pca = [g_std_bern_inv[i] for i in range(len(g_std_bern_inv)) if selected[i]]

    g_mean_pca, g_mean_pca_mask = mpc.arithmetic.__beaver_partition(g_mean_pca, modulus)
    g_stdinv_pca, g_stdinv_pca_mask = mpc.arithmetic.__beaver_partition(g_stdinv_pca, modulus)
    
    # Pass 2: Random sketch
    Y_cur = [[TP(0) for _ in range(m3)] for _ in range(kp)]
    Y_cur_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]
    bucket_count = [0 for _ in range(kp)]

    for cur in range(n1):
        # Count sketch (use global PRG)
        mpc.prg.switch_seed(-1)
        bucket_index = cur % kp # __rand_int(kp + 1) - 1
        rand_sign = (cur % 2) * 2 - 1  # (__rand_int(3) - 1) * 2 - 1
        mpc.prg.restore_seed(-1)

        g = pca_g_mat[cur].copy()
        g_mask = pca_g_mask_mat[cur].copy()
        miss = pca_miss_mat[cur].copy()
        miss_mask = pca_miss_mask_mat[cur].copy()

        # Flip miss bits so it points to places where g_mean should be subtracted
        mpc.boolean.beaver_flip_bit(miss, miss_mask, modulus)

        # Update running sum
        if mpc.pid > 0:
            Y_cur[bucket_index] += g_mask * rand_sign
            if mpc.pid == 1:
                Y_cur[bucket_index] += g * rand_sign
        Y_cur %= modulus

        # Update adjustment factor
        miss *= rand_sign
        miss_mask *= rand_sign
        Y_cur_adj[bucket_index] += mpc.arithmetic.__beaver_mult(
            miss, miss_mask, g_mean_pca, g_mean_pca_mask, modulus)

        bucket_count[bucket_index] += 1

    # Subtract the adjustment factor
    Y_cur_adj = mpc.arithmetic.__beaver_reconstruct(Y_cur_adj, modulus)
    if mpc.pid > 0:
        Y_cur = Y_cur * fp_one - Y_cur_adj
        Y_cur %= modulus
    
    # Get rid of empty buckets and normalize nonempty ones
    empty_slot = 0
    for i in range(kp):
        if bucket_count[i] > 0:
            fp_count_inv = double_to_fp(
                1.0 / bucket_count[i], modulus)
            Y_cur[empty_slot] = (Y_cur[i] * fp_count_inv) % modulus
            empty_slot += 1
    kp = empty_slot
    Y_cur = Y_cur.pad(kp, m3)
    Y_cur = mpc.fp.trunc(Y_cur, modulus)

    Y_cur, Y_cur_mask = mpc.arithmetic.__beaver_partition(Y_cur, modulus)

    print(f"Initial sketch obtained, starting power iteration (num iter = {NUM_POWER_ITER})")

    gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]

    # Divide by standard deviation
    Y = [[TP(0) for _ in range(m3)] for _ in range(kp)]

    for i in range(kp):
        Y[i] = mpc.arithmetic.__beaver_mult(Y_cur[i], Y_cur_mask[i], g_stdinv_pca, g_stdinv_pca_mask, modulus)

    Y = mpc.arithmetic.__beaver_reconstruct(Y, modulus)
    Y = mpc.fp.trunc(Y, modulus)

    # Calculate orthonormal bases of Y
    Q = mpc.lin_alg.orthonormal_basis(Y, modulus)

    # Power iteration
    for pit in range(NUM_POWER_ITER + 1):
        # This section is ran before each iteration AND once after all iterations
        Q, Q_mask = mpc.arithmetic.__beaver_partition(Q, modulus)

        # Normalize Q by standard deviations
        Q_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]
        for i in range(kp):
            Q_scaled[i] = mpc.arithmetic.__beaver_mult(Q[i], Q_mask[i], g_stdinv_pca, g_stdinv_pca_mask, modulus)

        Q_scaled = mpc.arithmetic.__beaver_reconstruct(Q_scaled, modulus)
        Q_scaled = mpc.fp.trunc(Q_scaled, modulus)

        Q_scaled, Q_scaled_mask = mpc.arithmetic.__beaver_partition(Q_scaled, modulus)

        # Pre-multiply with g_mean to simplify calculation of centering matrix
        Q_scaled_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]
        for i in range(kp):
            Q_scaled_gmean[i] = mpc.arithmetic.__beaver_mult(
                Q_scaled[i], Q_scaled_mask[i], g_mean_pca, g_mean_pca_mask, modulus)
        Q_scaled_gmean = mpc.arithmetic.__beaver_reconstruct(Q_scaled_gmean, modulus)
        Q_scaled_gmean = mpc.fp.trunc(Q_scaled_gmean, modulus)

        Q_scaled = Q_scaled.transpose()  # m3-by-kp
        Q_scaled_mask = Q_scaled_mask.transpose()
        Q_scaled_gmean = Q_scaled_gmean.transpose()  # m3-by-kp
        Q_scaled_gmean, Q_scaled_gmean_mask = mpc.arithmetic.__beaver_partition(Q_scaled_gmean, modulus)

        bsize: int = PITER_BATCH_SIZE

        g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]

        # Pass 1
        gQ = [[TP(0) for _ in range(kp)] for _ in range(n1)]
        gQ_adj = [[TP(0) for _ in range(kp)] for _ in range(n1)]

        for cur in range(n1):
            g[cur % bsize] = pca_g_mat[cur].copy()
            g_mask[cur % bsize] = pca_g_mask_mat[cur].copy()
            miss[cur % bsize] = pca_miss_mat[cur].copy()
            miss_mask[cur % bsize] = pca_miss_mask_mat[cur].copy()
            mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize], modulus)

            if cur % bsize == bsize - 1:
                tmp_mat = mpc.arithmetic.__beaver_matmul(g, g_mask, Q_scaled, Q_scaled_mask, modulus)
                for i in range(bsize):
                    gQ[cur-(bsize-1)+i] = tmp_mat[i]

                tmp_mat = mpc.arithmetic.__beaver_matmul(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask, modulus)
                for i in range(bsize):
                    gQ_adj[cur-(bsize-1)+i] = tmp_mat[i]

        remainder = n1 % bsize
        if remainder > 0:
            g = g.pad(remainder, m3)
            g_mask = g_mask.pad(remainder, m3)
            miss = miss.pad(remainder, m3)
            miss_mask = miss_mask.pad(remainder, m3)

            tmp_mat = mpc.arithmetic.__beaver_matmul(g, g_mask, Q_scaled, Q_scaled_mask, modulus)
            for i in range(remainder):
                gQ[n1 - remainder + i] = tmp_mat[i]

            tmp_mat = mpc.arithmetic.__beaver_matmul(miss, miss_mask, Q_scaled_gmean, Q_scaled_gmean_mask, modulus)
            for i in range(remainder):
                gQ_adj[n1 - remainder + i] = tmp_mat[i]
        
        gQ = mpc.arithmetic.__beaver_reconstruct(gQ, modulus)
        gQ_adj = mpc.arithmetic.__beaver_reconstruct(gQ_adj, modulus)

        if mpc.pid > 0:
            gQ -= gQ_adj
            gQ %= modulus

        if pit == NUM_POWER_ITER:  # Quit if all iterations are performed
            break

        gQ = gQ.transpose()  # kp-by-n1
        Q = mpc.lin_alg.orthonormal_basis(gQ, modulus)
        Q = Q.transpose()  # n1-by-kp

        Q, Q_mask = mpc.arithmetic.__beaver_partition(Q, modulus)

        gQ = [[TP(0) for _ in range(m3)] for _ in range(kp)]
        gQ_adj = [[TP(0) for _ in range(m3)] for _ in range(kp)]

        g = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        g_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        miss = [[TP(0) for _ in range(m3)] for _ in range(bsize)]
        miss_mask = [[TP(0) for _ in range(m3)] for _ in range(bsize)]

        Qsub = [[TP(0) for _ in range(kp)] for _ in range(bsize)]
        Qsub_mask = [[TP(0) for _ in range(kp)] for _ in range(bsize)]

        # Pass 2
        for cur in range(n1):
            g[cur % bsize] = pca_g_mat[cur].copy()
            g_mask[cur % bsize] = pca_g_mask_mat[cur].copy()
            miss[cur % bsize] = pca_miss_mat[cur].copy()
            miss_mask[cur % bsize] = pca_miss_mask_mat[cur].copy()
            mpc.boolean.beaver_flip_bit(miss[cur % bsize], miss_mask[cur % bsize], modulus)

            Qsub[cur % bsize] = Q[cur]
            Qsub_mask[cur % bsize] = Q_mask[cur]

            if cur % bsize == bsize - 1:
                Qsub = Qsub.transpose()
                Qsub_mask = Qsub_mask.transpose()

                gQ += mpc.arithmetic.__beaver_matmul(Qsub, Qsub_mask, g, g_mask, modulus)
                gQ_adj += mpc.arithmetic.__beaver_matmul(Qsub, Qsub_mask, miss, miss_mask, modulus)

                Qsub = Qsub.pad(bsize, kp)
                Qsub_mask = Qsub_mask.pad(bsize, kp)
        
        remainder = n1 % bsize
        if remainder > 0:
            g = g.pad(remainder, m3)
            g_mask = g_mask.pad(remainder, m3)
            miss = miss.pad(remainder, m3)
            miss_mask = miss_mask.pad(remainder, m3)
            Qsub = Qsub.pad(remainder, kp)
            Qsub_mask = Qsub_mask.pad(remainder, kp)

            Qsub = Qsub.transpose()
            Qsub_mask = Qsub_mask.transpose()

            gQ += mpc.arithmetic.__beaver_matmul(Qsub, Qsub_mask, g, g_mask, modulus)
            gQ_adj += mpc.arithmetic.__beaver_matmul(Qsub, Qsub_mask, miss, miss_mask, modulus)
        
        gQ = mpc.arithmetic.__beaver_reconstruct(gQ, modulus)
        gQ_adj = mpc.arithmetic.__beaver_reconstruct(gQ_adj, modulus)

        gQ_adj, gQ_adj_mask = mpc.arithmetic.__beaver_partition(gQ_adj, modulus)

        gQ_adj_gmean = [[TP(0) for _ in range(m3)] for _ in range(kp)]
        for i in range(kp):
            gQ_adj_gmean[i] = mpc.arithmetic.__beaver_mult(
                gQ_adj[i], gQ_adj_mask[i], g_mean_pca, g_mean_pca_mask, modulus)
        gQ_adj_gmean = mpc.arithmetic.__beaver_reconstruct(gQ_adj_gmean, modulus)
        gQ_adj_gmean = mpc.fp.trunc(gQ_adj_gmean, modulus)

        if mpc.pid > 0:
            gQ -= gQ_adj_gmean
        gQ, gQ_mask = mpc.arithmetic.__beaver_partition(gQ, modulus)

        gQ_scaled = [[TP(0) for _ in range(m3)] for _ in range(kp)]

        for i in range(kp):
            gQ_scaled[i] = mpc.arithmetic.__beaver_mult(gQ[i], gQ_mask[i], g_stdinv_pca, g_stdinv_pca_mask, modulus)
        gQ_scaled = mpc.arithmetic.__beaver_reconstruct(gQ_scaled, modulus)
        gQ_scaled = mpc.fp.trunc(gQ_scaled, modulus)

        Q = mpc.lin_alg.orthonormal_basis(gQ_scaled, modulus)

        print(f"Iter {pit + 1}. complete at CP{mpc.pid}.")

    print(f"Power iteration complete at CP{mpc.pid}.")
    print(f"Data projected to subspace at CP{mpc.pid}")

    Z = gQ
    V = [[TP(0) for _ in range(n1)] for _ in range(k)]

    # Eigendecomposition
    fp_m2_inv = double_to_fp(1.0 / m2, modulus)
    Z *= fp_m2_inv
    Z = mpc.fp.trunc(Z, modulus)

    Z = Z.transpose() # kp-by-n1

    Z, Z_mask = mpc.arithmetic.__beaver_partition(Z, modulus)

    # Form covariance matrix
    Z_gram = [[TP(0) for _ in range(kp)] for _ in range(kp)]
    for i in range(kp):
        Z_gram[i] = mpc.arithmetic.__beaver_matmul(Z, Z_mask, [Z[i]].transpose(), [Z_mask[i]].transpose(), modulus).transpose()[0]
    Z_gram = mpc.arithmetic.__beaver_reconstruct(Z_gram, modulus)
    Z_gram = mpc.fp.trunc(Z_gram, modulus)

    print(f"Constructed reduced eigenvalue problem for shape {Z_gram.shape()}")

    U, L = mpc.lin_alg.eigen_decomp(Z_gram, modulus)

    print(f"Eigenvectors found at CP{mpc.pid}")

    # Select top eigenvectors and eigenvalues
    U = U.pad(k, kp)
    L = L.pad_vec(k)

    print(f"Selected {k} eigenvectors at CP{mpc.pid}")

    # Recover singular vectors
    U, U_mask = mpc.arithmetic.__beaver_partition(U, modulus)

    V = mpc.arithmetic.__beaver_matmul(U, U_mask, Z, Z_mask, modulus)
    V = mpc.arithmetic.__beaver_reconstruct(V, modulus)
    V = mpc.fp.trunc(V, modulus)

    # Concatenate covariate matrix and jointly orthogonalize
    cov = cov.transpose()
    V = V.pad(k + NUM_COVS, n1)
    if mpc.pid > 0:
        for i in range(NUM_COVS):
            V[k + i] = (cov[i] * fp_one) % modulus
    
    V = mpc.lin_alg.orthonormal_basis(V, modulus)
    V, V_mask = mpc.arithmetic.__beaver_partition(V, modulus)

    print("Bases for top singular vectors and covariates calculated")

    # Pass 4: Calculate GWAS statistics */
    pheno, pheno_mask = mpc.arithmetic.__beaver_partition(pheno, modulus)

    Vp = mpc.arithmetic.__beaver_matmul(V, V_mask, [pheno].transpose(), [pheno_mask].transpose(), modulus).transpose()
    Vp = mpc.arithmetic.__beaver_reconstruct(Vp, modulus)

    Vp, Vp_mask = mpc.arithmetic.__beaver_partition(Vp, modulus)
    VVp = mpc.arithmetic.__beaver_matmul(Vp, Vp_mask, V, V_mask, modulus)
    VVp = mpc.arithmetic.__beaver_reconstruct(VVp, modulus)
    VVp = mpc.fp.trunc(VVp, modulus)

    VVp, VVp_mask = mpc.arithmetic.__beaver_partition(VVp, modulus)

    p_hat = pheno * fp_one - VVp[0]
    p_hat %= modulus
    p_hat_mask = pheno_mask * fp_one - VVp_mask[0]
    p_hat_mask %= modulus

    print("Phenotypes corrected")

    V_sum = [TP(0) for _ in range(k + NUM_COVS)]
    V_sum_mask = [TP(0) for _ in range(k + NUM_COVS)]
    for i in range(k + NUM_COVS):
        for j in range(n1):
            V_sum[i] += V[i][j]
            V_sum_mask[i] += V_mask[i][j]
            V_sum[i] %= modulus
            V_sum_mask[i] %= modulus

    u = mpc.arithmetic.__beaver_matmul([V_sum], [V_sum_mask], V, V_mask, modulus)[0]
    u = mpc.arithmetic.__beaver_reconstruct(u, modulus)
    u = mpc.fp.trunc(u, modulus)
    if mpc.pid > 0:
        u *= -1
        u = mpc.arithmetic.add_public(u, fp_one, modulus)

    u, u_mask = mpc.arithmetic.__beaver_partition(u, modulus)

    sx = [TP(0) for _ in range(m2)]
    sxx = [TP(0) for _ in range(m2)]
    sxp = [TP(0) for _ in range(m2)]
    B = [[TP(0) for _ in range(m2)] for _ in range(k + NUM_COVS)]

    bsize: int = PITER_BATCH_SIZE

    dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]
    dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]

    u_vec = [TP(0) for _ in range(bsize)]
    u_mask_vec = [TP(0) for _ in range(bsize)]
    p_hat_vec = [TP(0) for _ in range(bsize)]
    p_hat_mask_vec = [TP(0) for _ in range(bsize)]

    V = V.transpose()  # n1-by-(k + NUM_COVS)
    V_mask = V_mask.transpose()

    V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]
    V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]

    gkeep3: list[bool] = [False for _ in range(m0)]
    for j in range(m0):
        gkeep3[j] = (gkeep1[j] == 1)

    ind = 0
    for j in range(m0):
        if gkeep3[j]:
            gkeep3[j] = (gkeep2[ind] == 1)
            ind += 1

    ind = -1
    for cur in range(n1):
        ind += 1
        g0 = [[TP(0) for _ in range(m0)] for _ in range(3)]
        g0_mask = [[TP(0) for _ in range(m0)] for _ in range(3)]
        miss0 = [TP(0) for _ in range(m0)]
        miss0_mask = [TP(0) for _ in range(m0)]

        while ikeep[ind] != 1:
            skip_data(f_geno, 3)
            skip_data(f_geno_mask, 3)
            skip_data(f_miss, 1)
            skip_data(f_miss_mask, 1)
            ind += 1

        if mpc.pid > 0:
            g0 = read_matrix[TP](f_geno, 3, m0)
            miss0 = read_vector[TP](f_miss, m0)
        g0_mask = read_matrix[TP](f_geno_mask, 3, m0)
        miss0_mask = read_vector[TP](f_miss_mask, m0)

        g = [[TP(0) for _ in range(m2)] for _ in range(3)]
        miss = [TP(0) for _ in range(m2)]
        g_mask = [[TP(0) for _ in range(m2)] for _ in range(3)]
        miss_mask = [TP(0) for _ in range(m2)]
        ind2: int = 0

        for j in range(m0):
            if gkeep3[j]:
                for k in range(3):
                    g[k][ind2] = g0[k][j]
                    g_mask[k][ind2] = g0_mask[k][j]

                miss[ind2] = miss0[j]
                miss_mask[ind2] = miss0_mask[j]
                ind2 += 1

        dosage[cur % bsize] = (g[1] + (g[2] * 2) % modulus) % modulus
        dosage_mask[cur % bsize] = (g_mask[1] + (g_mask[2] * 2) % modulus) % modulus

        u_vec[cur % bsize] = u[cur]
        u_mask_vec[cur % bsize] = u_mask[cur]
        p_hat_vec[cur % bsize] = p_hat[cur]
        p_hat_mask_vec[cur % bsize] = p_hat_mask[cur]

        V_sub[cur % bsize] = V[cur]
        V_mask_sub[cur % bsize] = V_mask[cur]

        if cur % bsize == bsize - 1:
            sx += mpc.arithmetic.__beaver_matmul([u_vec], [u_mask_vec], dosage, dosage_mask, modulus)[0]
            sxp += mpc.arithmetic.__beaver_matmul([p_hat_vec], [p_hat_mask_vec], dosage, dosage_mask, modulus)[0]
            sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask, modulus)
            for b in range(bsize):
                sxx += sxx_tmp[b]

            V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-bsize
            V_mask_sub = V_mask_sub.transpose()
            B += mpc.arithmetic.__beaver_matmul(V_sub, V_mask_sub, dosage, dosage_mask, modulus)

            dosage = [[TP(0) for _ in range(m2)] for _ in range(bsize)]
            dosage_mask = [[TP(0) for _ in range(m2)] for _ in range(bsize)]
            V_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]
            V_mask_sub = [[TP(0) for _ in range(k + NUM_COVS)] for _ in range(bsize)]

    remainder = n1 % bsize
    if remainder > 0:
        dosage = dosage.pad(remainder, m2)
        dosage_mask = dosage_mask.pad(remainder, m2)
        u_vec = u_vec.pad_vec(remainder)
        u_mask_vec = u_mask_vec.pad_vec(remainder)
        p_hat_vec = p_hat_vec.pad_vec(remainder)
        p_hat_mask_vec = p_hat_mask_vec.pad_vec(remainder)
        V_sub = V_sub.pad(remainder, k + NUM_COVS)
        V_mask_sub = V_mask_sub.pad(remainder, k + NUM_COVS)

        sx += mpc.arithmetic.__beaver_matmul([u_vec], [u_mask_vec], dosage, dosage_mask, modulus)[0]
        sxp += mpc.arithmetic.__beaver_matmul([p_hat_vec], [p_hat_mask_vec], dosage, dosage_mask, modulus)[0]

        sxx_tmp = mpc.arithmetic.__beaver_mult(dosage, dosage_mask, dosage, dosage_mask, modulus)
        for b in range(remainder):
            sxx += sxx_tmp[b]
            sxx %= modulus

        V_sub = V_sub.transpose()  # (k + NUM_COVS)-by-remainder
        V_mask_sub = V_mask_sub.transpose()

        B += mpc.arithmetic.__beaver_matmul(V_sub, V_mask_sub, dosage, dosage_mask, modulus)

    sx = mpc.arithmetic.__beaver_reconstruct(sx, modulus)
    sxp = mpc.arithmetic.__beaver_reconstruct(sxp, modulus)
    sxx = mpc.arithmetic.__beaver_reconstruct(sxx, modulus)
    B = mpc.arithmetic.__beaver_reconstruct(B, modulus)
    sxx *= fp_one
    sxx %= modulus

    B = B.transpose()  # m2-by-(k + NUM_COVS)

    BB = mpc.arithmetic.inner_prod(B, modulus)
    BB = mpc.fp.trunc(BB, modulus)
    if mpc.pid > 0:
        sxx -= BB
    sxx %= modulus

    sp = TP(0)
    if mpc.pid > 0:
        for i in range(n1):
            sp += p_hat_mask[i]
            sp %= modulus
            if mpc.pid == 1:
                sp += p_hat[i]
                sp %= modulus

    spp = TP(0)
    spp = mpc.arithmetic.beaver_inner_prod(p_hat, p_hat_mask, modulus)
    spp = mpc.arithmetic.__beaver_reconstruct(spp, modulus)

    fp_n1_inv = double_to_fp(1.0 / n1, modulus)
    sx *= fp_n1_inv
    sp *= fp_n1_inv
    sx %= modulus
    sp %= modulus

    sx = mpc.fp.trunc(sx, modulus)
    sp = mpc.fp.trunc(sp, modulus)
    spp = mpc.fp.trunc(spp, modulus)

    sx, sx_mask = mpc.arithmetic.__beaver_partition(sx, modulus)
    sp, sp_mask = mpc.arithmetic.__beaver_partition(sp, modulus)

    sp2 = TP(0)
    spsx = [TP(0) for _ in range(m2)]
    sx2 = [TP(0) for _ in range(m2)]

    spsx = mpc.arithmetic.__beaver_mult(sx, sx_mask, sp, sp_mask, modulus)
    sp2 = mpc.arithmetic.__beaver_mult(sp, sp_mask, sp, sp_mask, modulus)
    sx2 = mpc.arithmetic.__beaver_mult(sx, sx_mask, sx, sx_mask, modulus)

    spsx = mpc.arithmetic.__beaver_reconstruct(spsx, modulus)
    sp2 = mpc.arithmetic.__beaver_reconstruct(sp2, modulus)
    sx2 = mpc.arithmetic.__beaver_reconstruct(sx2, modulus)

    spsx *= n1
    sp2 *= n1
    sx2 *= n1
    spsx %= modulus
    sp2 %= modulus
    sx2 %= modulus

    spsx = mpc.fp.trunc(spsx, modulus)
    sp2 = mpc.fp.trunc(sp2, modulus)
    sx2 = mpc.fp.trunc(sx2, modulus)

    numer = [TP(0) for _ in range(m2)]
    denom = [TP(0) for _ in range(m2 + 1)]
    if mpc.pid > 0:
        numer = sxp - spsx
        for i in range(m2):
            denom[i] = sxx[i] - sx2[i]
        denom[m2] = spp - sp2
    numer %= modulus
    denom %= modulus

    denom1_sqrt_inv = [TP(0) for _ in range(len(denom))]
    _, denom1_sqrt_inv = mpc.fp.fp_sqrt(denom, modulus)

    denom2_sqrt_inv = denom1_sqrt_inv[m2]  # p term
    denom1_sqrt_inv = denom1_sqrt_inv[:m2]  # truncate

    z = mpc.arithmetic.multiply(numer, denom1_sqrt_inv, modulus)
    z = mpc.fp.trunc(z, modulus)

    z = mpc.arithmetic.multiply(z, denom2_sqrt_inv, modulus)
    z = mpc.fp.trunc(z, modulus)

    print(f"Association statistics calculated at CP{mpc.pid}")

    f_geno.close()
    f_miss.close()
    f_geno_mask.close()
    f_miss_mask.close()
    
    return z
