from sequre.utils.param import *
from sequre.utils.io import read_vector, read_matrix
from sequre.utils.utils import zeros, switch_pair
from sequre.types.shared_tensor import SharedTensor, MODULUS

from sequre.mpc.env import MPCEnv
from sequre.stdlib.internal import Internal as sq
from sequre.stdlib.lin_alg import orthonormal_basis
from sequre_gwas import read_labels, load_dosage

from sequre.attributes import sequre_beaver


def open_input_files(mpc, test_run):
    pheno_path = (f"tests/data/input/gwas_pheno_shares_{mpc.pid}.txt" if test_run else
                  f"{GWAS_DATA_PATH}/__pheno_shares_{mpc.pid}.txt")
    cov_path = (f"tests/data/input/gwas_cov_shares_{mpc.pid}.txt" if test_run else
                f"{GWAS_DATA_PATH}/__cov_shares_{mpc.pid}.txt")
    geno_path = (f"tests/data/input/gwas_geno_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__geno_x_r.txt")
    geno_mask_path = (f"tests/data/input/gwas_geno_r_{mpc.pid}.txt" if test_run else
                      f"{GWAS_DATA_PATH}/__geno_r_{mpc.pid}.txt")
    miss_path = (f"tests/data/input/gwas_miss_x_r.txt" if test_run else
                 f"{GWAS_DATA_PATH}/__miss_x_r.txt")
    miss_mask_path = (f"tests/data/input/gwas_miss_r_{mpc.pid}.txt" if test_run else 
                      f"{GWAS_DATA_PATH}/__miss_r_{mpc.pid}.txt")
    eigen_path = (f"tests/data/input/logireg_eigen_shares_{mpc.pid}.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__eigen_shares_{mpc.pid}.txt")
    gkeep1_path = (f"tests/data/input/logireg_gkeep1.txt" if test_run else
                   f"{LOGIREG_DATA_PATH}/__gkeep1.txt")
    gkeep2_path = (f"tests/data/input/logireg_gkeep2.txt" if test_run else
                   f"{LOGIREG_DATA_PATH}/__gkeep2.txt")
    ikeep_path = (f"tests/data/input/logireg_ikeep.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__ikeep.txt")
    assoc_path = (f"tests/data/input/logireg_assoc.txt" if test_run else
                  f"{LOGIREG_DATA_PATH}/__assoc.txt")
    
    return (open(pheno_path),
            open(cov_path),
            open(geno_path),
            open(geno_mask_path),
            open(miss_path),
            open(miss_mask_path),
            open(eigen_path),
            open(gkeep1_path),
            open(gkeep2_path),
            open(ikeep_path),
            open(assoc_path))


def table_lookup(mpc, x):
    v_0, v_1 = mpc.polynomial.table_lookup(x.share, 2, MODULUS)
    sv_0 = SharedTensor(v_0)
    sv_1 = SharedTensor(v_1)
    sv_0.fp = True
    sv_1.fp = True
    return sv_0, sv_1


@sequre_beaver
def neg_log_sigmoid(mpc, a):
    a_vec = a.flatten()
    depth = 6
    step = 4.0
    a_ind = a_vec.zeros()
    a_ind.fp = False

    for i in range(depth):
        a_sign = a_vec > 0
        a_ind = a_ind + a_sign * (1 << (depth - 1 - i))
        a_vec = a_vec - (a_sign * 2 - 1) * step
        step = step / 2
    
    a_ind = a_ind + 1
    return table_lookup(mpc, a_ind)[1].expand_dims().reshape(a.shape())


@sequre_beaver
def parallel_logistic_regression(mpc, x, v, y, max_iter):
    n = len(v[0])
    eta = 0.3
    nbatch = 10
    batch_size = (n + nbatch - 1) // nbatch

    b0 = x.T[0].zeros().to_fp()
    bv = SharedTensor(zeros[int_t](len(x), len(v))).to_fp()
    bx = b0.zeros()
    y_neg = 1 - y

    step0 = b0.zeros()
    stepv = bv.zeros()
    stepx = bx.zeros()

    for it in range(max_iter):
        print(f'Logistic regression iteration {it} initialized at CP{mpc.pid}')
        batch_index = it % nbatch
        start_ind = batch_size * batch_index
        end_ind = start_ind + batch_size
        if end_ind > n: end_ind = n
        cur_bsize = end_ind - start_ind

        x_batch = x[:, start_ind:start_ind + cur_bsize]
        v_batch = v[:, start_ind:start_ind + cur_bsize]
        y_neg_batch = y_neg[start_ind:start_ind + cur_bsize]

        h = (sq.matmul(mpc, bv, v_batch) + x_batch.to_fp() * bx).parallel_add(b0)
        s_grad = neg_log_sigmoid(mpc, h)
        for i in range(len(s_grad)):
            s_grad[i] = s_grad[i] + y_neg_batch.to_fp()
        
        d0 = s_grad.T.sum()
        dx = sq.dot(mpc, x_batch.T, s_grad.T)
        dv = sq.matmul(mpc, s_grad, v_batch.T)

        norm = eta / cur_bsize
        step0 = step0 * 0.5 - d0 * norm
        stepv = stepv * 0.5 - dv * norm
        stepx = stepx * 0.5 - dx * norm

        b0 = b0 + step0
        bv = bv + stepv
        bx = bx + stepx

    return b0, bv, bx


@sequre_beaver
def logireg_protocol(mpc, test_run = True):
    (f_pheno, f_cov, f_geno, f_geno_mask,
     f_miss, f_miss_mask, f_eigen, f_gkeep1,
     f_gkeep2, f_ikeep, f_assoc) = open_input_files(mpc, test_run)     
    
    ntop = 100
    _, pheno, cov = read_labels(mpc, f_pheno, f_cov)
    gkeep1 = read_vector[int](f_gkeep1, NUM_SNPS)
    ikeep = read_vector[int](f_ikeep, NUM_INDS)
    n1 = sum(ikeep)
    gkeep2 = read_vector[int](f_gkeep2, NUM_SNPS)
    m2 = sum(gkeep2)
    cavec = list[tuple[int, float]](m2)
    for i, line in zip(range(m2), f_assoc):
        cavec.append((i, float(line) ** 2))
    cavec.sort(key=switch_pair[int, float], reverse=True)
    gkeep3 = [0 for _ in range(m2)]
    for i in range(ntop):
        gkeep3[cavec[i][0]] = 1

    pheno = pheno.filter(ikeep)
    cov = cov.filter(ikeep)
    V_val = read_matrix[int_t](f_eigen, NUM_DIM_TO_REDUCE_TO, n1)
    V = SharedTensor[list[list[int_t]]](V_val)
    V.fp = True

    V = orthonormal_basis(mpc, V.extend(cov.T.to_fp()))
    V = V.parallel_add(-(V.T.sum() / len(V[0])))
    stdinv = 1 / sq.sqrt(mpc, sq.dot(mpc, V.T) / len(V[0]))
    V = (V.T * stdinv).T

    gkeep = [(gkeep1[j] == 1) for j in range(NUM_SNPS)]

    ind: int = 0
    for j in range(NUM_SNPS):
        if gkeep[j]:
            gkeep[j] = (gkeep2[ind] == 1)
            ind += 1

    ind: int = 0
    for j in range(NUM_SNPS):
        if gkeep[j]:
            gkeep[j] = (gkeep3[ind] == 1)
            ind += 1
    
    X = load_dosage(
        mpc, f_geno, f_geno_mask, f_miss, f_miss_mask,
        ikeep, gkeep, len(ikeep), NUM_SNPS)[2]

    return parallel_logistic_regression(mpc, X.T, V, pheno, LOGIREG_ITER)[2]
