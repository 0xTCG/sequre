import math

import utils.param as param

from mpc_prg import MPCPRG
from mpc_comms import MPCComms
from mpc_arithmetic import MPCArithmetic
from mpc_polynomial import MPCPolynomial
from utils.utils import rand_mat, rand_vec
from utils.type_ops import TypeOps


class MPCBoolean[TP]:
    pid: int
    primes: dict[int, TP]
    prg: MPCPRG
    comms: MPCComms[TP]
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    or_lagrange_cache: dict[tuple[int, TP], list[TP]]
    primes_bits: dict[int, int]
    primes_bytes: dict[int, int]

    def __init__(self: MPCBoolean[TP], pid: int, primes: dict[int, TP], prg: MPCPRG, comms: MPCComms[TP], arithmetic: MPCArithmetic[TP], polynomial: MPCPolynomial[TP]):
        self.pid = pid
        self.primes = primes
        self.prg = prg
        self.comms = comms
        self.arithmetic = arithmetic
        self.polynomial = polynomial

        self.or_lagrange_cache = dict[tuple[int, TP], list[TP]]()
        self.primes_bits = {k: int(math.ceil(math.log2(float(v)))) for k, v in self.primes.items()}
        self.primes_bytes = {k: (v + 7) // 8 for k, v in self.primes_bits.items()}
    
    def fan_in_or(self: MPCBoolean[TP], a: list[list[TP]], field: TP = param.BASE_P) -> list[TP]:
        n, d = a.shape()
        a_sum: list[TP] = [TP(0) for _ in range(n)]

        # TODO: Vectorize a_sum calculation below
        if self.pid > 0:
            for i in range(n):
                a_sum[i] = TP(self.pid == 1)
                for j in range(d):
                    a_sum[i] += a[i][j]
        
        a_sum %= field

        key: tuple[int, TP] = (d + 1, field)
        if key not in self.or_lagrange_cache:
            y = [TP(i != 0) for i in range(d + 1)]
            coeff_param = self.polynomial.lagrange_interp_simple(y, field) # OR function
            self.or_lagrange_cache[key] = coeff_param
        
        coeff: list[list[TP]] = [self.or_lagrange_cache[key]]
        bmat = self.polynomial.evaluate_poly(a_sum, coeff, field)

        return bmat[0]
    
    def prefix_or(self: MPCBoolean[TP], a: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        # Performance warning: Allocation/assignment is redundant in this method
        n, m = a.shape()

        # Find next largest squared integer
        L: int = int(math.ceil(math.sqrt(float(m))))
        L2: int = L * L

        # Zero-pad to L2 bits
        a_padded = list[list[TP]](n)  # zeros((n, L2))
        
        if self.pid > 0:
            for i in range(n):
                row = list[TP](L2)
                for j in range(L2):
                    if j >= L2 - m: row.append(a[i][j - L2 + m])
                    else: row.append(TP(0))
                a_padded.append(row)
        else:
            for i in range(n):
                a_padded.append([TP(0) for _ in range(L2)])
        
        a_padded = a_padded.reshape((n * L, L))
        
        x: list[TP] = self.fan_in_or(a_padded, field)        
        xpre = [[TP(0) for _ in range(L)] for _ in range(n * L)]  # zeros((n * L, L))
        
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    xpi: int = L * i + j
                    for k in range(L):
                        xpre[xpi][k] = x[L * i + k] * int(k <= j)
        
        y: list[TP] = self.fan_in_or(xpre, field)

        # TODO: Make it parallel by using ndarray
        f = [[[TP(0) for _ in range(L)]] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    if j == 0:
                        f[i][0][j] = x[L * i]
                    else:
                        f[i][0][j] = y[L * i + j] - y[L * i + j - 1]
                f[i] %= field

        # TODO: Make it parallel by using ndarray
        tmp = [[[TP(0) for _ in range(L)] for _ in range(L)] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    tmp[i][j][:] = a_padded[L * i + j]
                tmp[i] %= field

        c = self.arithmetic.multiply_mat_bulk(f, tmp, field)  # c is a concatenation of n 1-by-L matrices

        cpre: list[list[TP]] = [[TP(0) for _ in range(L)] for _ in range(n * L)]  # zeros((n * L, L))
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    cpi: int = L * i + j
                    for k in range(L):
                        cpre[cpi][k] = c[i][0][k] * int(k <= j)
        
        bdot_vec: list[TP] = self.fan_in_or(cpre, field)

        bdot = [[[TP(0) for _ in range(L)]] for _ in range(n)]
        if self.pid > 0:
            for i in range(n):
                for j in range(L):
                    bdot[i][0][j] = bdot_vec[L * i + j]
        
        for i in range(n):
            f[i] = f[i].reshape((L, 1))

        s = self.arithmetic.multiply_mat_bulk(f, bdot, field)

        b = list[list[TP]](n)  # zeros(a.shape)
        if self.pid > 0:
            for i in range(n):
                row = list[TP](m)
                for j in range(m):
                    j_pad: int = L2 - m + j

                    il: int = j_pad // L
                    jl: int = j_pad - il * L

                    row.append(((s[i][il][jl] + y[L * i + il]) % field - f[i][il][0]) % field)
                b.append(row)
        else:
            for i in range(n):
                b.append([TP(0) for _ in range(m)])

        return b
    
    def less_than_bits_public(self: MPCBoolean[TP], a: list[list[TP]], b_pub: list[list[TP]], field: TP = param.BASE_P) -> list[TP]:
        return self.less_than_bits_aux(a, b_pub, 2, field)

    def less_than_bits(self: MPCBoolean[TP], a: list[list[TP]], b: list[list[TP]], field: TP = param.BASE_P) -> list[TP]:
        return self.less_than_bits_aux(a, b, 0, field)
    
    def less_than_bits_aux(self: MPCBoolean[TP], a: list[list[TP]], b: list[list[TP]], public_flag: int, field: TP = param.BASE_P) -> list[TP]:
        assert a.shape() == b.shape()

        n, L = a.shape()

        # Performance warning: Redundant allocation/assignment of x bellow
        # Calculate XOR
        x = [[TP(0) for _ in range(L)] for _ in range(n)]  # zeros((n, L))

        if public_flag == 0:
            x = self.arithmetic.multiply_mat(a, b, field)
            if self.pid > 0:
                x = ((a + b) % field - (x + x) % field) % field
        elif self.pid > 0:
            x = (a * b) % field
            x = ((a + b) % field - (x + x) % field) % field
            if self.pid == 2:
                x = (x - (a if public_flag == 1 else b)) % field

        f: list[list[TP]] = self.prefix_or(x, field)

        if self.pid > 0:
            for i in range(n):
                for j in range(L - 1, 0, -1):
                    f[i][j] = (f[i][j] - f[i][j - 1]) % field
        
        if public_flag == 2:
            c: list[TP] = [TP(0) for _ in range(n)]  # zeros(n)
            if self.pid > 0:
                fb: list[list[TP]] = (f * b) % field
                for i in range(n):
                    for e in fb[i]:
                        c[i] = (c[i] + e) % field
            
            return c

        # TODO: optimize
        f_arr = [[[TP(0) for _ in range(L)]] for _ in range(n)]
        b_arr = [[[TP(0)] for _ in range(L)] for _ in range(n)]

        if self.pid > 0:
            for i in range(n):
                f_arr[i][0][:] = f[i]
                for j in range(L):
                    b_arr[i][j][0] = b[i][j]
        
        c_arr = self.arithmetic.multiply_mat_bulk(f_arr, b_arr, field)

        return [c_arr[i][0][0] if self.pid > 0 else TP(0) for i in range(n)]
    
    def is_positive(self: MPCBoolean[TP], a: list[TP]) -> list[TP]:
        n: int = len(a)
        nbits: int = self.primes_bits[0]
        field = self.primes[2]

        r = list[TP](n)
        r_bits = list[list[TP]](n)
        if self.pid == 0:
            r = rand_vec(n, param.BASE_P)
            r_bits = TypeOps.num_to_bits(r, nbits)

            self.prg.switch_seed(1)
            r_mask: list[TP] = rand_vec(n, param.BASE_P)
            r_bits_mask: list[list[TP]] = rand_mat([n, nbits], field)
            self.prg.restore_seed(1)

            r -= r_mask
            r_bits -= r_bits_mask
            r %= param.BASE_P
            r_bits %= field

            self.comms.send_data(r, 2, n * param.SIZE_OF_U)
            self.comms.send_data(r_bits, 2, n * nbits * param.SIZE_OF_U)
        elif self.pid == 2:
            r = self.comms.receive_vector(0, n)
            r_bits = self.comms.receive_matrix(0, shape=[n, nbits])
        else:
            self.prg.switch_seed(0)
            r = rand_vec(n, param.BASE_P)
            r_bits = rand_mat([n, nbits], field)
            self.prg.restore_seed(0)

        c: list[TP] = (((a + a) % param.BASE_P) + r) % param.BASE_P if self.pid != 0 else [TP(0)]
        c = self.comms.reveal_vector(c, field=param.BASE_P)

        c_bits: list[list[TP]] = TypeOps.num_to_bits(c, nbits) if self.pid != 0 else [[TP(0) for _ in range(nbits)] for _ in range(n)]  # zeros((n, nbits))

        # Incorrect result if r = 0, which happens with probaility 1 / BASE_P
        no_overflow: list[TP] = self.less_than_bits_public(r_bits, c_bits, field=field)

        c_xor_r = [TP(0) for _ in range(n)]  # zeros(n)
        if self.pid > 0:
            # Warning: Overflow might occur below.
            for i in range(n):
                v: TP = r_bits[i][nbits - 1] - TP(2) * c_bits[i][nbits - 1] * r_bits[i][nbits - 1]
                v += (c_bits[i][nbits - 1] if self.pid == 1 else TP(0))
                c_xor_r.append(v)
            c_xor_r %= field
        
        lsb: list[TP] = self.arithmetic.multiply_vec(c_xor_r, no_overflow, field)
        if self.pid > 0:
            lsb = (lsb + lsb) % field
            lsb -= (no_overflow + c_xor_r) % field
            if self.pid == 1:
                lsb = (lsb + 1) % field
        lsb %= field

        # 0, 1 -> 1, 2
        if self.pid == 1:
            lsb = (lsb + 1) % field
        
        b_mat: list[list[TP]] = self.polynomial.table_lookup(lsb, 0)

        return b_mat[0]

    def less_than_public(self: MPCBoolean[TP], a: list[TP], bpub: TP, field: TP = param.BASE_P) -> list[TP]:
        n: int = len(a)
        a_cpy = list[TP](n)

        if self.pid > 0:
            for i in range(n):
                a_cpy.append(a[i])
                if self.pid == 1:
                    a_cpy[i] -= bpub
        else:
            for i in range(n):
                a_cpy.append(TP(0))
        a_cpy %= field

        # a - b >= 0?
        c = self.is_positive(a_cpy)
        c = self.flip_bit(c)

        return c
    
    def less_than(self: MPCBoolean[TP], a: list[TP], b: list[TP], field: TP = param.BASE_P) -> list[TP]:
        a_cpy = [TP(0) for _ in range(len(a))] if self.pid == 0 else a - b
        a_cpy %= field

        # a - b >= 0?
        c = self.is_positive(a_cpy)
        c = self.flip_bit(c)

        return c

    def not_less_than(self: MPCBoolean[TP], a: list[TP], b: list[TP], field: TP = param.BASE_P) -> list[TP]:
        c = self.less_than(a, b, field)
        c = self.flip_bit(c)

        return c
    
    def not_less_than_public(self: MPCBoolean[TP], a: list[TP], bpub: TP, field: TP = param.BASE_P) -> list[TP]:
        c = self.less_than_public(a, bpub, field)
        c = self.flip_bit(c)

        return c

    def flip_bit(self: MPCBoolean[TP], a: list[TP]):
        n = len(a)
        b = [TP(0) for _ in range(n)] if self.pid == 0 else -a
        if self.pid == 1: b += 1

        return b
    
    def beaver_flip_bit(self: MPCBoolean[TP], a: list[TP], a_mask: list[TP]):
        if self.pid > 0:
            a *= -1
            for i in range(len(a)): a[i] += 1
        a_mask *= -1
