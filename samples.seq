from stdlib.lin_alg import *
from stdlib.fp import *
from protocol.gwas import gwas_protocol as gp
from protocol.sequre_gwas import gwas_protocol as ogp

from utils.param import *
from utils.utils import get_address, evalp
from utils.type_ops import TypeOps
from utils.custom_types import SecureValue

from mpc.env import MPCEnv

from C import fork() -> int
from C import wait(cobj) -> int
from C import unlink(str) -> int

from sequre import *


@sequre
def arithmetics_1(mpc, a, b, c):
    d = b * c         # 24 # bc
    e = d + a         # 26 # bc + a
    f = e ** 7        # 8031810176 # (bc + a)^7
    # Reconstruct f   
    g = (f + a) * d   # 192763444272 # (bc + a)^7bc + abc
    return g


@sequre
def arithmetics_2(mpc, a, b, c):
    d = b * 3 * c  # 72
    e = d + a  # 74
    # f = e ** 7
    f = e + d * 2  # 144 + 74
    # Reconstruct f
    g = (f + a) * d  # (144 + 76) * 72
    # h = g ** 2
    h = g + e * 2  # (144 + 76) * 72 + 148
    # b * c * b * c + 
    # a * b * c + 
    # b * c * b * c + 
    # a * b * c +
    # b * c + 
    # a
    return h


@sequre
def arithmetics_3(mpc, a, b, c):
    d = b * 3 * c
    e = d * a
    f = e * d
    f = f * d
    f = f * d
    f = f * d
    f = f * d
    f = f * d
    f = f * d
    f = f * d
    f = f * d
    # Reconstruct f
    f += a
    g = f * d
    h = g + e * 2
    return h


@sequre
def arithmetics_4(mpc, a, b, c):
    d = b * a + c * a
    e = d * a
    f = e ** 7 * a
    # Reconstruct f   
    g = f + e ** 6
    h = d * g
    return h


@sequre
def arithmetics_5(mpc, a, b, c):
    d = a ** 128 + c * b
    e = d * a ** 64
    f = e ** 7 * a ** 32
    # Reconstruct f   
    g = f + e ** 6
    h = d * g
    return h


@sequre
def arithmetics_6(mpc, a, b, c):
    d = b * a + c * a
    f = d ** 32 * a
    g = f + d ** 16
    h = d ** 8 * g
    return h


@sequre_beaver
def arithmetics_7(mpc, a, b, c):
    d = b * a + c * a
    e = d ** 32 * a
    f = mpc.secure_reveal(e)
    print('f', f.share)
    g = f + d ** 16
    h = d ** 8 * g
    return h

@sequre_beaver
def test_sample(mpc, a, b):
    return a / 3


def benchmark(mpc):
    # a = SecureValue[list[list[int_t]]](
    #     [[int_t(1), int_t(1)],
    #     [int_t(1), int_t(1)]])
    # b = SecureValue[list[list[int_t]]](
    #     [[int_t(2), int_t(2)],
    #     [int_t(2), int_t(2)]])
    # c = SecureValue[list[list[int_t]]](
    #     [[int_t(3), int_t(3)],
    #     [int_t(3), int_t(3)]])
    a = SecureValue[list[int_t]]([int_t(1), int_t(1)])
    b = SecureValue[list[int_t]]([int_t(2), int_t(2)])
    # c = SecureValue[list[int_t]]([int_t(3), int_t(3)])
    # a = SecureValue[int_t](1)
    # b = SecureValue[int_t](2)
    # c = SecureValue[int_t](3)

    vec = [
        TypeOps.double_to_fp(1.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(0.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(2.5, NBIT_K, NBIT_F)]
    sv = SecureValue[list[int_t]](vec)
    sv.fp = True
    
    h_vec = [TypeOps.double_to_fp(float(i), NBIT_K, NBIT_F) for i in range(500000)]
    sv_vec = SecureValue[list[int_t]](h_vec)
    sv_vec.fp = True

    h_mat = [[TypeOps.double_to_fp(float(i + j), NBIT_K, NBIT_F) for i in range(50)] for j in range(50)]
    sv_mat = SecureValue[list[list[int_t]]](h_mat)
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, mpc.primes[0]))
    sv_mat.fp = True

    import time
    s = time.time()
    mpc.reset_stats()

    # a.set_partitions(mpc.arithmetic.__beaver_partition(a.share))
    # a = a.to_fp()
    # res = test_sample(mpc, a, b)
    # mpc.comms.print_fp(res.share)
    # res.beaver_reveal(mpc)

    # print(mpc.comms.reveal(test_sample(mpc, a, b).share))
    
    # result = mpc.fp.fp_sqrt(h_vec[:1000])

    # result = fp_sqrt(mpc, sv_vec[:1000])

    # result = mpc.lin_alg.householder(h_vec)
    # result_0 = mpc.lin_alg.qr_fact_square(h_mat)
    # result_1 = mpc.lin_alg.tridiag(h_mat)
    # result_2 = mpc.lin_alg.eigen_decomp(h_mat)
    # result_3 = mpc.lin_alg.orthonormal_basis(h_mat)

    # result = householder(mpc, sv_vec)
    # result_0 = qr_fact_square(mpc, sv_mat)
    # result_1 = tridiag(mpc, sv_mat)
    # result_2 = eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    # result_3 = orthonormal_basis(mpc, sv_mat)

    # gp(mpc, True)
    ogp(mpc, True)

    e = time.time()
    print(f'Done in {e - s}s at {mpc.pid}')

    mpc.comms.sync_nodes()
    mpc.print_stats()
    

def client[TP](pid):
    # Initialize MPC environment
    mpc = MPCEnv[TP](pid)
    print(f"Initialized MPC for {pid}")
    
    benchmark(mpc)

    # This is here just to keep P0 online until the end for data transfer
    # In practice, P0 would send data in advance before each phase and go offline
    if (pid == 0):
        b: bool = mpc.comms.receive_bool(2)
    elif (pid == 2): mpc.comms.send_bool(True, 0)

    mpc.comms.clean_up()

    # if (success): print(f"Protocol successfully completed for {pid}")
    # else: raise ValueError(f"Protocol abnormally terminated for {pid}")

    print(f'{pid} is done!')


def invoke[TP]():
    for port in ALL_PORTS:
        address = get_address(port)
        unlink(address)

    pid_0 = fork()
    status = 0

    if (pid_0 == 0): client[TP](0)
    else:
        pid_1: int = fork()
        if (pid_1 == 0): client[TP](1)
        else:
            import time
            s = time.time()
            client[TP](2)
            e = time.time()
            print(f'Seconds: {e - s}')
            wait(ptr[byte](__ptr__(status).as_byte()))


invoke[int_t]()
