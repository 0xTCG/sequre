import utils.param as param
from utils.type_ops import TypeOps
from utils.utils import rand_int
from mpc_env import MPCEnv


def assert_values(result, expected):
    assert result == expected, f'Result: {result}. Expected: {expected}'

def assert_approx(result, expected, error: float = 0.1):
    check: bool = ((expected - error) < result) and (result < (expected + error))
    assert check, f'Result: {result}. Expected: {expected}'


def test_all[TP](mpc: MPCEnv[TP]):
    print 'DEBUG', mpc.pid, [rand_int(param.BASE_P) for _ in range(20)]
    raise ValueError('Done')
    
    vector_length: int = 10
    mat_rows_no, mat_cols_no = 10, 15

    # Test inputs
    elem_1 = TP(10)
    elem_2 = TP(7)
    vector_1 = [TP(10), TP(11), TP(12)]
    vector_2 = [TP(7), TP(8), TP(9)]
    matrix_1 = [[TP(1), TP(2), TP(3)], [TP(4), TP(5), TP(6)], [TP(7), TP(8), TP(9)]]
    matrix_2 = [[TP(10), TP(11), TP(12)], [TP(13), TP(14), TP(15)], [TP(16), TP(17), TP(18)]]
    a: TP = TypeOps.double_to_fp(2.0 if mpc.pid == 1 else 1.14, param.NBIT_K, param.NBIT_F)
    b: TP = TypeOps.double_to_fp(3.0 if mpc.pid == 1 else 2.95, param.NBIT_K, param.NBIT_F)

    elem_to_send: TP = TP(rand_int(param.BASE_P))
    if mpc.pid == 1:
        mpc.comms.send_data(elem_to_send, 2, param.SIZE_OF_U)
    elif mpc.pid == 2:
        received_elem: TP = mpc.comms.receive_elem(1)
        assert_values(received_elem, elem_to_send)
    
    vector_to_send: list[TP] = [TP(rand_int(param.BASE_P)) for _ in range(vector_length)]
    if mpc.pid == 1:
        mpc.comms.send_data(vector_to_send, 2, vector_length * param.SIZE_OF_U)
    elif mpc.pid == 2:
        received_vector: list[TP] = mpc.comms.receive_vector(1, length=vector_length)
        assert_values(received_vector, vector_to_send)
    
    mat_to_send: list[list[TP]] = [[TP(rand_int(param.BASE_P)) for _ in range(mat_cols_no)] for _ in range(mat_rows_no)]
    if mpc.pid == 1:
        mpc.comms.send_data(mat_to_send, 2, mat_rows_no * mat_cols_no * param.SIZE_OF_U)
    elif mpc.pid == 2:
        received_mat: list[list[TP]] = mpc.comms.receive_matrix(1, shape=[mat_rows_no, mat_cols_no])
        assert_values(received_mat, mat_to_send)

    revealed_elem: TP = mpc.comms.reveal_elem(elem_1 if mpc.pid == 1 else elem_2)
    if mpc.pid != 0:
        assert_values(revealed_elem, elem_1 + elem_2)
    
    revealed_vector: list[TP] = mpc.comms.reveal_vector(vector_1 if mpc.pid == 1 else vector_2)
    if mpc.pid != 0:
        assert_values(revealed_vector, vector_1 + vector_2)
    
    revealed_matrix: list[list[TP]] = mpc.comms.reveal_matrix(matrix_1 if mpc.pid == 1 else matrix_2)
    if mpc.pid != 0:
        assert_values(revealed_matrix, matrix_1 + matrix_2)
    
    if mpc.pid == 1:
        mpc.prg.switch_seed(0)
    if mpc.pid == 2:
        mpc.prg.switch_seed(0)
    random_number: TP = TP(rand_int(param.BASE_P))
    if mpc.pid != 0:
        mpc.comms.send_data(random_number, 0, param.SIZE_OF_U)
    if mpc.pid == 1:
        mpc.prg.restore_seed(0)
    if mpc.pid == 2:
        mpc.prg.restore_seed(0)
    
    if mpc.pid == 0:
        mpc.prg.switch_seed(2)
        random_number: TP = TP(rand_int(param.BASE_P))
        mpc.prg.restore_seed(2)
        received_random_number: TP = mpc.comms.receive_elem(2)
        assert_values(random_number, received_random_number)

        mpc.prg.switch_seed(1)
        random_number: TP = TP(rand_int(param.BASE_P))
        mpc.prg.restore_seed(1)
        received_random_number: TP = mpc.comms.receive_elem(1)
        assert_values(random_number, received_random_number)

    elem_1 = TP(10)
    elem_2 = TP(7)
    x_r, r = mpc.arithmetic.beaver_partition_elem(elem_1 if mpc.pid == 1 else elem_2)
    if mpc.pid == 0:
        mpc.comms.send_data(r, 1, param.SIZE_OF_U)
        mpc.comms.send_data(r, 2, param.SIZE_OF_U)
    else:
        r_0 = mpc.comms.receive_elem(0)
        assert_values(r_0, mpc.comms.reveal_elem(r))
        assert_values((x_r + mpc.comms.reveal_elem(r)) % mpc.primes[0], (elem_1 + elem_2) % mpc.primes[0])
    
    x_r_vec, r_vec = mpc.arithmetic.beaver_partition_vec(vector_1 if mpc.pid == 1 else vector_2)
    if mpc.pid == 0:
        mpc.comms.send_data(r_vec, 1, len(vector_1) * param.SIZE_OF_U)
        mpc.comms.send_data(r_vec, 2, len(vector_1) * param.SIZE_OF_U)
    else:
        r_0 = mpc.comms.receive_vector(0, len(vector_1))
        assert_values(r_0, mpc.comms.reveal_vector(r_vec))
        assert_values((x_r_vec + mpc.comms.reveal_vector(r_vec)) % mpc.primes[0], (vector_1 + vector_2) % mpc.primes[0])
        
    x_r_mat, r_mat = mpc.arithmetic.beaver_partition_mat(matrix_1 if mpc.pid == 1 else matrix_2)
    if mpc.pid == 0:
        mpc.comms.send_data(r_mat, 1, matrix_1.shape()[0] * matrix_1.shape()[1] * param.SIZE_OF_U)
        mpc.comms.send_data(r_mat, 2, matrix_1.shape()[0] * matrix_1.shape()[1] * param.SIZE_OF_U)
    else:
        r_0 = mpc.comms.receive_matrix(0, matrix_1.shape())
        assert_values(r_0, mpc.comms.reveal_matrix(r_mat))
        assert_values((x_r_mat + mpc.comms.reveal_matrix(r_mat)) % mpc.primes[0], (matrix_1 + matrix_2) % mpc.primes[0])

    p_elem = mpc.arithmetic.multiply_elem(
        elem_1 if mpc.pid == 1 else elem_2,
        elem_2 if mpc.pid == 1 else elem_1)
    revealed_p_elem = mpc.comms.reveal_elem(p_elem)
    if mpc.pid != 0:
        assert_values(revealed_p_elem, (elem_1 + elem_2) ** 2 % mpc.primes[0])

    p_vec = mpc.arithmetic.multiply_vec(
        vector_1 if mpc.pid == 1 else vector_2,
        vector_2 if mpc.pid == 1 else vector_1)
    revealed_p_vec = mpc.comms.reveal_vector(p_vec)
    if mpc.pid != 0:
        assert_values(revealed_p_vec, (vector_1 + vector_2) ** 2 % mpc.primes[0])

    p_mat = mpc.arithmetic.multiply_mat(
        matrix_1 if mpc.pid == 1 else matrix_2,
        matrix_2 if mpc.pid == 1 else matrix_1)
    revealed_p_mat = mpc.comms.reveal_matrix(p_mat)
    if mpc.pid != 0:
        assert_values(revealed_p_mat, (matrix_1 + matrix_2) ** 2 % mpc.primes[0])

    p_mat_bulk = mpc.arithmetic.multiply_bulk(
        [matrix_1 if mpc.pid == 1 else matrix_2],
        [matrix_2 if mpc.pid == 1 else matrix_1])
    revealed_p_mat = mpc.comms.reveal_matrix(p_mat_bulk[0])
    if mpc.pid != 0:
        assert_values(revealed_p_mat, (matrix_1 + matrix_2) ** 2 % mpc.primes[0])
    
    p_mat_bulk = mpc.arithmetic.multiply_mat_bulk(
        [matrix_1 if mpc.pid == 1 else matrix_2],
        [matrix_2 if mpc.pid == 1 else matrix_1])
    revealed_p_mat = mpc.comms.reveal_matrix(p_mat_bulk[0])
    added_mat = matrix_1 + matrix_2
    if mpc.pid != 0:
        assert_values(revealed_p_mat, added_mat.mult(added_mat, mpc.primes[0]))
    
    # TODO: Check if convertiong TP to int in langrangian caused problems
    if mpc.pid != 0:
        # assert_values(mpc.polynomial.lagrange_cache[0][0][1], TP(432479344))
        # assert_values(mpc.polynomial.lagrange_cache[1][1][1], TP(1945125663))
        assert_values(mpc.polynomial.lagrange_cache[2][1][1], TP(8456863007111094651))

    p = mpc.polynomial.powers([TP(2), TP(0) if mpc.pid == 1 else TP(1), TP(3)], 10)
    revealed_p = mpc.comms.reveal_matrix(p)
    if mpc.pid != 0:
        assert_values(revealed_p[10], [TP(1048576), TP(1), TP(60466176)])
    
    coeff: list[list[TP]] = [[TP(1) for _ in range(3)], [TP(2) for _ in range(3)], [TP(3) for _ in range(3)]]
    x: list[TP] = [TP(1), TP(2), TP(3)]
    p = mpc.polynomial.evaluate_poly(x, coeff)
    revealed_p = mpc.comms.reveal_matrix(p)
    if mpc.pid != 0:
        expected_mat = [
            [TP(7), TP(21), TP(43)],
            [TP(14), TP(42), TP(86)],
            [TP(21), TP(63), TP(129)]]
        assert_values(revealed_p, expected_mat)
    
    pub: TP = TypeOps.double_to_fp(5.07, param.NBIT_K, param.NBIT_F)
    a = mpc.arithmetic.add_public(a, pub)
    float_a_mat = mpc.fp.print_fp([[a]])
    if mpc.pid != 0:
        assert_approx(float_a_mat, [[8.21]])

    a_mat: list[list[TP]] = [[a]]
    b_mat: list[list[TP]] = [[b]]

    p_or = mpc.comms.reveal_matrix(mpc.boolean.prefix_or(a_mat))
    # if mpc.pid != 0:
    #     assert_values(p_or, [[TP(1179446410)]])

    float_a = mpc.fp.print_fp([[a]])
    float_b = mpc.fp.print_fp([[b]])
    if mpc.pid != 0:
        assert_approx(float_a, [[8.21]])
        assert_approx(float_b, [[5.95]])

    d: list[list[TP]] = mpc.arithmetic.multiply_mat(a_mat, b_mat)
    d = mpc.fp.trunc(d, param.NBIT_K + param.NBIT_F, param.NBIT_F)
    float_d_mat = mpc.fp.print_fp(d)
    # TODO: Investigate why adding field to the value mess up results
    if mpc.pid != 0:
        assert_approx(float_d_mat, [[48.8495]])

    ne, ne_sqrt = mpc.fp.normalizer_even_exp([TP(4), TP(1)], mpc.primes[1])

    if mpc.pid != 0:
        nee_0 = mpc.fp.print_fp([mpc.comms.reveal_vector(ne)])
        nee_1 = mpc.fp.print_fp([mpc.comms.reveal_vector(ne_sqrt)])
        # assert_values(nee_0, [[65536.0, 0.0]])
        # assert_values(nee_1, [[0.5, 2.0]])

    a_vec: list[TP] = [
        TypeOps.double_to_fp(18.0, param.NBIT_K, param.NBIT_F),
        TypeOps.double_to_fp(128.0, param.NBIT_K, param.NBIT_F),
        TypeOps.double_to_fp(32.0, param.NBIT_K, param.NBIT_F),
        TypeOps.double_to_fp(50.0, param.NBIT_K, param.NBIT_F)]
    b_vec, b_vec_inv = mpc.fp.fp_sqrt(a_vec)
    float_b: list[list[float]] = mpc.fp.print_fp([b_vec])
    float_b_inv: list[list[float]] = mpc.fp.print_fp([b_vec_inv])
    if mpc.pid != 0:
        assert_approx(float_b, [[6.0, 16.0, 8.0, 10.0]])
        assert_approx(float_b_inv, [[0.1666666, 0.0625, 0.125, 0.1]])

    a_vec = [TP(7), TP(256), TP(99), TP(50)]
    b_vec = [TP(6), TP(16), TP(3), TP(40)]
    d_vec = mpc.fp.fp_div(a_vec, b_vec)
    float_d = mpc.fp.print_fp([d_vec])
    if mpc.pid != 0:
        assert_approx(float_d, [[1.1666666, 16.0, 33.0, 1.25]])
        
    a_vec = [
        TypeOps.double_to_fp(1.5, param.NBIT_K, param.NBIT_F),
        TypeOps.double_to_fp(0.5, param.NBIT_K, param.NBIT_F),
        TypeOps.double_to_fp(2.5, param.NBIT_K, param.NBIT_F)]
    v: list[TP] = mpc.lin_alg.householder(a_vec)
    float_v = mpc.fp.print_fp([v])
    if mpc.pid != 0:
        assert_approx(float_v, [[0.86807, 0.0973601, 0.486801]])

    raise ValueError('Done')
        
    mat = [
        [TypeOps.double_to_fp(4.0, param.NBIT_K, param.NBIT_F) for _ in range(3)],
        [TypeOps.double_to_fp(4.5, param.NBIT_K, param.NBIT_F) for _ in range(3)],
        [TypeOps.double_to_fp(5.5, param.NBIT_K, param.NBIT_F) for _ in range(3)]]
    q_fact, r_fact = mpc.lin_alg.qr_fact_square(mat)
    result_q = mpc.fp.print_fp(q_fact)
    result_r = mpc.fp.print_fp(r_fact)
    # expected_q = [
    #     [-0.57735, -0.57735, -0.57735],
    #     [-0.57735, 0.788675, -0.211325],
    #     [-0.57735, -0.211325, 0.788675]]
    # expected_r = [
    #     [-13.85640, 0.0, 0.0],
    #     [-15.58846, 0.0, 0.0],
    #     [-19.05255, 0.0, 0.0]]
    # if mpc.pid != 0:
    #     assert_approx(result_q, expected_q)
    #     assert_approx(result_r, expected_r)
        
    mat = [
        [TypeOps.double_to_fp(4.0, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(3.0, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(2.5, param.NBIT_K, param.NBIT_F)],
        [TypeOps.double_to_fp(0.5, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(4.5, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(1.5, param.NBIT_K, param.NBIT_F)],
        [TypeOps.double_to_fp(5.5, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(2.0, param.NBIT_K, param.NBIT_F),
            TypeOps.double_to_fp(1.0, param.NBIT_K, param.NBIT_F)]]
    t, q = mpc.lin_alg.tridiag(mat)
    result_t = mpc.fp.print_fp(t)
    result_q = mpc.fp.print_fp(q)
    # expected_t = [
    #     [8.0, -7.81025, 0.0],
    #     [-7.81025, 9.57377, 3.31148],
    #     [0.0, 2.31148, 1.42623]]
    expected_q = [
        [1.0, 0.0, 0.0],
        [0.0, -0.768221, -0.640184],
        [0.0, -0.640184, 0.768221]]
    if mpc.pid != 0:
    #     assert_approx(result_t, expected_t)
        assert_approx(result_q, expected_q)
        
    v_mat, l = mpc.lin_alg.eigen_decomp(mat)
    result_v_mat = mpc.fp.print_fp(v_mat)
    result_l = mpc.fp.print_fp([l])
    # expected_v_mat = [
    #     [0.650711, 0.672083, 0.353383],
    #     [-0.420729, -0.0682978, 0.904612],
    #     [0.632109, -0.73732, 0.238322]]
    # expected_l = [16.91242, -0.798897, 2.88648]
    # if mpc.pid != 0:
    #     assert_approx(result_v_mat, expected_v_mat)
    #     assert_approx(result_l, expected_l)
        
    q_mat = mpc.lin_alg.orthonormal_basis(mat)
    result_q_mat = mpc.fp.print_fp(q_mat)
    # expected_q_mat = [
    #     [-0.715542, -0.536656, -0.447214],
    #     [0.595097, -0.803563, 0.0121201],
    #     [0.365868, 0.257463, -0.894345]]
    # if mpc.pid != 0:
    #     assert_approx(result_q_mat, expected_q_mat)

    print(f'All tests passed at {mpc.pid}!')


def benchmark[TP](mpc: MPCEnv[TP], m: int, n: int):
    # import random, math
    import time
    
    # mat: np.ndarray = np.arange(m * n).reshape(m, n)
    mat: list[list[TP]] = [[TP(i + j) for j in range(n)] for i in range(m)]  # np.zeros((m, n), dtype=np.int64)
    
    # print('Orthonormal basis ...')
    # mpc.orthonormal_basis(mat)
    # print('QR ...')
    # mpc.qr_fact_square(mat)
    # print('Tridiag ...')
    # mpc.tridiag(mat)
    
    print('Eigen decomp ...')
    s = time.time()
    mpc.lin_alg.eigen_decomp(mat)
    e = time.time()
    print(f'Eigendecomp done in {e - s}s')
    
    # from profilehooks import profile
    # fn = profile(mpc.eigen_decomp, entries=200) if pid == 2 else mpc.eigen_decomp
    # fn(mat)

    # coeff = np.arange(1000000, dtype=np.int64).reshape((1000, 1000))
    # x = np.arange(100, dtype=np.int64)

    # from line_profiler import LineProfiler
    # lp = LineProfiler()
    # fn = lp(mul_mod) if pid == 2 else mul_mod
    # fn(mat)
    # fn(coeff, coeff, param.BASE_P)
    # if pid == 2:
    #     lp.print_stats()
    

    print(f'Benchmarks done at {mpc.pid}!')
