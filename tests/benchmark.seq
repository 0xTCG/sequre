from ..protocols.seq_gwas import gwas_protocol as seq_gwas
from ..protocols.sequre_gwas import gwas_protocol as sequre_gwas
from ..protocols.seq_logireg import logireg_protocol as seq_logireg
from ..protocols.sequre_logireg import logireg_protocol as sequre_logireg
from ..protocols.seq_nn import neural_net_protocol as seq_nn
from ..protocols.sequre_nn import neural_net_protocol as sequre_nn
from ..protocols.utils.data_sharing import share_all_data

from utils import time_frame
from ..playground import playground

from sequre.stdlib.lin_alg import *
from sequre.stdlib.fp import *
from sequre.utils.param import *
from sequre.utils.utils import get_address, evalp
from sequre.types.utils import double_to_fp
from sequre.attributes import *
from sequre.mpc.env import MPCEnv

from C import fork() -> int
from C import wait(cobj) -> int
from C import unlink(str) -> int


################################### Wrappers #####################################
def playground_sample_wrapper(mpc, a, b, c, modulus):
    print('Result: ', mpc.comms.reveal(playground(mpc, a, b, c).share, modulus))

def seq_lin_alg_wrapper(mpc, h_mat, modulus):
    mpc.lin_alg.qr_fact_square(h_mat, modulus)
    mpc.lin_alg.tridiag(h_mat, modulus)
    mpc.lin_alg.eigen_decomp(h_mat, modulus)
    mpc.lin_alg.orthonormal_basis(h_mat, modulus)

def sequre_lin_alg_wrapper(mpc, sv_mat):
    qr_fact_square(mpc, sv_mat)
    tridiag(mpc, sv_mat)
    eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    orthonormal_basis(mpc, sv_mat)

def seq_gwas_wrapper(mpc, modulus):
    seq_gwas(mpc, True, modulus)

def sequre_gwas_wrapper(mpc, modulus):
    sequre_gwas(mpc, True, modulus)

def seq_logireg_wrapper(mpc, modulus):
    seq_logireg(mpc, True, modulus)

def sequre_logireg_wrapper(mpc, modulus):
    sequre_logireg(mpc, True, modulus)

def seq_nn_wrapper(mpc, modulus):
    seq_nn(mpc, True, modulus)

def sequre_nn_wrapper(mpc, modulus):
    sequre_nn(mpc, True, modulus)
################################################################


def benchmark(mpc, modulus):
    a = SharedTensor[list[int_t]]([int_t(1), int_t(1)], modulus)
    b = SharedTensor[list[int_t]]([int_t(2), int_t(2)], modulus)
    c = SharedTensor[list[int_t]]([int_t(3), int_t(3)], modulus)

    h_mat = [[double_to_fp(float(i + j), modulus) for i in range(50)] for j in range(50)]
    sv_mat = SharedTensor[list[list[int_t]]](h_mat, modulus)
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, modulus))
    sv_mat.fp = True

    share_all_data[int_t](mpc, True, modulus)

    time_frame(mpc, playground_sample_wrapper, 'Playground', a, b, c, modulus)
    # time_frame(mpc, seq_lin_alg_wrapper, 'Seq linear algebra', h_mat, modulus)
    # time_frame(mpc, sequre_lin_alg_wrapper, 'Sequre linear algebra', sv_mat)
    # time_frame(mpc, seq_gwas_wrapper, 'Seq GWAS', modulus)
    # time_frame(mpc, sequre_gwas_wrapper, 'Sequre GWAS', modulus)
    # time_frame(mpc, seq_logireg_wrapper, 'Seq logistic regression', modulus)
    # time_frame(mpc, sequre_logireg_wrapper, 'Sequre logistic regression', modulus)
    # time_frame(mpc, seq_nn_wrapper, 'Seq neural net', modulus)
    # time_frame(mpc, sequre_nn_wrapper, 'Sequre neural net', modulus)
