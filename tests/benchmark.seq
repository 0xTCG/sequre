from sequre.stdlib.lin_alg import *
from sequre.stdlib.fp import *
from ..protocols.seq_gwas import gwas_protocol as seq_gwas
from ..protocols.sequre_gwas import gwas_protocol as sequre_gwas
from ..protocols.seq_logireg import logireg_protocol as seq_logireg
from ..protocols.sequre_logireg import logireg_protocol as sequre_logireg
from ..protocols.seq_nn import neural_net_protocol as seq_nn
from ..protocols.sequre_nn import neural_net_protocol as sequre_nn
from ..playground import playground

from sequre.utils.param import *
from sequre.utils.utils import get_address, evalp
from sequre.types.utils import double_to_fp

from sequre.mpc.env import MPCEnv

from C import fork() -> int
from C import wait(cobj) -> int
from C import unlink(str) -> int

from sequre.attributes import *
from ..protocols.utils.data_sharing import share_all_data


MODULUS = FIELD_PRIME


def benchmark(mpc):
    # a = SharedTensor[list[list[int_t]]](
    #     [[int_t(1), int_t(1)],
    #     [int_t(1), int_t(1)]])
    # b = SharedTensor[list[list[int_t]]](
    #     [[int_t(2), int_t(2)],
    #     [int_t(2), int_t(2)]])
    # c = SharedTensor[list[list[int_t]]](
    #     [[int_t(3), int_t(3)],
    #     [int_t(3), int_t(3)]])
    a = SharedTensor[list[int_t]]([int_t(1), int_t(1)])
    b = SharedTensor[list[int_t]]([int_t(2), int_t(2)])
    c = SharedTensor[list[int_t]]([int_t(3), int_t(3)])
    # a = SharedTensor[int_t](1)
    # b = SharedTensor[int_t](2)
    # c = SharedTensor[int_t](3)

    vec = [
        double_to_fp(1.5, MODULUS),
        double_to_fp(0.5, MODULUS),
        double_to_fp(2.5, MODULUS)]
    sv = SharedTensor[list[int_t]](vec)
    sv.fp = True
    
    h_vec = [double_to_fp(float(i), MODULUS) for i in range(500000)]
    sv_vec = SharedTensor[list[int_t]](h_vec)
    sv_vec.fp = True

    h_mat = [[double_to_fp(float(i + j), MODULUS) for i in range(50)] for j in range(50)]
    sv_mat = SharedTensor[list[list[int_t]]](h_mat)
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, MODULUS))
    sv_mat.fp = True

    share_all_data[int_t](mpc, True, MODULUS)

    import time
    s = time.time()
    mpc.reset_stats()

    # Playground samples #
    ######################
    print('Final result: ', mpc.comms.reveal(playground(mpc, a, b, c).share, MODULUS))
    
    # ####### Seq FP #######
    # ######################
    # result = mpc.fp.fp_sqrt(h_vec[:1000], MODULUS)

    # ###### Sequre FP #####
    # ######################
    # result = fp_sqrt(mpc, sv_vec[:1000])

    # #### Seq lin alg #####
    # ######################
    # result = mpc.lin_alg.householder(h_vec)
    # result_0 = mpc.lin_alg.qr_fact_square(h_mat, MODULUS)
    # result_1 = mpc.lin_alg.tridiag(h_mat, MODULUS)
    # result_2 = mpc.lin_alg.eigen_decomp(h_mat, MODULUS)
    # result_3 = mpc.lin_alg.orthonormal_basis(h_mat, MODULUS)

    # ### Sequre lin alg ###
    # ######################
    # result = householder(mpc, sv_vec)
    # result_0 = qr_fact_square(mpc, sv_mat)
    # result_1 = tridiag(mpc, sv_mat)
    # result_2 = eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    # result_3 = orthonormal_basis(mpc, sv_mat)

    # ###### Seq GWAS ######
    # ######################
    # seq_gwas(mpc, True, MODULUS)

    # #### Sequre GWAS #####
    # ######################
    # sequre_gwas(mpc, True)

    # #### Seq logireg #####
    # ######################
    # seq_logireg(mpc, True, MODULUS)

    # ### Sequre logireg ###
    # ######################
    # sequre_logireg(mpc, True)

    # #### Seq neural net #####
    # ######################
    # seq_nn(mpc, True, MODULUS)

    # ### Sequre neural net ###
    # ######################
    # sequre_nn(mpc, True)

    e = time.time()
    print(f'Done in {e - s}s at {mpc.pid}')
    mpc.print_stats()

    mpc.comms.sync_parties()
