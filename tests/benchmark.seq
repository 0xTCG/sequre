from ..protocols.sequre_gwas import gwas_protocol
from ..protocols.sequre_nn import neural_net_protocol
from ..protocols.opal import opal_protocol as opal
from ..protocols.sequre_ganon import ganon_classification as ganon, FilterConfig
from ..protocols.utils.data_sharing import share_all_data

from utils import time_frame
from ..playground import playground

from sequre.stdlib.lin_alg import *
from sequre.stdlib.fp import *
from sequre.utils.param import *
from sequre.utils.utils import get_address, evalp
from sequre.types.utils import double_to_fp
from sequre.attributes import *
from sequre.mpc.env import MPCEnv

from C import fork() -> int
from C import wait(cobj) -> int
from C import unlink(str) -> int


################################### Wrappers #####################################
def playground_wrapper(mpc, modulus, a, b, c, d):
    return playground(mpc, a, b, c, d)

def lin_alg_wrapper(mpc, modulus, sv_mat):
    qr_fact_square(mpc, sv_mat)
    tridiag(mpc, sv_mat)
    eigen_decomp(mpc, sv_mat)
    return orthonormal_basis(mpc, sv_mat)

def gwas_wrapper(mpc, modulus):
    return gwas_protocol(mpc, True, modulus)

def dti_wrapper(mpc, modulus):
    return neural_net_protocol(mpc, True, modulus)

def opal_wrapper(mpc, modulus):
    return opal(mpc, True, modulus)

def ganon_wrapper(mpc, modulus):

    parsed_hierarchy = {
        "level_1": {
                "window_size": 0,
                "kmer_size": 19,
                "offset": 1,
                "rel_filter": 1,
                "abs_filter": 0,
                "alphabet_size": 5  # the size of the nucleotide alphabeth -- 5 in case of SeqAn's IBF (A,C,G,N,T)
            }
        }

    filter_config = FilterConfig(
        ibf_path="data/ganon/opal_dataset_ibf.bin",
        map_path="data/ganon/opal_dataset_map.txt",
        rel_cutoff=0.25,
        abs_cutoff=0.0,
        bin_count=63,
        hash_count=3)

    # run(parsed_hierarchy, [filter_config], 'data/ganon/bac.sim.1.fq')
    return ganon(mpc, parsed_hierarchy, [filter_config], 'data/opal/test.fragments.fasta', modulus, True)

##################################################################################


def benchmark(mpc, run_playground, modulus):
    a = SharedTensor[list[int_t]](mpc.comms.share([int_t(i) for i in range(10)], modulus), modulus)
    b = SharedTensor[list[int_t]](mpc.comms.share(
        [int_t(1), int_t(2), int_t(1), int_t(2), int_t(3),
         int_t(4), int_t(3), int_t(4), int_t(1), int_t(5)], modulus), modulus)
    c = SharedTensor[list[int_t]](mpc.comms.share([int_t(i) for i in range(10)], modulus), modulus)
    d = SharedTensor[list[int_t]](mpc.comms.share(
        [int_t(1), int_t(2), int_t(1), int_t(2), int_t(3),
         int_t(4), int_t(3), int_t(4), int_t(1), int_t(5)], modulus), modulus)

    if run_playground:
        time_frame(mpc, playground_wrapper, 'Playground', modulus, a, b, c, d)
    else:
        h_mat = [[double_to_fp(float(i + j), modulus) for i in range(50)] for j in range(50)]
        sv_mat = SharedTensor[list[list[int_t]]](h_mat, modulus)
        sv_mat.get_partitions(mpc)
        sv_mat.fp = True

        share_all_data[int_t](mpc, True, modulus)

        time_frame(mpc, lin_alg_wrapper, 'Linear algebra', modulus, sv_mat)
        time_frame(mpc, gwas_wrapper, 'Genome-wide association study', modulus)
        time_frame(mpc, dti_wrapper, 'Drug-target interaction inference', modulus)
        # time_frame(mpc, opal_wrapper, 'Opal', modulus)
        # time_frame(mpc, ganon_wrapper, 'Ganon', modulus)
