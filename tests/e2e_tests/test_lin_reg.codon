from numpy.create import ones, array, zeros_like

from ..utils import assert_eq, assert_eq_approx

from sequre.types.sharetensor import Sharetensor
from sequre.types.multiparty_partition import MPP
from sequre.utils.utils import random_floats
from sequre.mpc.env import MPCEnv
from sequre.stdlib.learn.lin_reg import LinReg


def test_lin_reg[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre linear regression on {alg_struct} ... \n')

    rows_per_party = 4
    cols_per_party = 9
    with mpc.randomness.seed_switch(-1):
        X = array(random_floats(((mpc.comms.number_of_parties - 1) * rows_per_party, cols_per_party)))
        target_w = array(random_floats((cols_per_party, 1), scale=1))
        target_b = 1.0
        Y = X @ target_w + target_b
    target_w = target_w.vstack(array([[target_b]]))

    mpc_X = Sharetensor.enc(mpc, X, 0, modulus)
    mpc_Y = Sharetensor.enc(mpc, Y, 0, modulus)
    
    mpp_X = MPP(mpc, zeros_like(X) if mpc.pid == 0 else X[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party])
    mpp_Y = MPP(mpc, zeros_like(Y) if mpc.pid == 0 else Y[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party])

    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}:\tLinear regression train data for debugging on {alg_struct}:", X), False)
    if mpc.pid > 0:
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking linear regression data loading (MPC) on {alg_struct}", mpc_X.reveal(mpc), X)
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking linear regression data loading (MPP) on {alg_struct}", mpp_X.reveal(mpc), X)

    step_size = 0.001
    epochs = 2

    features_size = cols_per_party + 1
    raw_initial_w = ones((features_size, 1))
    mpc_initial_w = Sharetensor.enc(mpc, raw_initial_w, 0, modulus)
    
    raw_lin_reg = LinReg(raw_initial_w).fit(mpc, X=X, Y=Y, step=step_size, epochs=epochs)
    mpc_lin_reg = LinReg(mpc_initial_w).fit(mpc, X=mpc_X, Y=mpc_Y, step=step_size, epochs=epochs)

    raw_w = raw_lin_reg.coef_
    mpc_w = mpc_lin_reg.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking linear regression result shape (MPC) on {alg_struct}", mpc_w.shape, list(raw_w.shape))
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre linear regression (MPC) on {alg_struct}", mpc_w.reveal(mpc), raw_w)
    
    mpp_initial_w = MPP(
        mpc, zeros_like(raw_initial_w) if mpc.pid == 0 else raw_initial_w[
            (mpc.pid - 1) * features_size // (mpc.comms.number_of_parties - 1):mpc.pid * features_size // (mpc.comms.number_of_parties - 1)])
    mpp_lin_reg = LinReg(mpp_initial_w).fit(mpc, X=mpp_X, Y=mpp_Y, step=step_size, epochs=epochs)
    mpp_w = mpp_lin_reg.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking linear regression result shape (MPP) on {alg_struct}", mpp_w.shape, mpp_w.shape)
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre linear regression (MPP) on {alg_struct}", mpp_w.reveal(mpc), raw_w)

    print(f'CP{mpc.pid}:\tSequre linear regression on {"ring" if modulus.popcnt() == 1 else "field"} tests passed.\n')
    