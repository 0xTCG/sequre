from numpy.create import array

from ..utils import random_floats, assert_eq_approx

from sequre.stdlib.lin_alg import householder, qr_fact_square, tridiag, eigen_decomp, orthonormal_basis
from sequre.types.sharetensor import Sharetensor
from sequre.types.internal import Internal


def test_lin_alg(mpc, modulus):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting sequre MPC linear algebra on {alg_struct} ... \n')
    
    with mpc.randomness.seed_switch(-1):
        raw_vec = random_floats((8,))
        raw_mat = random_floats((8, 8))
    mpc_vec = Sharetensor.enc(mpc, raw_vec, 0, modulus)
    mpp_vec = mpc_vec.to_mpp(mpc, [1, 0], dtype=float)
    mpc_mat = Sharetensor.enc(mpc, raw_mat, 0, modulus)
    mpp_mat = mpc_mat.to_mpp(mpc, [4, 4], dtype=float)
    
    raw_v = householder(mpc, array(raw_vec))
    mpc_v = householder(mpc, mpc_vec)
    mpp_v = householder(mpc, mpp_vec)
    if mpc.pid != 0:
        assert_eq_approx(f'Sequre householder (MPC) on {alg_struct}', mpc_v.reveal(mpc), raw_v.tolist())
        assert_eq_approx(f'MPC input intact post householder on {alg_struct}', mpc_vec.reveal(mpc), raw_vec, silent_pass=True)
        assert_eq_approx(f'Sequre householder (MPP) on {alg_struct}', mpp_v.reveal(mpc), raw_v)
        assert_eq_approx(f'MPP input intact post householder on {alg_struct}', mpp_vec.reveal(mpc), array(raw_vec), silent_pass=True)

    raw_orth = orthonormal_basis(mpc, array(raw_mat))
    mpc_orth = orthonormal_basis(mpc, mpc_mat)
    mpp_orth = orthonormal_basis(mpc, mpp_mat)
    if mpc.pid != 0:
        assert_eq_approx(f'Sequre orthonormal basis (MPC) on {alg_struct}', mpc_orth.reveal(mpc), raw_orth.tolist())
        assert_eq_approx(f'MPC input intact post orthonormal basis on {alg_struct}', mpc_mat.reveal(mpc), raw_mat, silent_pass=True)
        assert_eq_approx(f'Sequre orthonormal basis (MPP) on {alg_struct}', mpp_orth.reveal(), raw_orth)
        assert_eq_approx(f'MPP input intact post orthonormal basis on {alg_struct}', mpp_mat.reveal().tolist(), raw_mat, silent_pass=True)

    raw_q_fact, raw_r_fact = qr_fact_square(mpc, array(raw_mat))
    mpc_q_fact, mpc_r_fact = qr_fact_square(mpc, mpc_mat)
    mpp_q_fact, mpp_r_fact = qr_fact_square(mpc, mpp_mat)
    mpc_result_mat = Internal.matmul(mpc, mpc_r_fact, mpc_q_fact)
    mpp_result_mat = Internal.matmul(mpc, mpp_r_fact, mpp_q_fact)
    if mpc.pid != 0:
        assert_eq_approx(f'Sequre QR factorization (MPC) on {alg_struct}: Q correctness', mpc_q_fact.reveal(mpc), raw_q_fact.tolist())
        assert_eq_approx(f'Sequre QR factorization (MPC) on {alg_struct}: R correctness', mpc_r_fact.reveal(mpc), raw_r_fact.tolist())
        assert_eq_approx(f'Sequre QR factorization (MPC) on {alg_struct}: validity', mpc_result_mat.reveal(mpc), (raw_r_fact @ raw_q_fact).tolist())
        assert_eq_approx(f'MPC input intact post QR factorization on {alg_struct}', mpc_mat.reveal(mpc), raw_mat, silent_pass=True)
        assert_eq_approx(f'Sequre QR factorization (MPP) on {alg_struct}: Q correctness', mpp_q_fact.reveal(mpc), raw_q_fact, error=0.1)
        assert_eq_approx(f'Sequre QR factorization (MPP) on {alg_struct}: R correctness', mpp_r_fact.reveal(mpc), raw_r_fact, error=0.1)
        assert_eq_approx(f'Sequre QR factorization (MPP) on {alg_struct}: validity', mpp_result_mat.reveal(mpc), raw_r_fact @ raw_q_fact, error=0.1)
        assert_eq_approx(f'MPP input intact post QR factorization on {alg_struct}', mpp_mat.reveal(mpc).tolist(), raw_mat, silent_pass=True)

    raw_t, raw_q = tridiag(mpc, array(raw_mat))
    mpc_t, mpc_q = tridiag(mpc, mpc_mat)
    if mpc.pid != 0:
        assert_eq_approx(f'Sequre tridiagonalize T on {alg_struct}', mpc_t.reveal(mpc), raw_t.tolist())
        assert_eq_approx(f'Sequre tridiagonalize Q on {alg_struct}', mpc_q.reveal(mpc), raw_q.tolist())
        assert_eq_approx(f'Input intact post tridiagonalization on {alg_struct}', mpc_mat.reveal(mpc), raw_mat, silent_pass=True)
    
    # TODO: Check why the sign of the eigen decomposition result is flipped for some inputs
    # raw_eigen_mat, raw_eigen_val = eigen_decomp(mpc, array(raw_mat))
    # mpc_eigen_mat, mpc_eigen_val = eigen_decomp(mpc, mpc_mat)
    # if mpc.pid != 0:
    #     assert_eq_approx(f'Sequre eigen decomposition eigen matrix on {alg_struct}', mpc_eigen_mat.reveal(mpc), raw_eigen_mat.tolist())
    #     assert_eq_approx(f'Sequre eigen decomposition eigen values on {alg_struct}', mpc_eigen_val.reveal(mpc), raw_eigen_val.tolist(), error=0.15)
    #     assert_eq_approx(f'Input intact post eigen decomposition {alg_struct}', mpc_mat.reveal(mpc), raw_mat, silent_pass=True)
