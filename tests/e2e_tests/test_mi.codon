from numpy.create import ones, array
from numpy.ndarray import ndarray

from ..utils import assert_eq, assert_eq_approx

from sequre.types.sharetensor import Sharetensor
from sequre.utils.utils import random_floats
from sequre.mpc.env import MPCEnv
from sequre.stdlib.learn.lin_reg import LinReg
from sequre.stdlib.learn.mi import MI, Imputer


def test_mi[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre multiple imputation on {alg_struct} ... \n')

    rows_per_party = 4
    cols_per_party = 8
    with mpc.randomness.seed_switch(-1):
        complete_data = ndarray.rand(((mpc.comms.number_of_parties - 1) * rows_per_party, cols_per_party)) * 7
        labels = complete_data @ ndarray.rand((cols_per_party, 1)) + 1.0

    data = complete_data.copy()
    miss_col = 0
    miss_val = 0.0
    miss_rate = rows_per_party // 2
    
    miss_rows_set = set[int]()
    with mpc.randomness.seed_switch(-1):
        for _ in range(miss_rate):
            miss_row = int.rand(len(data) - 1)
            data[miss_row][miss_col] = miss_val
            miss_rows_set.add(miss_row)
    miss_rows = sorted(list(miss_rows_set))
    
    mpc_data = Sharetensor.enc(mpc, data, 0, modulus)
    mpc_labels = Sharetensor.enc(mpc, labels, 0, modulus)
    
    mpc.comms.sequential(lambda: print(f"\nCP{mpc.pid}:\tMultiple imputation data for debugging on {alg_struct}:", complete_data.__repr__()), False)
    if mpc.pid > 0:
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking multiple imputation data loading (MPC) on {alg_struct}", mpc_data.reveal(mpc), data)

    step_size = 0.001
    epochs = 40

    raw_initial_w = ones((cols_per_party, 1))
    mpc_initial_w = Sharetensor.enc(mpc, raw_initial_w, 0, modulus)
    raw_impute_model = LinReg(raw_initial_w)
    mpc_impute_model = LinReg(mpc_initial_w)

    raw_initial_w = ones((cols_per_party + 1, 1))
    mpc_initial_w = Sharetensor.enc(mpc, raw_initial_w, 0, modulus)
    raw_fit_model = LinReg(raw_initial_w)
    mpc_fit_model = LinReg(mpc_initial_w)

    factor = 5
    mpc.randomness.reset_seed(-1, hash('global'))
    raw_mi = MI(factor, raw_impute_model, raw_fit_model).fit(
        mpc, data, labels, miss_rows, miss_col, step_size, epochs)
    mpc.randomness.reset_seed(-1, hash('global'))
    mpc_mi = MI(factor, mpc_impute_model, mpc_fit_model).fit(
        mpc, mpc_data, mpc_labels, miss_rows, miss_col, step_size, epochs)

    raw_w = raw_mi.model.coef_
    mpc_w = mpc_mi.model.coef_

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking multiple imputation result shape (MPC) on {alg_struct}", mpc_w.shape, list(raw_w.shape))
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre multiple imputation (MPC) on {alg_struct}", mpc_w.reveal(mpc), raw_w)
        
    print(f'CP{mpc.pid}:\tSequre multiple imputation on {"ring" if modulus.popcnt() == 1 else "field"} tests passed.\n')
    