import math

from numpy.create import array, zeros

from ..utils import assert_eq, assert_eq_approx

from sequre.types.multiparty_partition import MPP
from sequre.types.sharetensor import Sharetensor
from sequre.utils.io import write_ndarray, read_ndarray
from sequre.utils.utils import __rand_mat
from sequre.utils.param import *
from sequre.mpc.env import MPCEnv
from sequre.stdlib.learn.pca import random_pca


def test_pca[TP](mpc: MPCEnv[TP], modulus: TP):
    print(f'CP{mpc.pid}:\tTesting Sequre PCA on {"ring" if modulus.popcnt() == 1 else "field"} ... \n')

    rows_per_partition, cols = 8, 8
    partition_path = "tests/data/pca/partition.bin"

    if mpc.pid == 0:
        with open(partition_path, "wb") as f: write_ndarray(f, array(__rand_mat([rows_per_partition, cols], 3, TP=int)) - 1, binary=True)
    
    mpc.comms.sync_parties()
    partition = read_ndarray(open(partition_path), (rows_per_partition, cols), True, dtype=int)
    
    raw_data = [partition for _ in range(mpc.comms.number_of_parties - 1)].unfence()
    raw_data_mean = raw_data.sum(axis=0) / len(raw_data) / 2
    raw_data_std_inv = 1 / (raw_data_mean * (1 - raw_data_mean)).sqrt()
    raw_data_mean *= 2
    raw_mask_inv = zeros(raw_data.shape, dtype=int)

    top_components_count = 3
    oversampling_count = 3
    power_iterations_count = 0
    filtered_data_size = len(raw_data_mean)
    
    mpc_data = Sharetensor.enc(mpc, raw_data.tolist(), 0, modulus)
    mpc_data_mean = Sharetensor.enc(mpc, raw_data_mean.tolist(), 0, modulus)
    mpc_data_std_inv = Sharetensor.enc(mpc, raw_data_std_inv.tolist(), 0, modulus)
    mpc_mask_inv = Sharetensor.enc(mpc, raw_mask_inv.tolist(), 0, modulus)
    
    # mpp_data = MPP.collective_load(mpc, partition_path, rows=rows_per_partition, cols=cols, binary=True, dtype=int)
    
    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}: PCA test data for debugging:", raw_data), False)
    if mpc.pid > 0:
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking PCA data loading (MPC)", mpc_data.reveal(mpc), raw_data.astype(float).tolist())
        # assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking PCA data loading (MPP)", mpp_data.reveal(mpc), raw_data.tolist())

    mpc.randomness.reset_seed(-1, hash('global'))
    classic_pca_u, classic_pca_z = random_pca(
        mpc, raw_data, raw_data_mean, raw_data_std_inv,
        top_components_count, oversampling_count, power_iterations_count,
        raw_mask_inv, filtered_data_size)
    mpc.randomness.reset_seed(-1, hash('global'))
    mpc_pca_u, mpc_pca_z = random_pca(
        mpc, mpc_data, mpc_data_mean, mpc_data_std_inv,
        top_components_count, oversampling_count, power_iterations_count,
        mpc_mask_inv, filtered_data_size)
    # mpc.randomness.reset_seed(-1, hash('global'))
    # mpc_pca_u, mpc_pca_z = random_pca(
    #     mpc, mpc_data, mpc_data_mean, mpc_data_std_inv,
    #     top_components_count, oversampling_count, power_iterations_count,
    #     mpc_mask_inv, filtered_data_size)

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA U result shape (MPC)", mpc_pca_u.shape, list(classic_pca_u.shape))
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA Z result shape (MPC)", mpc_pca_z.shape, list(classic_pca_z.shape))
        # assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA result shape (MPP)", mpp_pca.shape, list(classic_pca_u.shape))
    else:
        # TODO: Wait for new ndarray version to compare to ndarray
        # assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA U (MPC)", mpc_pca_u.reveal(mpc), classic_pca_u.tolist())
        # assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA Z (MPC)", mpc_pca_z.reveal(mpc), classic_pca_z.tolist())
        # assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA U (MPP)", mpp_pca_u.reveal(mpc), classic_pca_u.tolist())
        # assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA Z (MPP)", mpp_pca_z.reveal(mpc), classic_pca_z.tolist())
        pass


    print(f'CP{mpc.pid}:\tSequre PCA on {"ring" if modulus.popcnt() == 1 else "field"} tests passed.\n')
    