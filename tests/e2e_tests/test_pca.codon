from numpy.create import array, zeros, zeros_like

from ..utils import random_ints, assert_eq, assert_eq_approx

from sequre.types.sharetensor import Sharetensor
from sequre.types.multiparty_partition import MPP
from sequre.mpc.env import MPCEnv
from sequre.stdlib.learn.pca import random_pca, random_pca_mpp


def test_pca[TP](mpc: MPCEnv[TP], modulus: TP):
    print(f'CP{mpc.pid}:\tTesting Sequre PCA on {"ring" if modulus.popcnt() == 1 else "field"} ... \n')

    rows_per_party = 8
    with mpc.randomness.seed_switch(-1):
        raw_data = array(random_ints(((mpc.comms.number_of_parties - 1) * rows_per_party, 8), upper_limit=2))    

    raw_data_mean = raw_data.sum(axis=0) / len(raw_data) / 2
    raw_data_std_inv = 1 / (raw_data_mean * (1 - raw_data_mean)).sqrt()
    raw_data_mean *= 2
    raw_miss = zeros(raw_data.shape, dtype=int)

    top_components_count = 3
    oversampling_count = 2
    power_iterations_count = 1
    filtered_data_size = len(raw_data_mean)
    
    mpc_data = Sharetensor.enc(mpc, raw_data, 0, modulus)
    mpc_data_mean = Sharetensor.enc(mpc, raw_data_mean, 0, modulus)
    mpc_data_std_inv = Sharetensor.enc(mpc, raw_data_std_inv, 0, modulus)
    mpc_miss = Sharetensor.enc(mpc, raw_miss, 0, modulus)
    
    local_data = zeros_like(raw_data) if mpc.pid == 0 else raw_data[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party]
    mpp_data = MPP(mpc, local_data)
    local_miss = zeros_like(raw_miss) if mpc.pid == 0 else raw_miss[(mpc.pid - 1) * rows_per_party:mpc.pid * rows_per_party]
    mpp_miss = MPP(mpc, local_miss)
    mpp_data_mean = raw_data_mean
    mpp_data_std_inv = raw_data_std_inv
    
    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}: PCA test data for debugging:", raw_data), False)
    if mpc.pid > 0:
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking PCA data loading (MPC)", mpc_data.reveal(mpc), raw_data.astype(float))
        assert_eq_approx(f"CP{mpc.pid}:\tSafe-checking PCA data loading (MPP)", mpp_data.reveal(mpc), raw_data)

    mpc.randomness.reset_seed(-1, hash('global'))
    classic_pca_u, classic_pca_z = random_pca(
        mpc, raw_data, raw_miss, raw_data_mean, raw_data_std_inv,
        top_components_count, oversampling_count, power_iterations_count, filtered_data_size)
    mpc.randomness.reset_seed(-1, hash('global'))
    mpc_pca_u, mpc_pca_z = random_pca(
        mpc, mpc_data, mpc_miss, mpc_data_mean, mpc_data_std_inv,
        top_components_count, oversampling_count, power_iterations_count, filtered_data_size)
    mpc.randomness.reset_seed(-1, hash('global'))
    mpp_pca_u, mpp_pca_z = random_pca_mpp(
        mpc, mpp_data, mpp_miss, mpp_data_mean, mpp_data_std_inv,
        top_components_count, oversampling_count, power_iterations_count, filtered_data_size)

    if mpc.pid == 0:
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA U result shape (MPC)", mpc_pca_u.shape, list(classic_pca_u.shape))
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA Z result shape (MPC)", mpc_pca_z.shape, list(classic_pca_z.shape))
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA U result shape (MPP)", mpp_pca_u.shape, classic_pca_u.shape)
        assert_eq(f"CP{mpc.pid}:\tSafe-checking PCA Z result shape (MPP)", mpp_pca_z.shape, classic_pca_z.shape)
    else:
        assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA U (MPC)", mpc_pca_u.reveal(mpc), classic_pca_u)
        assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA Z (MPC)", mpc_pca_z.reveal(mpc), classic_pca_z)
        assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA U (MPP)", mpp_pca_u.reveal(mpc), classic_pca_u, error=1.0)  # Checking only if the result is sane
        assert_eq_approx(f"CP{mpc.pid}:\tSequre PCA Z (MPP)", mpp_pca_z.reveal(mpc), classic_pca_z, error=1.0)  # Checking only if the result is sane

    print(f'CP{mpc.pid}:\tSequre PCA on {"ring" if modulus.popcnt() == 1 else "field"} tests passed.\n')
    