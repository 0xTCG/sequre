import time
from sequre.utils.param import NBIT_F


def assert_values(name, result, expected, silent_pass = False):
    assert result == expected, f'{name} failed! Result: {result}.\n\nExpected: {expected}'
    if not silent_pass: print(f'{name} passed.')


def assert_approx(name, result, expected, error: float = 0.018, silent_pass = False):
    # Scale error with the fractional size precision
    error += 2.0 / (2 ** NBIT_F)
    
    check: bool = ((expected - error) < result) and (result < (expected + error))
    assert check, f'{name} failed! Result: {result}.\n\nExpected: {expected}'
    if not silent_pass: print(f'{name} passed.')


def time_frame(mpc, func, name, modulus, *args):
    mpc.reset_stats()
    local_suffix = '_local' if mpc.local else ''
    with open(f'results/{"_".join(name.lower().split())}_results{local_suffix}.txt', 'w') as results_f, open(
            f'results/{"_".join(name.lower().split())}_stats_CP{mpc.pid}{local_suffix}.txt', 'w') as stats_f:
        s = time.time()
        mpc.reset_stats()
        results = func(mpc, modulus, *args)
        e = time.time()
        
        alg_structure = 'Ring' if modulus.popcnt() == 1 else 'Field'
        runtime_message = f'\n{name} done in {e - s}s at CP{mpc.pid}\n'
        stats_f.write(f'{alg_structure} size: {modulus}')
        stats_f.write(runtime_message)
        mpc.print_stats(stats_f)
        print(runtime_message)
        
        results_revealed = results.print(mpc)
        if mpc.pid == 2:
            for row in results_revealed: results_f.write(f'{row}\n')
    mpc.comms.sync_parties()
