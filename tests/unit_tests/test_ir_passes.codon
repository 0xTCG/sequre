from sequre import mpc_poly_opt
from sequre.mpc.env import MPCEnv
from sequre.types.shared_tensor import SharedTensor

from ..utils import assert_eq, assert_eq_approx, random_floats, random_ints


@mpc_poly_opt
def sequre_poly_foo(mpc, a, b, c):
    d = (a + b) * a
    e = d ** 2 * c
    f = e * c * b
    return f


def classic_poly_foo(a, b, c):
    # TODO: Check for types in mpc_poly_opt to enable running sequre_poly_foo on top of raw data
    d = (a + b) * a
    e = d ** 2 * c
    f = e * c * b
    return f


def test_mpc_poly_opt[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting MPC polynomial optimization pass on {alg_struct} ... \n')
    size = 1

    with mpc.randomness.seed_switch(-1):
        values_a = random_ints((size,))[0]
        values_b = random_ints((size,))[0]
        values_c = random_ints((size,))[0]
    
    stensor_a = SharedTensor.enc(mpc, values_a, 0, modulus)
    stensor_b = SharedTensor.enc(mpc, values_b, 0, modulus)
    stensor_c = SharedTensor.enc(mpc, values_c, 0, modulus)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 1 on {alg_struct}', stensor_a.print(mpc), values_a.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 2 on {alg_struct}', stensor_b.print(mpc), values_b.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 3 on {alg_struct}', stensor_c.print(mpc), values_c.to_float())

    mpc.arithmetic.reset_stats()
    classic_result = classic_poly_foo(values_a, values_b, values_c)
    sequre_result = sequre_poly_foo(mpc, stensor_a, stensor_b, stensor_c)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: correctness on {alg_struct}', sequre_result.print(mpc), classic_result.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: Beaver partitions count on {alg_struct}', mpc.arithmetic.partitions, 3)


def test_ir_passes[TP](mpc: MPCEnv[TP], modulus: TP):
    print(f'CP{mpc.pid}:\tTesting IR passes ... \n')

    test_mpc_poly_opt(mpc, modulus)
