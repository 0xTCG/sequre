from sequre import sequre, mpc_poly_opt, mhe_cipher_opt
from sequre.mpc.env import MPCEnv
from sequre.types.shared_tensor import SharedTensor
from sequre.types.cipher_tensor import CipherTensor
from sequre.lattiseq.ckks import Ciphertext, Plaintext

from ..utils import assert_eq, assert_eq_approx, random_floats, random_ints


@mpc_poly_opt
def sequre_poly_foo(mpc, a, b, c):
    d = (a + b) * a
    e = d ** 2 * c
    f = e * c * b
    return f


def classic_poly_foo(a, b, c):
    # TODO: Check for types in mpc_poly_opt to enable running sequre_poly_foo on top of raw data
    d = (a + b) * a
    e = d ** 2 * c
    f = e * c * b
    return f


def test_mpc_poly_opt[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting MPC polynomial optimization pass on {alg_struct} ... \n')
    size = 1

    with mpc.randomness.seed_switch(-1):
        values_a = random_ints((size,))[0]
        values_b = random_ints((size,))[0]
        values_c = random_ints((size,))[0]
    
    stensor_a = SharedTensor.enc(mpc, values_a, 0, modulus)
    stensor_b = SharedTensor.enc(mpc, values_b, 0, modulus)
    stensor_c = SharedTensor.enc(mpc, values_c, 0, modulus)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 1 on {alg_struct}', stensor_a.print(mpc), values_a.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 2 on {alg_struct}', stensor_b.print(mpc), values_b.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: safety-check 3 on {alg_struct}', stensor_c.print(mpc), values_c.to_float())

    mpc.arithmetic.reset_stats()
    classic_result = classic_poly_foo(values_a, values_b, values_c)
    sequre_result = sequre_poly_foo(mpc, stensor_a, stensor_b, stensor_c)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: correctness on {alg_struct}', sequre_result.print(mpc), classic_result.to_float())
        assert_eq_approx(f'CP{mpc.pid}:\tMPC polynomial optimization IR pass: Beaver partitions count on {alg_struct}', mpc.arithmetic.partitions, 3)


@sequre
@mhe_cipher_opt
def cipher_plain_foo(mpc, a, b, c, d):
    return a * c + a * d + b * c + b * d

def test_mhe_cipher_opt(mpc):
    print(f'CP{mpc.pid}:\tTesting MHE cipher-plain optimization pass ... \n')
    rows, cols = 4, 32

    with mpc.randomness.seed_switch(-1):
        values_a = random_floats((rows, cols))
        values_b = random_floats((rows, cols))
        values_c = random_floats((rows, cols))
        values_d = random_floats((rows, cols))
    
    ctensor_a = CipherTensor[Ciphertext].enc(mpc, values_a)
    ctensor_b = CipherTensor[Ciphertext].enc(mpc, values_b)
    ctensor_c = CipherTensor[Ciphertext].enc(mpc, values_c)
    ctensor_d = CipherTensor[Ciphertext].enc(mpc, values_d)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: safety-check 1', ctensor_a.reveal(mpc, T=float).tolist(), values_a)
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: safety-check 2', ctensor_b.reveal(mpc, T=float).tolist(), values_b)
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: safety-check 3', ctensor_c.reveal(mpc, T=float).tolist(), values_c)
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: safety-check 4', ctensor_d.reveal(mpc, T=float).tolist(), values_d)

    mpc.he.reset_stats()
    sequre_result = cipher_plain_foo(mpc, ctensor_a, ctensor_b, ctensor_c, ctensor_d)

    if mpc.pid:
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: correctness', sequre_result.reveal(mpc, T=float).tolist(), (values_a + values_b) * (values_c + values_d))
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: multiplications count', mpc.he.muls_count, 1)
        assert_eq_approx(f'CP{mpc.pid}:\tMHE cipher-plain optimization IR pass: additions count', mpc.he.adds_count, 2)


def test_ir_passes[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting IR passes on {alg_struct}... \n')

    test_mpc_poly_opt(mpc, modulus)
    test_mhe_cipher_opt(mpc)

    print(f'CP{mpc.pid}:\tIR passes on {alg_struct} passed.\n')
