import random

import sequre.lattiseq.ckks as ckks
import sequre.lattiseq.ring as ring
import sequre.lattiseq.ringqp as ringqp

from ..utils import assert_eq


def test_send_receive_poly(mpc):
    q = ring.new_poly(10, 10)
    p = ring.new_poly(10, 10)
    qp = ringqp.Poly(q=q, p=p)

    received_q = copy(q)
    received_qp = copy(qp)

    if mpc.pid == 1:
        mpc.prg.switch_seed(2)
        q.randomize(upper_bound=100)
        p.randomize(upper_bound=100)
        mpc.prg.restore_seed(2)
        
        mpc.comms.send_as_jar(q, 2)
        mpc.comms.send_as_jar(qp, 2)
        received_q = mpc.comms.receive_as_jar(2, ring.Poly)
        received_qp = mpc.comms.receive_as_jar(2, ringqp.Poly)
    elif mpc.pid == 2:
        mpc.prg.switch_seed(1)
        q.randomize(upper_bound=100)
        p.randomize(upper_bound=100)
        mpc.prg.restore_seed(1)
        
        received_q = mpc.comms.receive_as_jar(1, ring.Poly)
        received_qp = mpc.comms.receive_as_jar(1, ringqp.Poly)
        mpc.comms.send_as_jar(q, 1)
        mpc.comms.send_as_jar(qp, 1)

    assert_eq(f"CP{mpc.pid}:\tMHE send/receive poly", q, received_q)
    assert_eq(f"CP{mpc.pid}:\tMHE send/receive QP poly", qp, received_qp)


def test_send_receive_ciphertext(mpc):
    ct = ckks.Ciphertext()
    received_ct = ckks.Ciphertext()

    if mpc.pid == 1:
        mpc.prg.switch_seed(2)
        values = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots())]
        mpc.prg.restore_seed(2)
        
        ct = mpc.he.encrypt_vector(values)[0][0]
        mpc.comms.send_as_jar(ct, 2)
        received_ct = mpc.comms.receive_as_jar(2, ckks.Ciphertext)
    elif mpc.pid == 2:
        mpc.prg.switch_seed(1)
        values = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots())]
        mpc.prg.restore_seed(1)
        
        ct = mpc.he.encrypt_vector(values)[0][0]
        received_ct = mpc.comms.receive_as_jar(1, ckks.Ciphertext)
        mpc.comms.send_as_jar(ct, 1)

    assert_eq(f"CP{mpc.pid}:\tMHE send/receive ciphertext", ct, received_ct)


def test_collective_decryption(mpc):
    mpc.prg.switch_seed(-1)
    values = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    mpc.prg.restore_seed(-1)
    
    precision_stats = mpc.he.precision_stats(
        result=mpc.he.decode_vector(
            mpc.he.crypto_params,
            [mpc.he.collective_decrypt(
                mpc.he.crypto_params,
                mpc.he.encrypt_vector(values)[0][0],
                mpc.he.comms.hub_pid)],
            DTP=float),
        expected=values)
    
    assert_eq(f"CP{mpc.pid}:\tMHE collective decryption", precision_stats.min_precision.l2 > 22, True)


def test_addition(mpc):
    mpc.prg.switch_seed(-1)
    values_1 = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    values_2 = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    mpc.prg.restore_seed(-1)

    ciphertext_1 = mpc.he.encrypt_vector(values_1)
    ciphertext_2= mpc.he.encrypt_vector(values_2)
    ciphertext_sum = mpc.he.add(ciphertext_1, ciphertext_2)

    precision_stats = mpc.he.precision_stats(
        params=mpc.he.crypto_params.params,
        result=mpc.he.decode_vector(
            mpc.he.collective_decrypt(
                mpc.he.crypto_params,
                ciphertext_sum,
                mpc.he.comms.hub_pid)),
        expected=values_1 + values_2)
    
    assert_eq(f"CP{mpc.pid}:\tMHE addition", precision_stats.min_precision.l2 > 22, True)


def test_multiplication(mpc):
    mpc.prg.switch_seed(-1)
    values_1 = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    values_2 = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    mpc.prg.restore_seed(-1)

    ciphertext_1 = mpc.he.encrypt_vector(values_1)
    ciphertext_2= mpc.he.encrypt_vector(values_2)
    ciphertext_product = mpc.he.mult(ciphertext_1, ciphertext_2)

    precision_stats = mpc.he.precision_stats(
        params=mpc.he.crypto_params.params,
        result=mpc.he.decode_vector(mpc.he.collective_decrypt(mpc.he.crypto_params, ciphertext_product, mpc.he.comms.hub_pid)),
        expected=values_1 * values_2)
    
    assert_eq(f"CP{mpc.pid}:\tMHE multiplication level", ciphertext_product.level(), ciphertext_1.level() - 1)
    assert_eq(f"CP{mpc.pid}:\tMHE multiplication result", precision_stats.min_precision.l2 > 22, True)


def test_arithmetics(mpc):
    test_addition(mpc)
    test_multiplication(mpc)


def test_collective_bootstrapping(mpc):
    mpc.prg.switch_seed(-1)
    values = [7 * random.random() for _ in range(mpc.he.crypto_params.params.slots() * 2)]
    mpc.prg.restore_seed(-1)

    ciphertext = mpc.he.encrypt_vector(values)
    ciphertext_squared = mpc.he.mult(ciphertext, ciphertext)
    ciphertext_bootstrapped = mpc.collective_bootstrap(ciphertext_squared)

    precision_stats = mpc.he.precision_stats(
        params=mpc.he.crypto_params.params,
        result=mpc.he.decode_vector(mpc.he.decrypt_vector(ciphertext_bootstrapped)),
        expected=values ** 2)
    
    boot_lvl = ciphertext_bootstrapped.level()
    mult_level = ciphertext_squared.level()
    initial_lvl = ciphertext.level()

    assert_eq(f"CP{mpc.pid}:\tMHE collective bootstrapping level", (boot_lvl - mult_level) * boot_lvl, initial_lvl)
    assert_eq(f"CP{mpc.pid}:\tMHE collective bootstrapping result", precision_stats.min_precision.l2 > 22, True)


def test_mhe(mpc):
    print(f'CP{mpc.pid}:\tTesting MHE ... \n')

    test_send_receive_poly(mpc)

    ckks_params = ckks.new_parameters_from_literal(ckks.PN14QP438)
    mpc.he.set_params(ckks_params)
    mpc.he.collective_init(ckks_params, u64(256))
    test_send_receive_ciphertext(mpc)
    test_collective_decryption(mpc)
    # test_arithmetics(mpc)
    # test_collective_bootstrapping(mpc)

    print(f'CP{mpc.pid}:\tMHE tests passed.\n')
