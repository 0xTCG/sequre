from numpy.create import array, ones

from sequre import sequre
from sequre.mpc.env import MPCEnv
from sequre.types.multiparty_partition import MPP
from sequre.types.cipher_tensor import CipherTensor
from sequre.utils.io import write_ndarray
from sequre.utils.utils import __rand_mat

from sequre.types.internal import Internal

from ..utils import assert_eq


def test_transpose(mpc, mpp_a, raw_a):
    mhe_t = mpp_a.T.T
    assert_eq("MPP lazy transpose", mhe_t.reveal(mpc), raw_a)
    
    mhe_t = mpp_a.T
    assert_eq("MPP actual transpose", mhe_t.reveal(mpc), raw_a.T)


def test_mpc_switching(mpc, mpp_a, raw_a):
    shared_tensor_a = mpp_a.to_mpc(mpc)
    assert_eq("MPP MPP -> MPC switch", shared_tensor_a.reveal(mpc).share.to_int(), raw_a.tolist())

    mpp_a = shared_tensor_a.to_mpp(mpc, mpp_a._ratios, S=mpp_a.S, dtype=mpp_a.dtype)
    assert_eq("MPP MPC -> MPP switch", mpp_a.reveal(mpc), raw_a)


@sequre
def test_elem_wise_operations(mpc, mpp_a, mpp_b, raw_a, raw_b):
    mpp_add = mpp_a + mpp_b
    assert_eq("MPP addition", mpp_add.reveal(mpc), raw_a + raw_b)

    _ones = ones((mpp_a._ratios.sum(), raw_a.shape[1]), dtype=int)
    mpp_public_add = mpp_a + _ones
    assert_eq("MPP public addtition", mpp_public_add.reveal(mpc), raw_a + _ones)

    mpp_sub = mpp_a - mpp_b
    assert_eq("MPP subtraction", mpp_sub.reveal(mpc), raw_a + raw_b)

    mpp_mul = mpp_a * mpp_b
    assert_eq("MPP multiplication", mpp_mul.reveal(mpc), raw_a * raw_b)


@sequre
def test_matmul_operations(mpc, mpp_a, mpp_b, raw_a, raw_b):
    mpp_matmul = mpp_a @ mpp_b.T
    raw_matmul = raw_a @ raw_b.T
    assert_eq("MPP matrix multiplication 1", mpp_matmul.reveal(mpc), raw_matmul)

    mpp_matmul = mpp_a.T @ mpp_b
    assert_eq("MPP matrix multiplication 2", mpp_matmul.reveal(mpc), raw_a.T @ raw_b)

    _ones = ones((mpp_a._ratios.sum(), raw_a.shape[1]), dtype=int).T
    mpp_public_matmul = mpp_a @ _ones
    assert_eq("MPP matrix public multiplication", mpp_public_matmul.reveal(mpc), raw_a @ _ones)

    mpp_matmul.unify_partition(mpc)
    ct_matmul = mpp_matmul._encryption_unified
    ct_matmul_squared = ct_matmul @ raw_matmul
    assert_eq("CipherTensor matrix multiplication public", ct_matmul_squared.reveal(mpc, T=int), raw_matmul @ raw_matmul.T)

    ct_matmul_squared = ct_matmul @ ct_matmul
    assert_eq("CipherTensor matrix multiplication", ct_matmul_squared.reveal(mpc, T=int), raw_matmul @ raw_matmul.T)


def test_sequre_mhe[TP](mpc: MPCEnv[TP], modulus: TP):
    print(f'CP{mpc.pid}:\tTesting Sequre MHE stdlib ... \n')
    mpc.he.default_setup()
    params = mpc.he.crypto_params.params
    rows, cols = 4, params.slots()

    with mpc.randomness.seed_switch(-1):
        raw_a = array(__rand_mat([rows, cols], 100, TP=int))
        raw_b = array(__rand_mat([rows, cols], 100, TP=int))
    if mpc.pid == 1:
        with open("tests/data/mhe/a_partition.bin", "wb") as f: write_ndarray(f, raw_a, binary=True)
        mpp_a = MPP.collective_load(mpc, "tests/data/mhe/a_partition.bin", rows=rows, cols=cols, binary=True, modulus=modulus, dtype=int)
    if mpc.pid == 2:
        with open("tests/data/mhe/b_partition.bin", "wb") as f: write_ndarray(f, raw_b, binary=True)
        mpp_b = MPP.collective_load(mpc, "tests/data/mhe/b_partition.bin", rows=rows, cols=cols, binary=True, modulus=modulus, dtype=int)

    if mpc.pid > 0:
        assert_eq("MPP load/aggreate/decrypt 1", raw_a, mpp_a.reveal(mpc))
        assert_eq("MPP load/aggreate/decrypt 2", raw_b, mpp_b.reveal(mpc))

        test_transpose(mpc, mpp_a, raw_a)
        test_mpc_switching(mpc, mpp_a, raw_a)
        test_elem_wise_operations(mpc, mpp_a, mpp_b, raw_a, raw_b)
        test_matmul_operations(mpc, mpp_a, mpp_b, raw_a, raw_b)
