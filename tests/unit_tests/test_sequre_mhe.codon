from numpy.create import array, ones

import secure_operator
import sequre.lattiseq.ckks as ckks

from sequre import sequre
from sequre.mpc.env import MPCEnv
from sequre.types.multiparty_partition import MPP
from sequre.types.cipher_tensor import CipherTensor
from sequre.utils.io import write_ndarray, read_ndarray
from sequre.utils.utils import __rand_mat, zeros
from sequre.utils.param import FIELD_SIZE, RING_SIZE

from ..utils import assert_eq, random_floats


def test_ciphertensor_send_receive(mpc):
    if mpc.pid == 1:
        mpc.randomness.switch_seed(2)
        values = random_floats((mpc.he.crypto_params.params.slots(),))
        mpc.randomness.restore_seed(2)

        ct = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        mpc.comms.send_as_jar(ct, 2)
        received_ct = mpc.comms.receive_as_jar(2, CipherTensor[ckks.Ciphertext])
    elif mpc.pid == 2:
        mpc.randomness.switch_seed(1)
        values = random_floats((mpc.he.crypto_params.params.slots(),))
        mpc.randomness.restore_seed(1)
        
        ct = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        received_ct = mpc.comms.receive_as_jar(1, CipherTensor[ckks.Ciphertext])
        mpc.comms.send_as_jar(ct, 1)

    if mpc.pid: assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor send/receive", ct, received_ct)


def test_ciphertensor_encrypt_reveal(mpc, size):
    with mpc.randomness.seed_switch(-1):
        values = random_floats((size,))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).flatten().tolist(),
            expected=values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor encrypt/reveal of size {size}", precision_stats.min_precision.l2 > 10, True)
    

def test_ciphertensor_append(mpc):
    rows, cols = 4, mpc.he.crypto_params.params.slots() * 3
    with mpc.randomness.seed_switch(-1):
        values = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        encrypted_values.append(CipherTensor.zeros(mpc, [cols]))
        values.append(zeros((cols,), TP=float))

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).tolist(),
            expected=values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor append", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_pop(mpc):
    rows, cols = 4, mpc.he.crypto_params.params.slots() * 3
    with mpc.randomness.seed_switch(-1):
        values = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        encrypted_values.pop()
        values.pop()

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).tolist(),
            expected=values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor pop", precision_stats.min_precision.l2 > 10, True)
  

def test_ciphertensor_extend(mpc):
    rows, cols = 4, mpc.he.crypto_params.params.slots() * 3
    with mpc.randomness.seed_switch(-1):
        values = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        encrypted_zeros = CipherTensor.zeros(mpc, [rows, cols])
        encrypted_values.extend(encrypted_zeros)
        values.extend(zeros((rows, cols), TP=float))

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).tolist(),
            expected=values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor matrix extend", precision_stats.min_precision.l2 > 10, True)

        
    with mpc.randomness.seed_switch(-1):
        values_vec = random_floats((cols,))
        
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values_vec)
        encrypted_values.extend(CipherTensor.zeros(mpc, [cols]))
        values_vec.extend(zeros((cols,), TP=float))

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).flatten().tolist(),
            expected=values_vec)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor vector extend", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_rotation(mpc):
    slots = mpc.he.crypto_params.params.slots()
    number_of_ciphers = 3
    rotation_step = 3
    cols = slots * number_of_ciphers
    with mpc.randomness.seed_switch(-1):
        values = random_floats((cols,))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        rotated_encrypted_values = encrypted_values.rotate(mpc, rotation_step)
        rotated_values = values[:slots].rotate(rotation_step)
        for i in range(1, number_of_ciphers):
            rotated_values.extend(values[i * slots:(i + 1) * slots].rotate(rotation_step))

        precision_stats = mpc.he.precision_stats(
            result=rotated_encrypted_values.reveal(mpc, T=float).flatten().tolist(),
            expected=rotated_values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor rotation", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_shift(mpc, cols):
    slots = mpc.he.crypto_params.params.slots()
    rotation_step = 3
    with mpc.randomness.seed_switch(-1):
        values = random_floats((cols,))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        rotated_encrypted_values_cohort = encrypted_values.shift(mpc, rotation_step)
        shifted_values = values.shift_like_cipher(rotation_step, slots, cols)
        result = rotated_encrypted_values_cohort.reveal(mpc, T=float).flatten().tolist()

        precision_stats = mpc.he.precision_stats(
            result=result,
            expected=shifted_values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor shift of vector length {cols}", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_resize(mpc, size, new_size):
    with mpc.randomness.seed_switch(-1):
        values = random_floats((size,))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.resize(mpc, [new_size]).reveal(mpc, T=float).flatten().tolist(),
            expected=values.resize([new_size]))
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor resize vector of length {size} to length {new_size}", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_concat(mpc, rows, cols):
    with mpc.randomness.seed_switch(-1):
        values = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        encrypted_values = encrypted_values.concat(mpc, CipherTensor.zeros(mpc, [rows, cols]), axis=0)
        values.extend(zeros((rows, cols), TP=float))

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).tolist(),
            expected=values)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor concat axis 0 for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 10, True)

    with mpc.randomness.seed_switch(-1):
        values = random_floats((rows, cols))
        
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        encrypted_values = encrypted_values.concat(mpc, CipherTensor.zeros(mpc, [rows, cols]), axis=1)

        precision_stats = mpc.he.precision_stats(
            result=encrypted_values.reveal(mpc, T=float).tolist(),
            expected=values.pad(rows, cols * 2))
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor concat axis 1 for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 10, True)


def test_ciphertensor_vector_operations(mpc):
    test_ciphertensor_append(mpc)
    test_ciphertensor_pop(mpc)
    test_ciphertensor_extend(mpc)
    test_ciphertensor_rotation(mpc)
    test_ciphertensor_shift(mpc, 32)
    test_ciphertensor_shift(mpc, mpc.he.crypto_params.params.slots() * 3)
    test_ciphertensor_concat(mpc, 4, 32)
    test_ciphertensor_concat(mpc, 4, mpc.he.crypto_params.params.slots() * 3)
    test_ciphertensor_resize(mpc, 32, 16)
    test_ciphertensor_resize(mpc, 32, 64)
    test_ciphertensor_resize(mpc, mpc.he.crypto_params.params.slots(), mpc.he.crypto_params.params.slots())
    test_ciphertensor_resize(mpc, mpc.he.crypto_params.params.slots() + 32, 32)


def test_ciphertensor_binary_operation(mpc, op, rows, cols, msg):
    with mpc.randomness.seed_switch(-1):
        values_1 = random_floats((rows, cols))
        values_2 = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values_1 = CipherTensor[ckks.Ciphertext].enc(mpc, values_1)
        encrypted_values_2 = CipherTensor[ckks.Ciphertext].enc(mpc, values_2)

        result = op(mpc, encrypted_values_1, encrypted_values_2)
        precision_stats = mpc.he.precision_stats(
            result=result.reveal(mpc, T=float).tolist(),
            expected=op(mpc, values_1, values_2))
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor {msg} for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 9, True)


def test_ciphertensor_reduce_add(mpc, cols):
    with mpc.randomness.seed_switch(-1):
        values = random_floats((cols,))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values)
        reduced_encrypted_values = encrypted_values.reduce_add(mpc)
        reduced_value = values.sum()

        precision_stats = mpc.he.precision_stats(
            result=reduced_encrypted_values.reveal(mpc, T=float).flatten().tolist(),
            expected=[reduced_value for _ in range(cols)])
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor addition reduction for vector of size {cols}", precision_stats.min_precision.l2 > 10, True)


@sequre
def test_ciphertensor_reversed_matrix_multiplication(mpc, rows, cols):
    with mpc.randomness.seed_switch(-1):
        values_1 = random_floats((rows, cols))
        values_2 = random_floats((cols, rows))
    
    if mpc.pid > 0:
        encrypted_values = CipherTensor[ckks.Ciphertext].enc(mpc, values_1)

        result = array(values_2) @ encrypted_values
        precision_stats = mpc.he.precision_stats(
            result=result.reveal(mpc, T=float).tolist(),
            expected=values_2 @ values_1)
        
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor reversed matmul for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 8, True)


@sequre
def test_ciphertensor_matrix_multiplication(mpc, rows, cols, only_general):
    with mpc.randomness.seed_switch(-1):
        values_1 = random_floats((rows, cols))
        values_2 = random_floats((rows, cols))
    
    if mpc.pid > 0:
        encrypted_values_1 = CipherTensor[ckks.Ciphertext].enc(mpc, values_1)
        encrypted_values_2 = CipherTensor[ckks.Ciphertext].enc(mpc, values_2)

        if not only_general:
            result_v1 = encrypted_values_1._matmul_v1(mpc, encrypted_values_2.T)        
            precision_stats = mpc.he.precision_stats(
                result=result_v1.reveal(mpc, T=float).tolist(),
                expected=values_1 @ values_2.transpose())
            assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor _matmul_v1 for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 5, True)

            encrypted_values_2_t = CipherTensor[ckks.Ciphertext].enc(mpc, values_2.transpose())
            result_v2 = encrypted_values_1._matmul_v2(mpc, encrypted_values_2_t)
            precision_stats = mpc.he.precision_stats(
                result=result_v2.reveal(mpc, T=float).tolist(),
                expected=values_1 @ values_2.transpose())
            assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor _matmul_v2 for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 5, True)
            
            result_v3 = encrypted_values_1._matmul_v3(mpc, array(values_2.transpose()))
            precision_stats = mpc.he.precision_stats(
                result=result_v3.reveal(mpc, T=float).tolist(),
                expected=values_1 @ values_2.transpose())
            assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor _matmul_v3 for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 4, True)

        result_general = encrypted_values_1 @ values_2.transpose()

        precision_stats = mpc.he.precision_stats(
            result=result_general.reveal(mpc, T=float).tolist(),
            expected=values_1 @ values_2.transpose())
        assert_eq(f"CP{mpc.pid}:\tSequre MHE ciphertensor matmul general for shape ({rows}, {cols})", precision_stats.min_precision.l2 > 4, True)


def test_ciphertensor_arithmetics(mpc):
    test_ciphertensor_binary_operation(mpc, secure_operator.add, 4, mpc.he.crypto_params.params.slots() * 3, "addition")
    test_ciphertensor_binary_operation(mpc, secure_operator.sub, 4, mpc.he.crypto_params.params.slots() * 3, "subtraction")
    test_ciphertensor_binary_operation(mpc, secure_operator.mul, 4, mpc.he.crypto_params.params.slots() * 3, "multiplication")
    test_ciphertensor_reduce_add(mpc, 32)
    test_ciphertensor_reduce_add(mpc, mpc.he.crypto_params.params.slots() // 2)
    test_ciphertensor_reduce_add(mpc, mpc.he.crypto_params.params.slots())
    test_ciphertensor_reduce_add(mpc, mpc.he.crypto_params.params.slots() + 32)
    test_ciphertensor_reversed_matrix_multiplication(mpc, 4, 32)
    test_ciphertensor_matrix_multiplication(mpc, 4, 32, False)
    # test_ciphertensor_matrix_multiplication(mpc, 8, 4, False)
    test_ciphertensor_matrix_multiplication(mpc, 4, mpc.he.crypto_params.params.slots(), True)


def test_ciphertensor(mpc):
    print(f'CP{mpc.pid}:\tTesting Sequre MHE CipherTensor ... \n')
    test_ciphertensor_send_receive(mpc)
    test_ciphertensor_encrypt_reveal(mpc, mpc.he.crypto_params.params.slots() * 3)
    test_ciphertensor_encrypt_reveal(mpc, 32)
    test_ciphertensor_encrypt_reveal(mpc, mpc.he.crypto_params.params.slots() + 32)
    test_ciphertensor_vector_operations(mpc)
    test_ciphertensor_arithmetics(mpc)
    

def test_mpp_transpose(mpc, mpp_a, raw_a):
    mhe_t = mpp_a.T.T
    if mpc.pid:
        assert_eq("MPP lazy transpose", mhe_t.reveal(mpc), raw_a)

    mhe_t = mpp_a.T
    if mpc.pid:
        assert_eq("MPP actual transpose", mhe_t.reveal(mpc), raw_a.T)


def test_mpp_mpc_switching(mpc, mpp_a, raw_a):
    shared_tensor_a = mpp_a.to_mpc(mpc)
    if mpc.pid:
        assert_eq("MPP -> MPC switch", shared_tensor_a.print(mpc).to_int(), raw_a.tolist())

    mpp_a = shared_tensor_a.to_mpp(mpc, mpp_a._ratios, S=mpp_a.S, dtype=mpp_a.dtype)
    if mpc.pid:
        assert_eq("MPC -> MPP switch", mpp_a.reveal(mpc), raw_a)


@sequre
def test_mpp_elem_wise_operations(mpc, mpp_a, mpp_b, raw_a, raw_b):
    mpp_add = mpp_a + mpp_b
    if mpc.pid:
        assert_eq("MPP addition", mpp_add.reveal(mpc), raw_a + raw_b)

    _ones = ones((mpp_a._ratios.sum(), raw_a.shape[1]), dtype=int)
    mpp_public_add = mpp_a + _ones
    if mpc.pid:
        assert_eq("MPP public addtition", mpp_public_add.reveal(mpc), raw_a + _ones)

    mpp_sub = mpp_a - mpp_b
    if mpc.pid:
        assert_eq("MPP subtraction", mpp_sub.reveal(mpc), raw_a + raw_b)

    mpp_mul = mpp_a * mpp_b
    if mpc.pid:
        assert_eq("MPP multiplication", mpp_mul.reveal(mpc), raw_a * raw_b)


@sequre
def test_mpp_matmul_operations(mpc, mpp_a, mpp_b, raw_a, raw_b):
    mpp_matmul = mpp_a @ mpp_b.T
    raw_matmul = raw_a @ raw_b.T
    if mpc.pid:
        assert_eq("MPP matrix multiplication 1", mpp_matmul.reveal(mpc), raw_matmul)

    mpp_matmul = mpp_a.T @ mpp_b
    if mpc.pid:
        assert_eq("MPP matrix multiplication 2", mpp_matmul.reveal(mpc), raw_a.T @ raw_b)

    _ones = ones((mpp_a._ratios.sum(), raw_a.shape[1]), dtype=int).T
    mpp_public_matmul = mpp_a @ _ones
    if mpc.pid:
        assert_eq("MPP matrix public multiplication", mpp_public_matmul.reveal(mpc), raw_a @ _ones)


@sequre
def test_mpp_transposed_operations(mpc, mpp_a, raw_a):
    mpp_dot = mpp_a @ mpp_a.T
    mpp_transposed_add = mpp_dot + mpp_dot.T
    dot = raw_a @ raw_a.T
    if mpc.pid:
        assert_eq("MPP transposed addition", mpp_transposed_add.reveal(mpc), dot + dot.T)


def test_mpp[TP](mpc: MPCEnv[TP], modulus: TP):
    mpc.comms.sync_parties()
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MHE MPP on {alg_struct}... \n')
    rows, cols = 4, 32

    a_partition_path = "tests/data/mhe/a_partition.bin"
    b_partition_path = "tests/data/mhe/b_partition.bin"

    if mpc.pid == 0:
        with open(a_partition_path, "wb") as f: write_ndarray(f, array(__rand_mat([rows, cols], 100, TP=int)), binary=True)
        with open(b_partition_path, "wb") as f: write_ndarray(f, array(__rand_mat([rows, cols], 100, TP=int)), binary=True)
    
    mpc.comms.sync_parties()
    
    a_partition = read_ndarray(open(a_partition_path), (rows, cols), True, dtype=int)
    b_partition = read_ndarray(open(b_partition_path), (rows, cols), True, dtype=int)

    raw_a = [a_partition for _ in range(mpc.comms.number_of_parties - 1)].unfence()
    raw_b = [b_partition for _ in range(mpc.comms.number_of_parties - 1)].unfence()

    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}: Printing MPP test data A for debugging:", raw_a), False)
    mpc.comms.sequential(lambda: print(f"CP{mpc.pid}: Printing MPP test data B for debugging:", raw_b), False)
    
    mpp_a = MPP.collective_load(mpc, a_partition_path, rows=rows, cols=cols, binary=True, modulus=modulus, dtype=int)
    mpp_b = MPP.collective_load(mpc, b_partition_path, rows=rows, cols=cols, binary=True, modulus=modulus, dtype=int)

    if mpc.pid:
        assert_eq("MPP load/collect/decrypt 1", mpp_a.reveal(mpc), raw_a)
        assert_eq("MPP load/collect/decrypt 2", mpp_b.reveal(mpc), raw_b)

    test_mpp_transpose(mpc, mpp_a, raw_a)
    test_mpp_mpc_switching(mpc, mpp_a, raw_a)
    test_mpp_elem_wise_operations(mpc, mpp_a, mpp_b, raw_a, raw_b)
    test_mpp_matmul_operations(mpc, mpp_a, mpp_b, raw_a, raw_b)
    test_mpp_transposed_operations(mpc, mpp_a, raw_a)


def test_sequre_mhe[TP](mpc: MPCEnv[TP]):
    print(f'CP{mpc.pid}:\tTesting Sequre MHE stdlib ... \n')
    
    test_ciphertensor(mpc)
    test_mpp(mpc, FIELD_SIZE, TP=TP)
    test_mpp(mpc, RING_SIZE, TP=TP)

    print(f'CP{mpc.pid}:\tSequre MHE stdlib passed \n')
