import math, random

from ..utils import assert_eq, assert_eq_approx

import sequre.lattiseq.ckks as ckks
import sequre.lattiseq.rlwe as rlwe

from sequre.lattiseq.stats import plot_precision_stats
from sequre.types.builtin import Complex


def test_encryption_decryption_for_values(values, plaintext, params, encoder, encryptor, decryptor):
    print('Encoding values ...')
    encoder.encode(values, plaintext, params.log_slots)

    print('Encrypting values ...')
    ciphertext = encryptor.encrypt_new(plaintext)

    print('Evaluating precision ...')
    precision_stats = plot_precision_stats(params, ciphertext, values, decryptor, encoder)
    
    assert_eq("Homomorphic encryption/decryption", precision_stats.min_precision.l2 > 22, True)


def test_encryp_decrypt(params):
    print('Initializing HE encoder ...')
    encoder = ckks.new_encoder_complex(params)
    
    print('Initializing HE keygen ...')
    kgen = ckks.new_key_generator(params)
    
    print('Generating secret ...')
    sk = kgen.gen_secret_key()
    
    print('Initializing HE encryptor ...')
    encryptor = ckks.new_encryptor(params, sk)
    
    print('Initializing HE decryptor ...')
    decryptor = ckks.new_decryptor(params, sk)
    
    print('Initializing HE plaintext ...')
    plaintext = ckks.new_plaintext(params, params.max_level(), params.default_scale / 16)

    test_encryption_decryption_for_values(
        values=[Complex(2 * math.pi, 0) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(2 * math.pi, math.pi) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(float(i % 10), 0) for i in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(7 * random.random(), 7 * random.random()) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)


def test_addition(evaluator):
    raise NotImplementedError()


def test_subtraction(evaluator):
    raise NotImplementedError()


def test_negation(evaluator):
    raise NotImplementedError()


def test_multiplication(evaluator):
    raise NotImplementedError()


def test_rotation(evaluator):
    raise NotImplementedError()


def test_evaluator(params):
    print('Initializing HE keygen ...')
    kgen = ckks.new_key_generator(params)
    
    print('Generating secret ...')
    sk = kgen.gen_secret_key()
    
    print('Generating relinearization key ...')
    rlk = kgen.gen_relinearization_key(sk, 1)
    
    print('Initializing evaluator ...')
    # evaluator = ckks.new_evaluator(params, rlwe.EvaluationKey(rlk=rlk))
    
    # test_addition(evaluator)
    # test_subtraction(evaluator)
    # test_negation(evaluator)
    # test_multiplication(evaluator)
    # test_rotation(evaluator)


def test_lattiseq():
    print('Testing Lattiseq ...')
    # Schemes parameters are created from scratch
    params = ckks.new_parameters_from_literal(
        ckks.ParametersLiteral(
            logn=14,
            logq=[55, 40, 40, 40, 40, 40, 40, 40],
            logp=[45, 45],
            log_slots=13,
            default_scale=float(1 << 40)))

    test_encryp_decrypt(params)
    # test_evaluator(params)


def test_he():
    print('Testing HE ...')
    test_lattiseq()
