import math, random

from ..utils import assert_eq, assert_eq_approx

import sequre.lattiseq.ckks as ckks
import sequre.lattiseq.rlwe as rlwe

from sequre.lattiseq.stats import plot_precision_stats
from sequre.types.builtin import Complex


def test_encryption_decryption_for_values(values, plaintext, params, encoder, encryptor, decryptor):
    print('Encoding values ...')
    encoder.encode(values, plaintext, params.log_slots)

    print('Encrypting values ...')
    ciphertext = encryptor.encrypt_new(plaintext)

    print('Evaluating precision ...')
    precision_stats = plot_precision_stats(params, ciphertext, values, decryptor, encoder)
    
    assert_eq("Homomorphic encryption/decryption", precision_stats.min_precision.l2 > 22, True)


def test_encryp_decrypt(params, encoder, encryptor, decryptor):
    print('Initializing HE plaintext ...')
    plaintext = ckks.new_plaintext(params, params.max_level(), params.default_scale / 16)

    test_encryption_decryption_for_values(
        values=[Complex(2 * math.pi, 0) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(2 * math.pi, math.pi) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(float(i % 10), 0) for i in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)
    
    test_encryption_decryption_for_values(
        values=[Complex(7 * random.random(), 7 * random.random()) for _ in range(params.slots())],
        plaintext=plaintext,
        params=params,
        encoder=encoder,
        encryptor=encryptor,
        decryptor=decryptor)


def test_negation(params, encoder, encryptor, decryptor, evaluator):
    elem = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    expected_negation = [Complex(-e.r, -e.i) for  e in elem]
    
    print('Initializing HE plaintext for negation ...')
    plaintext = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for negation ...')
    encoder.encode(elem, plaintext, params.log_slots)

    print('Encrypting values for negation ...')
    ciphertext = encryptor.encrypt_new(plaintext)

    print('Evaluating ciphertext negation ...')
    ciphertext_negation = evaluator.neg_new(ciphertext)

    print('Evaluating precision for negation ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_negation, expected_negation, decryptor, encoder)
    
    assert_eq(
        "Homomorphic negation",
        precision_stats.min_precision.l2 > 22,
        True)


def test_addition(params, encoder, encryptor, decryptor, evaluator):
    addend_1 = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    addend_2 = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    expected_sum = [e_1 + e_2 for e_1, e_2 in zip(addend_1, addend_2)]
    
    print('Initializing HE plaintext for addition ...')
    plaintext_1 = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)
    plaintext_2 = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for addition ...')
    encoder.encode(addend_1, plaintext_1, params.log_slots)
    encoder.encode(addend_2, plaintext_2, params.log_slots)

    print('Encrypting values for addition ...')
    ciphertext_1 = encryptor.encrypt_new(plaintext_1)
    ciphertext_2 = encryptor.encrypt_new(plaintext_2)

    print('Evaluating ciphertext addition ...')
    ciphertext_sum = evaluator.add_new(ciphertext_1, ciphertext_2)

    print('Evaluating precision for addition ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_sum, expected_sum, decryptor, encoder)
    
    assert_eq(
        "Homomorphic addition",
        precision_stats.min_precision.l2 > 21,
        True)


def test_subtraction(params, encoder, encryptor, decryptor, evaluator):
    minuend = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    subtrahend = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    expected_diff = [e_1 - e_2 for e_1, e_2 in zip(minuend, subtrahend)]
    
    print('Initializing HE plaintext for subtraction ...')
    plaintext_minuend = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)
    plaintext_subtrahend = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for subtraction ...')
    encoder.encode(minuend, plaintext_minuend, params.log_slots)
    encoder.encode(subtrahend, plaintext_subtrahend, params.log_slots)

    print('Encrypting values for subtraction ...')
    ciphertext_minuend = encryptor.encrypt_new(plaintext_minuend)
    ciphertext_subtrahend = encryptor.encrypt_new(plaintext_subtrahend)

    print('Evaluating ciphertext subtraction ...')
    ciphertext_diff = evaluator.sub_new(ciphertext_minuend, ciphertext_subtrahend)

    print('Evaluating precision for subtraction ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_diff, expected_diff, decryptor, encoder)
    
    assert_eq(
        "Homomorphic subtraction",
        precision_stats.min_precision.l2 > 21,
        True)


def test_multiplication_by_i(params, encoder, encryptor, decryptor, evaluator):
    factor = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    expected_product = [e * Complex(0, 1) for  e in factor]
    
    print('Initializing HE plaintext for multiplication by i ...')
    plaintext = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for multiplication by i ...')
    encoder.encode(factor, plaintext, params.log_slots)

    print('Encrypting values for multiplication by i ...')
    ciphertext = encryptor.encrypt_new(plaintext)

    print('Evaluating ciphertext multiplication by i ...')
    ciphertext_prod = evaluator.mult_by_i_new(ciphertext)

    print('Evaluating precision for multiplication by i ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_prod, expected_product, decryptor, encoder)
    
    assert_eq(
        "Homomorphic multiplication by i",
        precision_stats.min_precision.l2 > 22,
        True)


def test_ciphertext_multiplication(params, encoder, encryptor, decryptor, evaluator):
    factor_1 = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    factor_2 = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    expected_prod = [e_1 * e_2 for e_1, e_2 in zip(factor_1, factor_2)]
    
    print('Initializing HE plaintext for ciphertext multiplication ...')
    plaintext_1 = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)
    plaintext_2 = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for ciphertext multiplication ...')
    encoder.encode(factor_1, plaintext_1, params.log_slots)
    encoder.encode(factor_2, plaintext_2, params.log_slots)

    print('Encrypting values for ciphertext multiplication ...')
    ciphertext_1 = encryptor.encrypt_new(plaintext_1)
    ciphertext_2 = encryptor.encrypt_new(plaintext_2)

    print('Evaluating ciphertext ciphertext multiplication w/o relinearization ...')
    ciphertext_prod = evaluator.mult_new(ciphertext_1, ciphertext_2)
    print('Evaluating ciphertext ciphertext multiplication w/ relinearization ...')
    ciphertext_prod_relin = evaluator.mult_relin_new(ciphertext_1, ciphertext_2)

    print('Evaluating precision for ciphertext multiplication w/o relinearization ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_prod, expected_prod, decryptor, encoder)
    print('Evaluating precision for ciphertext multiplication w/ relinearization ...')
    precision_stats_relin = plot_precision_stats(
        params, ciphertext_prod_relin, expected_prod, decryptor, encoder)
    
    assert_eq(
        "Homomorphic ciphertext multiplication w/o relinearization",
        precision_stats.min_precision.l2 > 19,
        True)
    
    assert_eq(
        "Homomorphic ciphertext multiplication w/ relinearization",
        precision_stats_relin.min_precision.l2 > 19,
        True)


def test_multiplication(params, encoder, encryptor, decryptor, evaluator):
    test_multiplication_by_i(params, encoder, encryptor, decryptor, evaluator)
    test_ciphertext_multiplication(params, encoder, encryptor, decryptor, evaluator)


def test_rotation(params, encoder, encryptor, decryptor, evaluator):
    elem = [
        Complex(7 * random.random(), 7 * random.random())
        for _ in range(params.slots())]
    k = random.randint(0, len(elem))
    expected_rotation = elem[k:]
    expected_rotation.extend(elem[:k])
    
    print('Initializing HE plaintext for rotation ...')
    plaintext = ckks.new_plaintext(
        params, params.max_level(), params.default_scale / 16)

    print('Encoding values for rotation ...')
    encoder.encode(elem, plaintext, params.log_slots)

    print('Encrypting values for rotation ...')
    ciphertext = encryptor.encrypt_new(plaintext)

    print('Evaluating ciphertext rotation ...')
    ciphertext_rotation = evaluator.rotate_new(ciphertext, k)

    print('Evaluating precision for rotation ...')
    precision_stats = plot_precision_stats(
        params, ciphertext_rotation, expected_rotation, decryptor, encoder)
    
    assert_eq(
        "Homomorphic rotation",
        precision_stats.min_precision.l2 > 22,
        True)


def test_evaluator(params, encoder, encryptor, decryptor, evaluator):
    test_negation(params, encoder, encryptor, decryptor, evaluator)
    test_addition(params, encoder, encryptor, decryptor, evaluator)
    test_subtraction(params, encoder, encryptor, decryptor, evaluator)
    test_multiplication(params, encoder, encryptor, decryptor, evaluator)
    # test_rotation(params, encoder, encryptor, decryptor, evaluator)


def test_lattiseq():
    print('Testing Lattiseq ...')
    # Schemes parameters are created from scratch
    params = ckks.new_parameters_from_literal(
        ckks.ParametersLiteral(
            logn=14,
            logq=[55, 40, 40, 40, 40, 40, 40, 40],
            logp=[45, 45],
            log_slots=13,
            default_scale=float(1 << 40)))
    
    print('Initializing HE encoder ...')
    encoder = ckks.new_encoder_complex(params)
    
    print('Initializing HE keygen ...')
    kgen = ckks.new_key_generator(params)
    
    print('Generating secret ...')
    sk = kgen.gen_secret_key()

    print('Initializing HE encryptor ...')
    encryptor = ckks.new_encryptor(params, sk)
    
    print('Initializing HE decryptor ...')
    decryptor = ckks.new_decryptor(params, sk)

    print('Generating relinearization key ...')
    rlk = kgen.gen_relinearization_key(sk, 1)
    
    print('Initializing evaluator ...')
    evaluator = ckks.new_evaluator(params, rlwe.EvaluationKey(rlk=rlk))

    test_encryp_decrypt(params, encoder, encryptor, decryptor)
    test_evaluator(params, encoder, encryptor, decryptor, evaluator)
    
    print('Lattiseq tests passed.\n')


def test_he():
    print('Testing HE ... \n')
    
    test_lattiseq()

    print('HE tests passed.\n')
