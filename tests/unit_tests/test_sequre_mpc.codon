import prg

from numpy.create import array

from ..utils import assert_eq_approx, assert_eq, random_floats

from sequre.utils.param import *
from sequre.types.utils import double_to_fp
from sequre.utils.utils import zeros_vec
from sequre.mpc.env import MPCEnv
from sequre.stdlib.lin_alg import *
from sequre.stdlib.fp import *
from sequre.stdlib.protocols import bit_add as bit_add_protocol, bit_decomposition as bit_decomposition_protocol
from sequre.types.internal import Internal as sq
from sequre.types.shared_tensor import SharedTensor
from sequre.attributes import sequre


def test_sequre_bitwise_operations[TP](mpc, modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC bitwise operations on {alg_struct} ... \n')
    
    a_bits = [TP(1), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]
    b_bits = [TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]
    shared_a_bits = mpc.comms.share_from_trusted_dealer([a_bits], modulus)
    shared_b_bits = mpc.comms.share_from_trusted_dealer([b_bits], modulus)
    SharedTensor_a_bits = SharedTensor(shared_a_bits, modulus)
    SharedTensor_b_bits = SharedTensor(shared_b_bits, modulus)
    SharedTensor_b_bits_public = SharedTensor([b_bits], modulus)
    SharedTensor_b_bits_public.public = True
    
    bit_addition = bit_add_protocol(mpc, SharedTensor_a_bits, SharedTensor_b_bits).share
    revealed_bit_add_results = mpc.comms.reveal(bit_addition, modulus)
    if mpc.pid != 0:
        assert_eq(
            'Sequre bit add private',
            revealed_bit_add_results,
            [[TP(1), TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]])
    
    bit_addition = bit_add_protocol(mpc, SharedTensor_a_bits, SharedTensor_b_bits_public).share
    revealed_bit_add_results = mpc.comms.reveal(bit_addition, modulus)
    if mpc.pid != 0:
        assert_eq(
            'Sequre bit add public',
            revealed_bit_add_results,
            [[TP(1), TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]])
    
    expected_decomposition_1 = zeros_vec(MODULUS_BITS, TP=int)
    expected_decomposition_2 = zeros_vec(MODULUS_BITS, TP=int)
    expected_decomposition_2[0] = 1
    expected_decomposition_3 = zeros_vec(MODULUS_BITS, TP=int)
    small_modulus = SECOND_RING_SIZE if modulus.popcnt() == 1 else SECOND_FIELD_SIZE
    for i in range(3): expected_decomposition_3[i] = 1
    bit_decomp_input = SharedTensor(mpc.comms.share_from_trusted_dealer([TP(0), TP(1), TP(7)], modulus), modulus)
    bit_decomposition = bit_decomposition_protocol(
        mpc, bit_decomp_input, bitlen=MODULUS_BITS, small_modulus=small_modulus, modulus=modulus)
    revealed_bit_decomposition = mpc.comms.reveal(bit_decomposition.share.to_int(), small_modulus)
    expected_decomposition = [expected_decomposition_1, expected_decomposition_2, expected_decomposition_3]
    if mpc.pid != 0:
        assert_eq(
            'Sequre bit decomposition',
            revealed_bit_decomposition,
            expected_decomposition)
    

@sequre
def test_sequre_basic_arithmetic(mpc, elem):
    alg_struct = "ring" if elem.modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC basic arithmetic on {alg_struct} ... \n')

    for _ in range(10000):
        mpc.randomness.switch_seed(-1)
        rand_elem_1 = (elem.share.to_int().rand(1 << (NBIT_K // 2 - 1)) - elem.share.to_int().rand(1 << (NBIT_K // 2 - 1))).to_float() / (1 << (NBIT_F // 2))
        rand_elem_2 = (elem.share.to_int().rand(1 << (NBIT_K // 2 - 1)) - elem.share.to_int().rand(1 << (NBIT_K // 2 - 1))).to_float() / (1 << (NBIT_F // 2))
        mpc.randomness.restore_seed(-1)

        rand_elem_1_shared = mpc.comms.share_from_trusted_dealer(rand_elem_1.to_fp(elem.modulus), elem.modulus)
        rand_elem_2_shared = mpc.comms.share_from_trusted_dealer(rand_elem_2.to_fp(elem.modulus), elem.modulus)

        SharedTensor_1 = SharedTensor(rand_elem_1_shared, elem.modulus)
        SharedTensor_2 = SharedTensor(rand_elem_2_shared, elem.modulus)
        SharedTensor_1.fp = True
        SharedTensor_2.fp = True

        sum_ = SharedTensor_1 + SharedTensor_2
        sub_ = SharedTensor_1 - SharedTensor_2
        mul_ = SharedTensor_1 * SharedTensor_2

        if mpc.pid != 0:
            assert_eq(f"{_}: Sequre addition for elems {rand_elem_1} and {rand_elem_1}", sum_.print(mpc), rand_elem_1 + rand_elem_2, True)
            assert_eq(f"{_}: Sequre subtraction for elems {rand_elem_1} and {rand_elem_1}", sub_.print(mpc), rand_elem_1 - rand_elem_2, True)
            assert_eq(f"{_}: Sequre multiplication for elems {rand_elem_1} and {rand_elem_1}", mul_.print(mpc), rand_elem_1 * rand_elem_2, True)


def test_sequre_sqrt(mpc, elem):
    alg_struct = "ring" if elem.modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC square root on {alg_struct} ... \n')
    
    modulus = elem.modulus
    fp_elem = elem.to_fp()
    expected_sqrt, expected_sqrt_inv = mpc.fp.fp_sqrt(fp_elem.share, modulus)
    sqrt, sqrt_inv = fp_sqrt(mpc, fp_elem)
    if mpc.pid != 0:
        assert_eq_approx("Sequre sqrt", mpc.comms.print_fp(sqrt.share, modulus), mpc.comms.print_fp(expected_sqrt, modulus))
        assert_eq_approx("Sequre sqrt_inv", mpc.comms.print_fp(sqrt_inv.share, modulus), mpc.comms.print_fp(expected_sqrt_inv, modulus))
    

@sequre
def test_sequre_division(mpc, elem_1, elem_2):
    assert elem_1.modulus == elem_2.modulus
    alg_struct = "ring" if elem_1.modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC divison on {alg_struct} ... \n')

    modulus = elem_1.modulus
    fp_elem_1 = elem_1.to_fp()
    fp_elem_2 = elem_2.to_fp()
    factor = 1000
    div = fp_elem_1 / factor
    if mpc.pid != 0:
        assert_eq_approx("Sequre division 1", mpc.comms.print_fp((div * factor).share, modulus), mpc.comms.print_fp(fp_elem_1.share, modulus))
        # TODO: #61 Find a way to reuse partitions in truncation
        # assert_eq_approx("Sequre division partitions", (div * factor).beaver_reveal(mpc), mpc.comms.print_fp(fp_elem.share))
    
    div = fp_elem_1 / fp_elem_2
    res = div * fp_elem_2
    if mpc.pid != 0:
        # TODO: #87 Figure out why code commented bellow does not work.
        # assert_eq_approx("Sequre division 2", (div * fp_elem_2).print(mpc), mpc.comms.print_fp(fp_elem_1.share))
        assert_eq_approx("Sequre division 2", res.print(mpc), mpc.comms.print_fp(fp_elem_1.share, modulus))
    

@sequre
def test_sequre_comparisons(mpc, vec):
    alg_struct = "ring" if vec.modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC comparisons on {alg_struct} ... \n')

    ones_vector = vec.raw_ones().to_float()
    zeros_vector = vec.raw_zeros().to_float()
    vec_larger = vec + 1
    elem = vec[0]

    eq = vec == vec
    lt = vec < vec_larger
    gt = vec_larger > vec

    not_eq = vec == vec_larger
    not_lt = vec_larger < vec
    not_gt = vec > vec_larger

    not_lt_2 = vec < vec
    not_gt_2 = vec > vec

    # Equality tests
    for _ in range(1000):
        mpc.randomness.switch_seed(-1)
        rand_elem_1 = (elem.share.to_int().rand(1 << ((NBIT_K + NBIT_F) // 2 - 1)) - elem.share.to_int().rand(1 << ((NBIT_K + NBIT_F) // 2 - 1))).to_float() / (1 << NBIT_F)
        rand_elem_2 = (elem.share.to_int().rand(1 << ((NBIT_K + NBIT_F) // 2 - 1)) - elem.share.to_int().rand(1 << ((NBIT_K + NBIT_F) // 2 - 1))).to_float() / (1 << NBIT_F)
        mpc.randomness.restore_seed(-1)

        rand_elem_1_shared = mpc.comms.share_from_trusted_dealer(rand_elem_1.to_fp(elem.modulus), elem.modulus)
        rand_elem_2_shared = mpc.comms.share_from_trusted_dealer(rand_elem_2.to_fp(elem.modulus), elem.modulus)

        SharedTensor_1 = SharedTensor(rand_elem_1_shared, elem.modulus)
        SharedTensor_2 = SharedTensor(rand_elem_2_shared, elem.modulus)
        SharedTensor_1.fp = True
        SharedTensor_2.fp = True

        is_pos_1 = (SharedTensor_1 - SharedTensor_1) > 0
        is_pos_2 = (SharedTensor_2 - SharedTensor_2) > 0
        is_pos_3 = (SharedTensor_1 - SharedTensor_2) > 0
        
        eq_1 = SharedTensor_1 == SharedTensor_1
        eq_2 = SharedTensor_2 == SharedTensor_2
        eq_3 = SharedTensor_1 == SharedTensor_2

        if mpc.pid != 0:
            assert_eq(f"{_}: Sequre is gt for elems {rand_elem_1} and {rand_elem_1}", is_pos_1.print(mpc), 0.0, True)
            assert_eq(f"{_}: Sequre is gt for elems {rand_elem_2} and {rand_elem_2}", is_pos_2.print(mpc), 0.0, True)
            assert_eq(
                f"{_}: Sequre is gt for elems {rand_elem_1} and {rand_elem_2}",
                is_pos_3.print(mpc), 1.0 if rand_elem_1 > rand_elem_2 else 0.0, True)
            assert_eq(f"{_}: Sequre eq for elems {rand_elem_1} and {rand_elem_1}", eq_1.print(mpc), 1.0, True)
            assert_eq(f"{_}: Sequre eq for elems {rand_elem_2} and {rand_elem_2}", eq_2.print(mpc), 1.0, True)
            assert_eq(
                f"{_}: Sequre eq for elems {rand_elem_1} and {rand_elem_2}",
                eq_3.print(mpc), 1.0 if rand_elem_1 == rand_elem_2 else 0.0, True)

    if mpc.pid != 0:
        assert_eq("Sequre eq", eq.print(mpc), ones_vector)
        assert_eq("Sequre lt", lt.print(mpc), ones_vector)
        assert_eq("Sequre get", gt.print(mpc), ones_vector)
        assert_eq("Sequre not eq", not_eq.print(mpc), zeros_vector)
        assert_eq("Sequre not lt", not_lt.print(mpc), zeros_vector)
        assert_eq("Sequre not gt", not_gt.print(mpc), zeros_vector)
        assert_eq("Sequre not lt 2", not_lt_2.print(mpc), zeros_vector)
        assert_eq("Sequre not gt 2", not_gt_2.print(mpc), zeros_vector)


def test_sequre_linear_algebra(mpc, modulus):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting sequre MPC linear algebra on {alg_struct} ... \n')
    
    with mpc.randomness.seed_switch(-1):
        raw_vec = random_floats((7,))
        raw_mat = random_floats((7, 7))
    mpc_vec = SharedTensor.enc(mpc, raw_vec, 0, modulus)
    mpc_mat = SharedTensor.enc(mpc, raw_mat, 0, modulus)
    
    raw_v = householder(mpc, array(raw_vec))
    mpc_v = householder(mpc, mpc_vec)
    if mpc.pid != 0:
        assert_eq_approx('Sequre householder', mpc_v.print(mpc), raw_v.tolist())
        assert_eq_approx('Input intact post householder', mpc_vec.print(mpc), raw_vec, silent_pass=True)

    raw_q_fact, raw_r_fact = qr_fact_square(mpc, array(raw_mat))
    mpc_q_fact, mpc_r_fact = qr_fact_square(mpc, mpc_mat)
    mpc_result_mat = sq.matmul(mpc, mpc_r_fact, mpc_q_fact)
    if mpc.pid != 0:
        assert_eq_approx('Sequre QR factorization', mpc_result_mat.print(mpc), (raw_r_fact @ raw_q_fact).tolist())
        assert_eq_approx('Input intact post QR factorization', mpc_mat.print(mpc), raw_mat, silent_pass=True)

    raw_t, raw_q = tridiag(mpc, array(raw_mat))
    mpc_t, mpc_q = tridiag(mpc, mpc_mat)
    if mpc.pid != 0:
        assert_eq_approx('Sequre tridiagonalize T', mpc_t.print(mpc), raw_t.tolist())
        assert_eq_approx('Sequre tridiagonalize Q', mpc_q.print(mpc), raw_q.tolist())
        assert_eq_approx('Input intact post tridiagonalization', mpc_mat.print(mpc), raw_mat, silent_pass=True)
    
    raw_eigen_mat, raw_eigen_val = eigen_decomp(mpc, array(raw_mat))
    mpc_eigen_mat, mpc_eigen_val = eigen_decomp(mpc, mpc_mat)
    if mpc.pid != 0:
        assert_eq_approx('Sequre eigen decomposition eigen matrix', mpc_eigen_mat.print(mpc), raw_eigen_mat.tolist(), error=0.15)
        assert_eq_approx('Sequre eigen decomposition eigen values', mpc_eigen_val.print(mpc), raw_eigen_val.tolist(), error=0.15)
        assert_eq_approx('Input intact post eigen decomposition', mpc_mat.print(mpc), raw_mat, silent_pass=True)

    raw_orth = orthonormal_basis(mpc, array(raw_mat))
    mpc_orth = orthonormal_basis(mpc, mpc_mat)
    if mpc.pid != 0:
        assert_eq_approx('Sequre orthonormal basis', mpc_orth.print(mpc), raw_orth.tolist())
        assert_eq_approx('Input intact post orthonormal basis', mpc_mat.print(mpc), raw_mat, silent_pass=True)


def test_sequre_mpc[TP](mpc: MPCEnv[TP], modulus: TP):
    alg_struct = "ring" if modulus.popcnt() == 1 else "field"
    print(f'CP{mpc.pid}:\tTesting Sequre MPC stdlib on {alg_struct} ... \n')

    a_vec = [
        double_to_fp(1.5, modulus),
        double_to_fp(0.5, modulus),
        double_to_fp(2.5, modulus)]
    sv_vec = SharedTensor(a_vec, modulus)
    sv_vec.fp = True
    sv_vec.set_partitions(mpc.arithmetic.__beaver_partition(sv_vec.share, modulus))
    
    sv_elem = SharedTensor(int_t(18350080), modulus)
    sv_elem.fp = True
    sv_elem.set_partitions(mpc.arithmetic.__beaver_partition(sv_elem.share, modulus))
    
    test_sequre_bitwise_operations(mpc, modulus)
    test_sequre_basic_arithmetic(mpc, sv_elem)
    test_sequre_division(mpc, sv_vec * 2, sv_vec)
    test_sequre_sqrt(mpc, sv_elem)
    test_sequre_sqrt(mpc, sv_vec)
    test_sequre_comparisons(mpc, sv_vec)
    test_sequre_linear_algebra(mpc, modulus)
    
    print(f'CP{mpc.pid}:\tSequre MPC stdlib tests on {alg_struct} passed.\n')
