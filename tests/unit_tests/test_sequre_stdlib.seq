from ..utils import assert_approx, assert_values

from sequre.utils.param import *
from sequre.types.utils import double_to_fp
from sequre.utils.utils import zeros_vec
from sequre.mpc.env import MPCEnv
from sequre.stdlib.lin_alg import *
from sequre.stdlib.fp import *
from sequre.stdlib.protocols import bit_add as bit_add_protocol, bit_decomposition as bit_decomposition_protocol
from sequre.stdlib.internal import Internal as sq
from sequre.attributes import *

# TODO: #93 Add tests for simple arithmetics also.


def test_sequre_sqrt(mpc, elem):
    modulus = elem.modulus
    fp_elem = elem.to_fp()
    expected_sqrt, expected_sqrt_inv = mpc.fp.fp_sqrt(fp_elem.share, modulus)
    sqrt, sqrt_inv = fp_sqrt(mpc, fp_elem)
    if mpc.pid != 0:
        assert_approx("Sequre sqrt", mpc.comms.print_fp(sqrt.share, modulus), mpc.comms.print_fp(expected_sqrt, modulus))
        assert_approx("Sequre sqrt_inv", mpc.comms.print_fp(sqrt_inv.share, modulus), mpc.comms.print_fp(expected_sqrt_inv, modulus))


@sequre_beaver
def test_sequre_division(mpc, elem_1, elem_2):
    assert elem_1.modulus == elem_2.modulus
    modulus = elem_1.modulus
    fp_elem_1 = elem_1.to_fp()
    fp_elem_2 = elem_2.to_fp()
    factor = 1000
    div = fp_elem_1 / factor
    if mpc.pid != 0:
        assert_approx("Sequre division 1", mpc.comms.print_fp((div * factor).share, modulus), mpc.comms.print_fp(fp_elem_1.share, modulus))
        # TODO: #61 Find a way to reuse partitions in truncation
        # assert_approx("Sequre division partitions", (div * factor).beaver_reveal(mpc), mpc.comms.print_fp(fp_elem.share))
    
    div = fp_elem_1 / fp_elem_2
    res = div * fp_elem_2
    if mpc.pid != 0:
        # TODO: #87 Figure out why code commented bellow does not work.
        # assert_approx("Sequre division 2", (div * fp_elem_2).print(mpc), mpc.comms.print_fp(fp_elem_1.share))
        assert_approx("Sequre division 2", res.print(mpc), mpc.comms.print_fp(fp_elem_1.share, modulus))


@sequre_beaver
def test_sequre_comparisons(mpc, elem):
    ones_vector = elem.raw_ones().to_float()
    zeros_vector = elem.raw_zeros().to_float()
    elem_larger = elem + 1

    eq = elem == elem
    lt = elem < elem_larger
    gt = elem_larger > elem

    not_eq = elem == elem_larger
    not_lt = elem_larger < elem
    not_gt = elem > elem_larger

    not_lt_2 = elem < elem
    not_gt_2 = elem > elem

    if mpc.pid != 0:
        assert_values("Sequre eq", eq.print(mpc), ones_vector)
        assert_values("Sequre lt", lt.print(mpc), ones_vector)
        assert_values("Sequre get", gt.print(mpc), ones_vector)
        assert_values("Sequre not eq", not_eq.print(mpc), zeros_vector)
        assert_values("Sequre not lt", not_lt.print(mpc), zeros_vector)
        assert_values("Sequre not gt", not_gt.print(mpc), zeros_vector)
        assert_values("Sequre not lt 2", not_lt_2.print(mpc), zeros_vector)
        assert_values("Sequre not gt 2", not_gt_2.print(mpc), zeros_vector)

def test_sequre_stdlib[TP](mpc: MPCEnv[TP], modulus: TP):
    a_bits = [TP(1), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]
    b_bits = [TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]
    shared_a_bits = mpc.comms.share([a_bits], modulus)
    shared_b_bits = mpc.comms.share([b_bits], modulus)
    stensor_a_bits = SharedTensor[typeof(shared_a_bits)](shared_a_bits, modulus)
    stensor_b_bits = SharedTensor[typeof(shared_b_bits)](shared_b_bits, modulus)
    stensor_b_bits_public = SharedTensor[list[typeof(b_bits)]]([b_bits], modulus)
    stensor_b_bits_public.public = True
    
    bit_add = bit_add_protocol(mpc, stensor_a_bits, stensor_b_bits).share
    revealed_bit_add_results = mpc.comms.reveal(bit_add, modulus)
    if mpc.pid != 0:
        assert_values(
            'Sequre bit add private',
            revealed_bit_add_results,
            [[TP(1), TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]])
    
    bit_add = bit_add_protocol(mpc, stensor_a_bits, stensor_b_bits_public).share
    revealed_bit_add_results = mpc.comms.reveal(bit_add, modulus)
    if mpc.pid != 0:
        assert_values(
            'Sequre bit add public',
            revealed_bit_add_results,
            [[TP(1), TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]])
    
    expected_decomposition_1 = zeros_vec[int](MODULUS_BITS)
    expected_decomposition_2 = zeros_vec[int](MODULUS_BITS)
    expected_decomposition_2[0] = 1
    expected_decomposition_3 = zeros_vec[int](MODULUS_BITS)
    small_modulus = SECOND_RING_SIZE if modulus.popcnt() == 1 else SECOND_FIELD_SIZE
    for i in range(3): expected_decomposition_3[i] = 1
    bit_decomp_input = SharedTensor[list[int_t]](mpc.comms.share([TP(0), TP(1), TP(7)], modulus), modulus)
    bit_decomposition = bit_decomposition_protocol(
        mpc, bit_decomp_input, bitlen=MODULUS_BITS, small_modulus=small_modulus, modulus=modulus)
    revealed_bit_decomposition = mpc.comms.reveal(bit_decomposition.share.to_int(), small_modulus)
    expected_decomposition = [expected_decomposition_1, expected_decomposition_2, expected_decomposition_3]
    if mpc.pid != 0:
        assert_values(
            'Sequre bit decomposition',
            revealed_bit_decomposition,
            expected_decomposition)

    a_vec = [
        double_to_fp(1.5, modulus),
        double_to_fp(0.5, modulus),
        double_to_fp(2.5, modulus)]
    sv_vec = SharedTensor[list[int_t]](a_vec, modulus)
    sv_vec.fp = True
    sv_vec.set_partitions(mpc.arithmetic.__beaver_partition(sv_vec.share, modulus))
    
    
    test_sequre_division(mpc, sv_vec * 2, sv_vec)
    test_sequre_sqrt(mpc, sv_vec)
    test_sequre_comparisons(mpc, sv_vec)

    
    v = householder(mpc, sv_vec)
    if mpc.pid != 0:
        assert_approx(
            'Sequre householder',
            mpc.comms.print_fp(v.share, modulus),
            [0.86807, 0.0973601, 0.486801])

    
    mat_float = [
        [4.0 for _ in range(3)],
        [4.5 for _ in range(3)],
        [5.5 for _ in range(3)]]
    sv_mat = SharedTensor[list[list[int_t]]](
        [[double_to_fp(e, modulus) for e in row]
         for row in mat_float], modulus)
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, modulus))
    q_fact, r_fact = qr_fact_square(mpc, sv_mat)
    result_mat = sq.matmul(mpc, r_fact, q_fact)
    if mpc.pid != 0:
        assert_approx('Sequre QR factorization', mpc.comms.print_fp(result_mat.share, modulus), mat_float * 2, 0.036)
    
    
    mat = [
        [double_to_fp(4.0, modulus),
            double_to_fp(3.0, modulus),
            double_to_fp(2.5, modulus)],
        [double_to_fp(0.5, modulus),
            double_to_fp(4.5, modulus),
            double_to_fp(1.5, modulus)],
        [double_to_fp(5.5, modulus),
            double_to_fp(2.0, modulus),
            double_to_fp(1.0, modulus)]]
    sv_mat = SharedTensor[list[list[int_t]]](mat, modulus)
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, modulus))
    t, q = tridiag(mpc, sv_mat)
    expected_t = [
        [8.0, -7.81025, 0.0],
        [-7.81025, 9.57377, 3.31148],
        [0.0, 2.31148, 1.42623]]
    expected_q = [
        [1.0, 0.0, 0.0],
        [0.0, -0.768221, -0.640184],
        [0.0, -0.640184, 0.768221]]
    if mpc.pid != 0:
        assert_approx('Sequre tridiagonalize 1', mpc.comms.print_fp(t.share, modulus), expected_t)
        assert_approx('Sequre tridiagonalize 2', mpc.comms.print_fp(q.share, modulus), expected_q)
    
    
    v_mat, l = eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    expected_v_mat = [
        [0.650711, 0.672083, 0.353383],
        [-0.420729, -0.0682978, 0.904612],
        [0.632109, -0.73732, 0.238322]]
    # TODO: #148 Merge #45 to fix test cases 
    expected_l = [16.9749, -0.799774, 2.88673]
    if mpc.pid != 0:
        assert_approx('Sequre eigen decomposition 1', mpc.comms.print_fp(v_mat.share, modulus), expected_v_mat)
        assert_approx('Sequre eigen decomposition 2', mpc.comms.print_fp(l.share, modulus), expected_l)
    

    expected_q_mat = [
        [-0.715542, -0.536656, -0.447214],
        [0.595097, -0.803563, 0.0121201],
        [0.365868, 0.257463, -0.894345]]
    result_mat = orthonormal_basis(mpc, sv_mat)
    if mpc.pid != 0:
        assert_approx('Sequre orthonormal basis', mpc.comms.print_fp(result_mat.share, modulus), expected_q_mat)
    
    print(f'Sequre stdlib ({"ring" if modulus.popcnt() == 1 else "field"}) tests passed at {mpc.pid}!\n')
