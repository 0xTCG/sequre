from experimental.simd import Vec

from ..utils import assert_eq

from sequre.utils.param import *
from sequre.utils.primitives import strassen, mod_inv, mod_pow

from sequre.lattiseq.ring import mred, _mm_mred, _mm_mult_sum, ntt_lazy, _mm_ntt_lazy_x4, _mm_butterfly_inplace_x2, reduce_vec, _mm_reduce_vec
from sequre.lattiseq.obsolete import mult_sum, _mm_butterfly_inplace_x2_old

def test_modular[TP](modulus: TP, algebraic_structure: str):
    assert_eq(f'Simple modulus 0 on {algebraic_structure}', TP(0) % TP(3), TP(0))
    assert_eq(f'Simple modulus 1 on {algebraic_structure}', TP(10) % TP(3), TP(1))
    assert_eq(f'Simple modulus 2 on {algebraic_structure}', (modulus + 1) % modulus, TP(1))
    assert_eq(f'Simple modulus 3 on {algebraic_structure}', modulus % modulus, TP(0))

    for i in range(1, 10000):
        assert_eq(f'Modular square of {i} by raw int on field', mod_pow(TP(i), 2, modulus), TP(i).mul_mod(TP(i), modulus), True)
        assert_eq(f'Modular cube by of {i} raw int on field', mod_pow(TP(i), 3, modulus), TP(i).mul_mod(TP(i), modulus).mul_mod(TP(i), modulus), True)
        assert_eq(f'Modular square of {i} on field', mod_pow(TP(i), TP(2), modulus), TP(i).mul_mod(TP(i), modulus), True)
        assert_eq(f'Modular cube of {i} on field', mod_pow(TP(i), TP(3), modulus), TP(i).mul_mod(TP(i), modulus).mul_mod(TP(i), modulus), True)

        assert_eq(f'Modular square of {(modulus - i).__repr__()} by raw int on field', mod_pow(modulus - i, 2, modulus), (modulus - i).mul_mod(modulus - i, modulus), True)
        assert_eq(f'Modular cube of {(modulus - i).__repr__()} by raw int on field', mod_pow(modulus - i, 3, modulus), (modulus - i).mul_mod(modulus - i, modulus).mul_mod(modulus - i, modulus), True)
        assert_eq(f'Modular square of {(modulus - i).__repr__()} on field', mod_pow(modulus - i, TP(2), modulus), (modulus - i).mul_mod(modulus - i, modulus), True)
        assert_eq(f'Modular cube of {(modulus - i).__repr__()} on field', mod_pow(modulus - i, TP(3), modulus), (modulus - i).mul_mod(modulus - i, modulus).mul_mod(modulus - i, modulus), True)

        assert_eq(f'Modular exponentiation by {i} on field', mod_pow(TP(1), TP(i), modulus), TP(1), True)
        assert_eq(f'Modular exponentiation by {(modulus - i).__repr__()} on field', mod_pow(TP(1), modulus - i, modulus), TP(1), True)
    print(f'Modular exponentiation passed on {algebraic_structure}.\n')

    if modulus.popcnt() != 1:
        for i in range(1, 100000):
            assert_eq(f'Modular inverse of {i} on field', mod_inv(TP(i), modulus).mul_mod(TP(i), modulus), TP(1), True)
    print(f'Modular multiplicative inverse passed on {algebraic_structure}.\n')
    
    if modulus.popcnt() != 1 and modulus == ((TP(1) << 127) - 1):
        assert_eq(
            f'Simple modular multiplication on {algebraic_structure}',
            TP('79624773705870324488959359155350619013').mul_mod(TP('101761777005983095179580621306363125588'), modulus),
            TP('111543309598552442012268786484921807604'))

def test_matmul_of_size[TP](size, modulus: TP):
    a_mat = [[TP(i * j) for j in range(size)] for i in range(size)]
    b_mat = [[TP(i * j) for j in range(size)] for i in range(size)]
    assert_eq(
        f'Matrix multiplication on {"ring" if modulus.popcnt() == 1 else "field"} of size {size}x{size}',
        strassen(a_mat, b_mat, modulus),
        a_mat.matmul_mod(b_mat, modulus))


def test_matmul[TP](modulus: TP):
    algebraic_structure = "ring" if modulus.popcnt() == 1 else "field"
    print(f'Testing matrix multiplication on {algebraic_structure} ... \n')

    test_matmul_of_size(5, modulus, TP=TP)
    test_matmul_of_size(MATMUL_LEAF_SIZE + 1, modulus, TP=TP)
    test_matmul_of_size(100, modulus, TP=TP)

    print(f'Matrix multiplication on {algebraic_structure} tests passed.\n')


def test_montgomery():
    x, y, q, q_inv = u64(36028796801285633), u64(7292413438934353), u64(36028797019389953), u64(1039592823570661377)
    
    _mm_x = Vec[u64, 4](x)
    _mm_y = Vec[u64, 4](y)
    _mm_q = Vec[u64, 4](q)
    _mm_q_inv = Vec[u64, 4](q_inv)

    m = mred(x, y, q, q_inv)
    _mm_m = _mm_mred(_mm_x, _mm_y, _mm_q, _mm_q_inv)

    assert_eq(f'Montgomery _mm_mred', _mm_m.scatter(), [m for _ in range(4)])

    v = [u64(1), u64(0), u64(1), u64(0)]
    y = [[u64(16353578116128), u64(19280067099343)], [u64(26691843734133), u64(1478986259000)], [u64(29470228109566), u64(32223689507422)], [u64(10903860369950), u64(15056171463628)]]
    nb_pi = 2
    pj = u64(36028797019389953)
    q_inv = u64(1039592823570661377)
    vtimesqmodp = [u64(0), u64(14566343215252127), u64(29132686430504254)]
    qoverqimodp = [u64(17871552176045569), u64(18007342180843009)]

    _mm_v = Vec[u64, 4](v)
    _mm_y = [Vec[u64, 4](e) for e in y.transpose()]
    _mm_pj_const = Vec[u64, 4](pj)
    _mm_q_inv_const = Vec[u64, 4](q_inv)
    _mm_qoverqimodp = [Vec[u64, 4](e) for e in qoverqimodp]

    s = mult_sum(v, y, nb_pi, pj, q_inv, vtimesqmodp, qoverqimodp, 4)
    _mm_s = _mm_mult_sum(
        _mm_v, _mm_y, _mm_pj_const, _mm_q_inv_const, vtimesqmodp, _mm_qoverqimodp)

    assert_eq(f'Montgomery _mm_mult_sum', _mm_s.scatter(), s)

    coeffs_in = [u64(36028797019389952), u64(36028797019389952), u64(1), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(1), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(1), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(1), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(0), u64(0), u64(0), u64(36028797019389952)]
    coeffs_out = [u64(36028797019389952), u64(36028797019389952), u64(1), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(1), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(1), u64(0), u64(0), u64(0), u64(36028797019389952), u64(36028797019389952), u64(1), u64(36028797019389952), u64(36028797019389952), u64(36028797019389952), u64(0), u64(0), u64(0), u64(36028797019389952)]
    n = 32
    ntt_psi = [u64(36028796801285633), u64(21322052610299771), u64(19749900754771513), u64(34496128126681124), u64(26085425198597987), u64(1083531368458287), u64(18970333468318480), u64(18411790513882853), u64(27992453387947810), u64(27063596860208285), u64(7007453096489808), u64(10101021952438785), u64(24627494485125821), u64(19355247870591465), u64(32956912874439446), u64(9200206207728983), u64(36028796801285633), u64(21322052610299771), u64(19749900754771513), u64(34496128126681124), u64(26085425198597987), u64(1083531368458287), u64(18970333468318480), u64(18411790513882853), u64(27992453387947810), u64(27063596860208285), u64(7007453096489808), u64(10101021952438785), u64(24627494485125821), u64(19355247870591465), u64(32956912874439446), u64(9200206207728983)]
    q = u64(36028797019389953)
    q_inv = u64(1039592823570661377)

    _mm_coeffs_in = coeffs_in.vectorize(4)
    _mm_coeffs_out = coeffs_out.vectorize(4)
    _mm_q = Vec[u64, 4](q)
    _mm_q_inv = Vec[u64, 4](q_inv)
    _mm_two_q = Vec[u64, 4](q << 1)
    _mm_four_q = Vec[u64, 4](q << 2)
    
    ntt_lazy(coeffs_in, coeffs_out, n, ntt_psi, q, q_inv)
    _mm_ntt_lazy_x4(
        _mm_coeffs_in, _mm_coeffs_out, n, ntt_psi,
        _mm_q, _mm_q_inv, _mm_two_q, _mm_four_q)
    
    assert_eq(f'Montgomery _mm_ntt_lazy_x4', _mm_coeffs_out.scatter_inplace(), coeffs_out)

    reduce_vec(coeffs_out, coeffs_out, q, q_inv)
    _mm_reduce_vec(_mm_coeffs_out, _mm_coeffs_out, _mm_q, _mm_q_inv)

    assert_eq(f'Montgomery _mm_reduce_vec', _mm_coeffs_out.scatter_inplace(), coeffs_out)


def test_primitives[TP](modulus: TP):
    algebraic_structure = "ring" if modulus.popcnt() == 1 else "field"
    print(f'Testing primitives on {algebraic_structure} ... \n')

    test_modular(modulus, algebraic_structure, TP=TP)
    test_matmul(modulus, TP=TP)
    test_montgomery()
    
    print(f'Primitives on {algebraic_structure} passed.\n')
