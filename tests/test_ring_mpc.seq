from utils import assert_values, assert_approx 

from sequre.utils.param import *
from sequre.utils.utils import evalp
from sequre.types.utils import double_to_fp

from sequre.mpc.env import MPCEnv


def test_ring_mpc[TP](mpc: MPCEnv[TP], modulus = RING_SIZE):
    vector_length = 10
    mat_rows_no, mat_cols_no = 10, 15

    # Test inputs
    elem_1 = TP(10)
    elem_2 = TP(7)
    elem_1_int = 10
    elem_2_int = 7
    vector_1 = [TP(10), TP(11), TP(12)]
    vector_2 = [TP(7), TP(8), TP(9)]
    vector_1_int = [10, 11, 12]
    vector_2_int = [7, 8, 9]
    matrix_1 = [[TP(1), TP(2), TP(3)], [TP(4), TP(5), TP(6)], [TP(7), TP(8), TP(9)]]
    matrix_2 = [[TP(10), TP(11), TP(12)], [TP(13), TP(14), TP(15)], [TP(16), TP(17), TP(18)]]
    matrix_1_int = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    matrix_2_int = [[10, 11, 12], [13, 14, 15], [16, 17, 18]]
    a: TP = double_to_fp(2.0 if mpc.pid == 1 else 1.14, modulus)
    b: TP = double_to_fp(3.0 if mpc.pid == 1 else 2.95, modulus)
    a_bits = [TP(1), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]
    b_bits = [TP(0), TP(0), TP(1), TP(0), TP(1), TP(0), TP(0)]

    elem_to_send: TP = elem_1.rand(modulus)
    if mpc.pid == 1:
        mpc.comms.send(elem_to_send, 2)
    elif mpc.pid == 2:
        received_elem: TP = mpc.comms.receive[TP](1)
        assert_values('Sending-receiving elem', received_elem, elem_to_send)
    
    vector_to_send: list[TP] = [elem_1.rand(modulus) for _ in range(vector_length)]
    if mpc.pid == 1:
        mpc.comms.send(vector_to_send, 2)
    elif mpc.pid == 2:
        received_vector: list[TP] = mpc.comms.receive[TP](1, shape=vector_length)
        assert_values('Sending-receiving vector', received_vector, vector_to_send)
    
    mat_to_send: list[list[TP]] = [[elem_1.rand(modulus) for _ in range(mat_cols_no)] for _ in range(mat_rows_no)]
    if mpc.pid == 1:
        mpc.comms.send(mat_to_send, 2)
    elif mpc.pid == 2:
        received_mat: list[list[TP]] = mpc.comms.receive[TP](1, shape=[mat_rows_no, mat_cols_no])
        assert_values('Sending-receiving matrix', received_mat, mat_to_send)
    
    elem_to_send_int: int = elem_1_int.rand(int(SECOND_P))
    if mpc.pid == 1:
        mpc.comms.send(elem_to_send_int, 2)
    elif mpc.pid == 2:
        received_elem: int = mpc.comms.receive[int](1)
        assert_values('Sending-receiving elem of ints', received_elem, elem_to_send_int)
    
    vector_to_send_int: list[int] = [elem_1_int.rand(int(SECOND_P)) for _ in range(vector_length)]
    if mpc.pid == 1:
        mpc.comms.send(vector_to_send_int, 2)
    elif mpc.pid == 2:
        received_vector: list[int] = mpc.comms.receive[int](1, shape=vector_length)
        assert_values('Sending-receiving vector of ints', received_vector, vector_to_send_int)
    
    mat_to_send_int: list[list[int]] = [[elem_1_int.rand(int(SECOND_P)) for _ in range(mat_cols_no)] for _ in range(mat_rows_no)]
    if mpc.pid == 1:
        mpc.comms.send(mat_to_send_int, 2)
    elif mpc.pid == 2:
        received_mat: list[list[int]] = mpc.comms.receive[int](1, shape=[mat_rows_no, mat_cols_no])
        assert_values('Sending-receiving matrix of ints', received_mat, mat_to_send_int)

    revealed_elem: TP = mpc.comms.reveal(elem_1 if mpc.pid == 1 else elem_2, modulus)
    if mpc.pid != 0:
        assert_values('Revealing elem', revealed_elem, elem_1 + elem_2)
    
    revealed_vector: list[TP] = mpc.comms.reveal(vector_1 if mpc.pid == 1 else vector_2, modulus)
    if mpc.pid != 0:
        assert_values('Revealing vector', revealed_vector, vector_1 + vector_2)
    
    revealed_matrix: list[list[TP]] = mpc.comms.reveal(matrix_1 if mpc.pid == 1 else matrix_2, modulus)
    if mpc.pid != 0:
        assert_values('Revealing matrix', revealed_matrix, matrix_1 + matrix_2)

    revealed_elem_int: int = mpc.comms.reveal(elem_1_int if mpc.pid == 1 else elem_2_int, int(SECOND_P))
    if mpc.pid != 0:
        assert_values('Revealing elem of ints', revealed_elem_int, (elem_1_int + elem_2_int) % int(SECOND_P))
    
    revealed_vector_int: list[int] = mpc.comms.reveal(vector_1_int if mpc.pid == 1 else vector_2_int, int(SECOND_P))
    if mpc.pid != 0:
        assert_values('Revealing vector of ints', revealed_vector_int, (vector_1_int + vector_2_int) % int(SECOND_P))
    
    revealed_matrix_int: list[list[int]] = mpc.comms.reveal(matrix_1_int if mpc.pid == 1 else matrix_2_int, int(SECOND_P))
    if mpc.pid != 0:
        assert_values('Revealing matrix of ints', revealed_matrix_int, (matrix_1_int + matrix_2_int) % int(SECOND_P))
    
    if mpc.pid == 1:
        mpc.prg.switch_seed(0)
    if mpc.pid == 2:
        mpc.prg.switch_seed(0)
    random_number = elem_1.rand(modulus)
    if mpc.pid != 0:
        mpc.comms.send(random_number, 0)
    if mpc.pid == 1:
        mpc.prg.restore_seed(0)
    if mpc.pid == 2:
        mpc.prg.restore_seed(0)
    
    if mpc.pid == 0:
        mpc.prg.switch_seed(2)
        random_number = elem_1.rand(modulus)
        mpc.prg.restore_seed(2)
        received_random_number: TP = mpc.comms.receive[TP](2)
        assert_values('PRG 1', random_number, received_random_number)

        mpc.prg.switch_seed(1)
        random_number = elem_1.rand(modulus)
        mpc.prg.restore_seed(1)
        received_random_number: TP = mpc.comms.receive[TP](1)
        assert_values('PRG 2', random_number, received_random_number)

    x_r, r = mpc.arithmetic.__beaver_partition(elem_1 if mpc.pid == 1 else elem_2, modulus)
    if mpc.pid == 0:
        mpc.comms.send(r, 1)
        mpc.comms.send(r, 2)
    else:
        r_0 = mpc.comms.receive[TP](0)
        assert_values('Beaver partition elem 1', r_0, mpc.comms.reveal(r, modulus))
        assert_values('Beaver partition elem 2', (x_r + mpc.comms.reveal(r, modulus)) % RING_SIZE, (elem_1 + elem_2) % RING_SIZE)
    
    x_r_vec, r_vec = mpc.arithmetic.__beaver_partition(vector_1 if mpc.pid == 1 else vector_2, modulus)
    if mpc.pid == 0:
        mpc.comms.send(r_vec, 1)
        mpc.comms.send(r_vec, 2)
    else:
        r_0 = mpc.comms.receive[TP](0, len(vector_1))
        assert_values('Beaver partition vector 1', r_0, mpc.comms.reveal(r_vec, modulus))
        assert_values('Beaver partition vector 2', (x_r_vec + mpc.comms.reveal(r_vec, modulus)) % RING_SIZE, (vector_1 + vector_2) % RING_SIZE)
        
    x_r_mat, r_mat = mpc.arithmetic.__beaver_partition(matrix_1 if mpc.pid == 1 else matrix_2, modulus)
    if mpc.pid == 0:
        mpc.comms.send(r_mat, 1)
        mpc.comms.send(r_mat, 2)
    else:
        r_0 = mpc.comms.receive[TP](0, matrix_1.shape())
        assert_values('Beaver partition matrix 1', r_0, mpc.comms.reveal(r_mat, modulus))
        assert_values('Beaver partition matrix 2', (x_r_mat + mpc.comms.reveal(r_mat, modulus)) % RING_SIZE, (matrix_1 + matrix_2) % RING_SIZE)
    
    x_r_int, r_int = mpc.arithmetic.__beaver_partition(
        elem_1_int if mpc.pid == 1 else elem_2_int, int(SECOND_P))
    if mpc.pid == 0:
        mpc.comms.send(r_int, 1)
        mpc.comms.send(r_int, 2)
    else:
        r_0_int = mpc.comms.receive[int](0)
        assert_values('Beaver partition elem 1 int', r_0_int, mpc.comms.reveal(r_int, int(SECOND_P)))
        assert_values('Beaver partition elem 2 int',
                      (x_r_int + mpc.comms.reveal(r_int, int(SECOND_P))) % int(SECOND_P),
                      (elem_1_int + elem_2_int) % int(SECOND_P))
    
    x_r_vec_int, r_vec_int = mpc.arithmetic.__beaver_partition(
        vector_1_int if mpc.pid == 1 else vector_2_int, int(SECOND_P))
    if mpc.pid == 0:
        mpc.comms.send(r_vec_int, 1)
        mpc.comms.send(r_vec_int, 2)
    else:
        r_0_int = mpc.comms.receive[int](0, len(vector_1_int))
        assert_values('Beaver partition vector 1 int', r_0_int, mpc.comms.reveal(r_vec_int, int(SECOND_P)))
        assert_values('Beaver partition vector 2 int',
                      (x_r_vec_int + mpc.comms.reveal(r_vec_int, int(SECOND_P))) % int(SECOND_P),
                      (vector_1_int + vector_2_int) % int(SECOND_P))
        
    x_r_mat_int, r_mat_int = mpc.arithmetic.__beaver_partition(
        matrix_1_int if mpc.pid == 1 else matrix_2_int, int(SECOND_P))
    if mpc.pid == 0:
        mpc.comms.send(r_mat_int, 1)
        mpc.comms.send(r_mat_int, 2)
    else:
        r_0_int = mpc.comms.receive[int](0, matrix_1_int.shape())
        assert_values('Beaver partition matrix 1 int', r_0_int, mpc.comms.reveal(r_mat_int, int(SECOND_P)))
        assert_values('Beaver partition matrix 2 int',
                      (x_r_mat_int + mpc.comms.reveal(r_mat_int, int(SECOND_P))) % int(SECOND_P),
                      (matrix_1_int + matrix_2_int) % int(SECOND_P))

    p_elem = mpc.arithmetic.multiply(
        elem_1 if mpc.pid == 1 else elem_2,
        elem_2 if mpc.pid == 1 else elem_1, modulus)
    revealed_p_elem = mpc.comms.reveal(p_elem, modulus)
    if mpc.pid != 0:
        assert_values('Multiply elem', revealed_p_elem, (elem_1 + elem_2) ** 2 % RING_SIZE)

    p_vec = mpc.arithmetic.multiply(
        vector_1 if mpc.pid == 1 else vector_2,
        vector_2 if mpc.pid == 1 else vector_1, modulus)
    revealed_p_vec = mpc.comms.reveal(p_vec, modulus)
    if mpc.pid != 0:
        assert_values('Multiply vector', revealed_p_vec, (vector_1 + vector_2) ** 2 % RING_SIZE)

    p_mat = mpc.arithmetic.multiply(
        matrix_1 if mpc.pid == 1 else matrix_2,
        matrix_2 if mpc.pid == 1 else matrix_1, modulus)
    revealed_p_mat = mpc.comms.reveal(p_mat, modulus)
    if mpc.pid != 0:
        assert_values('Multiply matrix', revealed_p_mat, (matrix_1 + matrix_2) ** 2 % RING_SIZE)

    p_mat_bulk = mpc.arithmetic.multiply_bulk(
        [matrix_1 if mpc.pid == 1 else matrix_2],
        [matrix_2 if mpc.pid == 1 else matrix_1], modulus)
    revealed_p_mat = mpc.comms.reveal(p_mat_bulk[0], modulus)
    if mpc.pid != 0:
        assert_values('Multiply bulk', revealed_p_mat, (matrix_1 + matrix_2) ** 2 % RING_SIZE)
    
    p_mat_bulk = mpc.arithmetic.multiply_mat_bulk(
        [matrix_1 if mpc.pid == 1 else matrix_2],
        [matrix_2 if mpc.pid == 1 else matrix_1], modulus)
    revealed_p_mat = mpc.comms.reveal(p_mat_bulk[0], modulus)
    added_mat = matrix_1 + matrix_2
    if mpc.pid != 0:
        assert_values('Multiply matrix bulk', revealed_p_mat, added_mat.mult(added_mat, modulus))
    
    p_elem: list[TP] = mpc.polynomial.powers(TP(2), 10, modulus)
    revealed_p_elem: list[TP] = mpc.comms.reveal(p_elem, modulus)
    if mpc.pid != 0:
        assert_values('Powers elem', revealed_p_elem[10], TP(1048576))
    
    p_vec: list[list[TP]] = mpc.polynomial.powers([TP(2), TP(0) if mpc.pid == 1 else TP(1), TP(3)], 10, modulus)
    revealed_p_vec: list[list[TP]] = mpc.comms.reveal(p_vec, modulus)
    if mpc.pid != 0:
        assert_values('Powers vector', revealed_p_vec[10], [TP(1048576), TP(1), TP(60466176)])
    
    coeff: list[list[TP]] = [[TP(1) for _ in range(3)], [TP(2) for _ in range(3)], [TP(3) for _ in range(3)]]
    x: list[TP] = [TP(1), TP(2), TP(3)]
    p = mpc.polynomial.evaluate_poly(x, coeff, modulus)
    revealed_p = mpc.comms.reveal(p, modulus)
    if mpc.pid != 0:
        expected_mat = [
            [TP(7), TP(21), TP(43)],
            [TP(14), TP(42), TP(86)],
            [TP(21), TP(63), TP(129)]]
        assert_values('Evaluate polynomial', revealed_p, expected_mat)
    
    size = 10
    # input_bits = [
    #     [(TP(0) if i != (size - 1) else e) for i in range(size)] for e in a_bits]
    # shared_input_bits = mpc.comms.share(input_bits)
    # or_results = mpc.boolean.fan_in_or(shared_input_bits)
    # revealed_or_results = mpc.comms.reveal(or_results)
    # if mpc.pid != 0:
    #     assert_values('Fan in or', revealed_or_results, a_bits)
    
    # input_bits = [
    #     [(TP(0) if i != (size - 1) else e) for i in range(size)] for e in a_bits]
    # shared_input_bits = mpc.comms.share(input_bits)
    # prefix_or_results = mpc.boolean.prefix_or(shared_input_bits)
    # revealed_prefix_or_results = mpc.comms.reveal(prefix_or_results)
    # if mpc.pid != 0:
    #     assert_values('Prefix or', revealed_prefix_or_results, input_bits)

    # shared_a_bits = mpc.comms.share([a_bits])
    # shared_b_bits = mpc.comms.share([b_bits])
    # not_less_results = mpc.boolean.less_than_bits(shared_a_bits, shared_b_bits)
    # less_results = mpc.boolean.less_than_bits(shared_b_bits, shared_a_bits)
    # revealed_not_less_results = mpc.comms.reveal(not_less_results)
    # revealed_less_results = mpc.comms.reveal(less_results)
    # if mpc.pid != 0:
    #     assert_values('Not less than bits', revealed_not_less_results, [TP(0)])
    #     assert_values('Less than bits', revealed_less_results, [TP(1)])
    
    # pos_neg = [
    #     double_to_fp(5.07, modulus),
    #     double_to_fp(-5.07, modulus)]
    # pos_neg_revealed = mpc.comms.reveal(mpc.boolean.is_positive(pos_neg))
    # if mpc.pid != 0:
    #     assert_values('Is positive', pos_neg_revealed, [TP(1), TP(0)])

    # shared_a = mpc.comms.share([TP(1), TP(5), TP(-3)])
    # shared_b = mpc.comms.share([TP(3), TP(3), TP(-7)])
    # revealed_less_results = mpc.comms.reveal(mpc.boolean.less_than(shared_a, shared_b))
    # if mpc.pid != 0:
    #     assert_values('Less than', revealed_less_results, [TP(1), TP(0), TP(0)])

    # public_b = TP(3)
    # revealed_less_results = mpc.comms.reveal(mpc.boolean.less_than_public(shared_a, public_b))
    # if mpc.pid != 0:
    #     assert_values('Less than public', revealed_less_results, [TP(1), TP(0), TP(1)])

    pub: TP = double_to_fp(5.07, modulus)
    a = mpc.arithmetic.add_public(a, pub, modulus)
    float_a = mpc.comms.print_fp(a, modulus)
    if mpc.pid != 0:
        assert_approx('Add public', float_a, 8.21)

    float_a = mpc.comms.print_fp(a, modulus)
    float_b = mpc.comms.print_fp(b, modulus)
    if mpc.pid != 0:
        assert_approx('Print FP 1', float_a, 8.21)
        assert_approx('Print FP 2', float_b, 5.95)
    
    # TODO: #92 Investigate why adding modulus to the value mess up results
    # result_elem = mpc.fp.trunc(
    #         mpc.arithmetic.multiply(a, b),
    #         modulus)
    # if mpc.pid != 0:
    #     assert_approx(
    #         'Multiply float',
    #         mpc.comms.print_fp(result_elem),
    #         48.8495)

    # nee_input = [
    #     double_to_fp(1099511627775.2354325, modulus),
    #     double_to_fp(128.0, modulus),
    #     double_to_fp(32.0, modulus),
    #     double_to_fp(50.0, modulus)]
    # nee, nee_sqrt = mpc.fp.__normalizer_even_exp(nee_input, modulus)

    # if mpc.pid != 0:
    #     revealed_nee = mpc.comms.reveal(nee, modulus)
    #     revealed_nee_sqrt = mpc.comms.reveal(nee_sqrt, modulus)
    #     assert_values('Normalizer Even Exponent 1', revealed_nee, revealed_nee_sqrt ** 2)
    #     assert_values('Normalizer Even Exponent 2', revealed_nee * nee_input * 2 < [TP(1) << NBIT_K for _ in range(len(nee_input))], True)
    #     assert_values('Normalizer Even Exponent 3', revealed_nee * nee_input * 2 >= [TP(1) << (NBIT_K - 2) for _ in range(len(nee_input))], True)

    # a_vec: list[TP] = [
    #     double_to_fp(18.0, modulus),
    #     double_to_fp(128.0, modulus),
    #     double_to_fp(32.0, modulus),
    #     double_to_fp(50.0, modulus)]
    # b_vec, b_vec_inv = mpc.fp.fp_sqrt(a_vec)
    # if mpc.pid != 0:
    #     assert_approx(
    #         'Sqrt',
    #         mpc.comms.print_fp(b_vec),
    #         [6.0, 16.0, 8.0, 10.0])
    #     assert_approx(
    #         'Sqrt inv',
    #         mpc.comms.print_fp(b_vec_inv),
    #         [0.1666666, 0.0625, 0.125, 0.1])
    
    # a_vec: list[TP] = [
    #     double_to_fp(7.0, modulus),
    #     double_to_fp(7.0, modulus),
    #     double_to_fp(256.0, modulus),
    #     double_to_fp(99.0, modulus),
    #     double_to_fp(50.0, modulus)]
    # b_vec: list[TP] = [
    #     double_to_fp(6.0, modulus),
    #     double_to_fp(6.0, modulus),
    #     double_to_fp(16.0, modulus),
    #     double_to_fp(3.0, modulus),
    #     double_to_fp(40.0, modulus)]
    # result_vec = mpc.fp.fp_div(a_vec, b_vec)
    # if mpc.pid != 0:
    #     assert_approx(
    #         'Division',
    #         mpc.comms.print_fp(result_vec),
    #         [1.1666666, 1.1666666, 16.0, 33.0, 1.25])
        
    # a_vec = [
    #     double_to_fp(1.5, modulus),
    #     double_to_fp(0.5, modulus),
    #     double_to_fp(2.5, modulus)]
    # result_vec = mpc.lin_alg.householder(a_vec)
    # if mpc.pid != 0:
    #     assert_approx(
    #         'Householder',
    #         mpc.comms.print_fp(result_vec),
    #         [0.86807, 0.0973601, 0.486801])

    # mat_float = [
    #     [4.0 for _ in range(3)],
    #     [4.5 for _ in range(3)],
    #     [5.5 for _ in range(3)]]
    # mat = [
    #     [double_to_fp(e, modulus) for e in row]
    #     for row in mat_float]
    # q_fact, r_fact = mpc.lin_alg.qr_fact_square(mat)
    # result_mat = mpc.arithmetic.multiply_matmul(r_fact, q_fact)
    # result_mat = mpc.fp.trunc(result_mat, modulus)
    # if mpc.pid != 0:
    #     assert_approx('QR factorization', mpc.comms.print_fp(result_mat), mat_float * 2, 0.036)

    # mat = [
    #     [double_to_fp(4.0, modulus),
    #         double_to_fp(3.0, modulus),
    #         double_to_fp(2.5, modulus)],
    #     [double_to_fp(0.5, modulus),
    #         double_to_fp(4.5, modulus),
    #         double_to_fp(1.5, modulus)],
    #     [double_to_fp(5.5, modulus),
    #         double_to_fp(2.0, modulus),
    #         double_to_fp(1.0, modulus)]]
    # t, q = mpc.lin_alg.tridiag(mat)
    # expected_t = [
    #     [8.0, -7.81025, 0.0],
    #     [-7.81025, 9.57377, 3.31148],
    #     [0.0, 2.31148, 1.42623]]
    # expected_q = [
    #     [1.0, 0.0, 0.0],
    #     [0.0, -0.768221, -0.640184],
    #     [0.0, -0.640184, 0.768221]]
    # if mpc.pid != 0:
    #     assert_approx('Tridiagonalize 1', mpc.comms.print_fp(t), expected_t)
    #     assert_approx('Tridiagonalize 2', mpc.comms.print_fp(q), expected_q)
        
    # v_mat, l = mpc.lin_alg.eigen_decomp(mat)
    # expected_v_mat = [
    #     [0.650711, 0.672083, 0.353383],
    #     [-0.420729, -0.0682978, 0.904612],
    #     [0.632109, -0.73732, 0.238322]]
    # # expected_l = [16.91242, -0.798897, 2.88648]
    # expected_l = [17.176, -0.806559, 2.88746]
    # if mpc.pid != 0:
    #     assert_approx('Eigen decomposition 1', mpc.comms.print_fp(v_mat), expected_v_mat)
    #     assert_approx('Eigen decomposition 2', mpc.comms.print_fp(l), expected_l)
        
    # expected_q_mat = [
    #     [-0.715542, -0.536656, -0.447214],
    #     [0.595097, -0.803563, 0.0121201],
    #     [0.365868, 0.257463, -0.894345]]
    # result_mat = mpc.lin_alg.orthonormal_basis(mat)
    # if mpc.pid != 0:
    #     assert_approx(
    #         'Orthonormal basis',
    #         mpc.comms.print_fp(result_mat),
    #         expected_q_mat)

    # vec = [TP(4), TP(5), TP(6)]
    # coefs = [TP(3), TP(2)]
    # exps = [[3, 2, 1], [1, 2, 3]]
    # poly_eval = mpc.optimizations.secure_evalp(vec, vec.zeros(), coefs, exps, modulus)
    # expected_poly_eval = evalp(vec * 2, coefs, exps, modulus)
    # if mpc.pid != 0:
    #     assert_values('Polynomial optimization', mpc.comms.reveal(poly_eval), expected_poly_eval)

    print(f'Ring MPC tests passed at {mpc.pid}!\n')
