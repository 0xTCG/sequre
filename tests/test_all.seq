from ..mpc.env import MPCEnv


def test_all[TP](mpc: MPCEnv[TP]):
    from test_mpc import test_mpc
    test_mpc(mpc)
    
    from test_optimized_mpc import test_optimized_mpc
    test_optimized_mpc(mpc)

    # from test_gwas import test_gwas
    # test_gwas(mpc)

    from test_optimized_gwas import test_optimized_gwas
    test_optimized_gwas(mpc)

    print(f'All tests passed at {mpc.pid}!\n')


def benchmark[TP](mpc: MPCEnv[TP], m: int, n: int):
    # import random, math
    import time
    
    # mat: np.ndarray = np.arange(m * n).reshape(m, n)
    # mat: list[list[TP]] = [[TP(i + j) for j in range(n)] for i in range(m)]  # np.zeros((m, n), dtype=np.int64)
    vec: list[TP] = [TP(i) for i in range(m)]
    
    # print('Orthonormal basis ...')
    # mpc.orthonormal_basis(mat)
    # print('QR ...')
    # mpc.qr_fact_square(mat)
    # print('Tridiag ...')
    # mpc.tridiag(mat)
    
    print('Householder ...')
    s = time.time()
    mpc.lin_alg.householder(vec)
    e = time.time()
    print(f'Householder done in {e - s}s at {mpc.pid}')

    # print('Eigen decomp ...')
    # s = time.time()
    # mpc.lin_alg.eigen_decomp(mat)
    # e = time.time()
    # print(f'Eigendecomp done in {e - s}s at {mpc.pid}')
    
    # from profilehooks import profile
    # fn = profile(mpc.eigen_decomp, entries=200) if pid == 2 else mpc.eigen_decomp
    # fn(mat)

    # coeff = np.arange(1000000, dtype=np.int64).reshape((1000, 1000))
    # x = np.arange(100, dtype=np.int64)

    # from line_profiler import LineProfiler
    # lp = LineProfiler()
    # fn = lp(mul_mod) if pid == 2 else mul_mod
    # fn(mat)
    # fn(coeff, coeff, BASE_P)
    # if pid == 2:
    #     lp.print_stats()

    # d = b * c
    # e = d + a
    # f = e ** 7
    # # Reconstruct f
    # g = (f + a) * d
    # return g ** 2

    # a^14 b^2 c^2 + 14 a^13 b^3 c^3 + 91 a^12 b^4 c^4 + 364 a^11 b^5 c^5 + 1001 a^10 b^6 c^6 + 2002 a^9 b^7 c^7 + 3003 a^8 b^8 c^8 + 2 a^8 b^2 c^2 + 3432 a^7 b^9 c^9 + 14 a^7 b^3 c^3 + 3003 a^6 b^10 c^10 + 42 a^6 b^4 c^4 + 2002 a^5 b^11 c^11 + 70 a^5 b^5 c^5 + 1001 a^4 b^12 c^12 + 70 a^4 b^6 c^6 + 364 a^3 b^13 c^13 + 42 a^3 b^7 c^7 + 91 a^2 b^14 c^14 + 14 a^2 b^8 c^8 + a^2 b^2 c^2 + 14 a b^15 c^15 + 2 a b^9 c^9 + b^16 c^16

    # from ir_examples import *

    # baseline = baseline_arithmetics(TP(2), TP(4), TP(6))
    
    # secure_non_opt = mpc.comms.reveal(secure_arithmetics(mpc, TP(1), TP(2), TP(3)))
    # # print '\nNon-optimized stats: '
    # mpc.comms.print_stats()
    # mpc.comms.reset_stats()

    # coefs = [TP(1), TP(14), TP(91), TP(364), TP(1001), TP(2002), TP(3003), TP(2), TP(3432), TP(14), TP(3003), TP(42), TP(2002), TP(70), TP(1001), TP(70), TP(364), TP(42), TP(91), TP(14), TP(1), TP(14), TP(2), TP(1)]
    # exps = [[14, 2, 2], [13, 3, 3], [12, 4, 4], [11, 5, 5], [10, 6, 6], [9, 7, 7], [8, 8, 8], [8, 2, 2], [7, 9, 9], [7, 3, 3], [6, 10, 10], [6, 4, 4], [5, 11, 11], [5, 5, 5], [4, 12, 12], [4, 6, 6], [3, 13, 13], [3, 7, 7], [2, 14, 14], [2, 8, 8], [2, 2, 2], [1, 15, 15], [1, 9, 9], [0, 1, 1]]
    # assert len(coefs) == len(exps), f'{len(coefs)}, {len(exps)}'
    # secure_opt = mpc.optimizations.secure_evalp(
    #     [TP(1), TP(2), TP(3)],
    #     coefs, exps, mpc.primes[0])
    # # print '\nOptimized stats: '
    # mpc.comms.print_stats()
    # mpc.comms.reset_stats()

    # a = sequre_arithmetics(1, 2, 3)
    # print(a)

    print(f'Benchmarks done at {mpc.pid}!')
