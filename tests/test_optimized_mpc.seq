from utils import assert_values, assert_approx 

from ..utils.param import *
from ..utils.type_ops import TypeOps
from ..utils.custom_types import SecureValue
from ..mpc.env import MPCEnv
from ..stdlib.lin_alg import *

# TODO: Add tests for simple arithmetics also.


def test_optimized_mpc[TP](mpc: MPCEnv[TP]):
    a_vec = [
        TypeOps.double_to_fp(1.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(0.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(2.5, NBIT_K, NBIT_F)]
    sv_vec = SecureValue[list[size_u]](a_vec)
    sv_vec.fp = True
    v = householder(mpc, sv_vec)
    if mpc.pid != 0:
        assert_approx(
            'Optimized householder',
            mpc.fp.print_fp(v.share),
            [0.86807, 0.0973601, 0.486801])

    
    mat_float = [
        [4.0 for _ in range(3)],
        [4.5 for _ in range(3)],
        [5.5 for _ in range(3)]]
    sv_mat = SecureValue[list[list[size_u]]](
        [[TypeOps.double_to_fp(e, NBIT_K, NBIT_F) for e in row]
         for row in mat_float])
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, mpc.primes[0]))
    q_fact, r_fact = qr_fact_square(mpc, sv_mat)
    result_mat = mpc.matmul(r_fact, q_fact)
    if mpc.pid != 0:
        assert_approx('Optimized QR factorization', mpc.fp.print_fp(result_mat.share), mat_float * 2, 0.036)
    
    
    mat = [
        [TypeOps.double_to_fp(4.0, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(3.0, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(2.5, NBIT_K, NBIT_F)],
        [TypeOps.double_to_fp(0.5, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(4.5, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(1.5, NBIT_K, NBIT_F)],
        [TypeOps.double_to_fp(5.5, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(2.0, NBIT_K, NBIT_F),
            TypeOps.double_to_fp(1.0, NBIT_K, NBIT_F)]]
    sv_mat = SecureValue[list[list[size_u]]](mat)
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, mpc.primes[0]))
    t, q = tridiag(mpc, sv_mat)
    expected_t = [
        [8.0, -7.81025, 0.0],
        [-7.81025, 9.57377, 3.31148],
        [0.0, 2.31148, 1.42623]]
    expected_q = [
        [1.0, 0.0, 0.0],
        [0.0, -0.768221, -0.640184],
        [0.0, -0.640184, 0.768221]]
    if mpc.pid != 0:
        assert_approx('Tridiagonalize 1', mpc.fp.print_fp(t.share), expected_t)
        assert_approx('Tridiagonalize 2', mpc.fp.print_fp(q.share), expected_q)
    
    
    v_mat, l = eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    expected_v_mat = [
        [0.650711, 0.672083, 0.353383],
        [-0.420729, -0.0682978, 0.904612],
        [0.632109, -0.73732, 0.238322]]
    expected_l = [17.176, -0.806559, 2.88746]
    if mpc.pid != 0:
        assert_approx('Eigen decomposition 1', mpc.fp.print_fp(v_mat.share), expected_v_mat)
        assert_approx('Eigen decomposition 2', mpc.fp.print_fp(l.share), expected_l)
    

    expected_q_mat = [
        [-0.715542, -0.536656, -0.447214],
        [0.595097, -0.803563, 0.0121201],
        [0.365868, 0.257463, -0.894345]]
    result_mat = orthonormal_basis(mpc, sv_mat)
    if mpc.pid != 0:
        assert_approx('Orthonormal basis', mpc.fp.print_fp(result_mat.share), expected_q_mat)
    
    print(f'Optimized MPC tests passed at {mpc.pid}!\n')
