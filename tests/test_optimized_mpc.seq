from utils import assert_approx 

from ..utils.param import *
from ..types.utils import double_to_fp
from ..mpc.env import MPCEnv
from ..stdlib.lin_alg import *
from ..stdlib.fp import *

from sequre import *

# TODO: #93 Add tests for simple arithmetics also.


def test_sequre_sqrt(mpc, elem):
    fp_elem = elem.to_fp()
    expected_sqrt, expected_sqrt_inv = mpc.fp.fp_sqrt(fp_elem.share)
    sqrt, sqrt_inv = fp_sqrt(mpc, fp_elem)
    if mpc.pid != 0:
        assert_approx("Sequre sqrt", mpc.comms.print_fp(sqrt.share), mpc.comms.print_fp(expected_sqrt))
        assert_approx("Sequre sqrt_inv", mpc.comms.print_fp(sqrt_inv.share), mpc.comms.print_fp(expected_sqrt_inv))


@sequre_beaver
def test_sequre_division(mpc, elem_1, elem_2):
    fp_elem_1 = elem_1.to_fp()
    fp_elem_2 = elem_2.to_fp()
    factor = 1000
    div = fp_elem_1 / factor
    if mpc.pid != 0:
        assert_approx("Sequre division 1", mpc.comms.print_fp((div * factor).share), mpc.comms.print_fp(fp_elem_1.share))
        # TODO: #61 Find a way to reuse partitions in truncation
        # assert_approx("Sequre division partitions", (div * factor).beaver_reveal(mpc), mpc.comms.print_fp(fp_elem.share))
    
    div = fp_elem_1 / fp_elem_2
    res = div * fp_elem_2
    if mpc.pid != 0:
        # TODO: #87 Figure out why code commented bellow does not work.
        # assert_approx("Sequre division 2", (div * fp_elem_2).print(mpc), mpc.comms.print_fp(fp_elem_1.share))
        assert_approx("Sequre division 2", res.print(mpc), mpc.comms.print_fp(fp_elem_1.share))


def test_optimized_mpc[TP](mpc: MPCEnv[TP]):
    a_vec = [
        double_to_fp(1.5, NBIT_K, NBIT_F),
        double_to_fp(0.5, NBIT_K, NBIT_F),
        double_to_fp(2.5, NBIT_K, NBIT_F)]
    sv_vec = SecureValue[list[int_t]](a_vec)
    sv_vec.fp = True
    sv_vec.set_partitions(mpc.arithmetic.__beaver_partition(sv_vec.share, BASE_P))
    
    
    test_sequre_division(mpc, sv_vec * 2, sv_vec)
    test_sequre_sqrt(mpc, sv_vec)

    
    v = householder(mpc, sv_vec)
    if mpc.pid != 0:
        assert_approx(
            'Optimized householder',
            mpc.comms.print_fp(v.share),
            [0.86807, 0.0973601, 0.486801])

    
    mat_float = [
        [4.0 for _ in range(3)],
        [4.5 for _ in range(3)],
        [5.5 for _ in range(3)]]
    sv_mat = SecureValue[list[list[int_t]]](
        [[double_to_fp(e, NBIT_K, NBIT_F) for e in row]
         for row in mat_float])
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, BASE_P))
    q_fact, r_fact = qr_fact_square(mpc, sv_mat)
    result_mat = mpc.matmul(r_fact, q_fact)
    if mpc.pid != 0:
        assert_approx('Optimized QR factorization', mpc.comms.print_fp(result_mat.share), mat_float * 2, 0.036)
    
    
    mat = [
        [double_to_fp(4.0, NBIT_K, NBIT_F),
            double_to_fp(3.0, NBIT_K, NBIT_F),
            double_to_fp(2.5, NBIT_K, NBIT_F)],
        [double_to_fp(0.5, NBIT_K, NBIT_F),
            double_to_fp(4.5, NBIT_K, NBIT_F),
            double_to_fp(1.5, NBIT_K, NBIT_F)],
        [double_to_fp(5.5, NBIT_K, NBIT_F),
            double_to_fp(2.0, NBIT_K, NBIT_F),
            double_to_fp(1.0, NBIT_K, NBIT_F)]]
    sv_mat = SecureValue[list[list[int_t]]](mat)
    sv_mat.fp = True
    sv_mat.set_partitions(mpc.arithmetic.__beaver_partition(sv_mat.share, BASE_P))
    t, q = tridiag(mpc, sv_mat)
    expected_t = [
        [8.0, -7.81025, 0.0],
        [-7.81025, 9.57377, 3.31148],
        [0.0, 2.31148, 1.42623]]
    expected_q = [
        [1.0, 0.0, 0.0],
        [0.0, -0.768221, -0.640184],
        [0.0, -0.640184, 0.768221]]
    if mpc.pid != 0:
        assert_approx('Optimized tridiagonalize 1', mpc.comms.print_fp(t.share), expected_t)
        assert_approx('Optimized tridiagonalize 2', mpc.comms.print_fp(q.share), expected_q)
    
    
    v_mat, l = eigen_decomp(mpc, sv_mat, ITER_PER_EVAL)
    expected_v_mat = [
        [0.650711, 0.672083, 0.353383],
        [-0.420729, -0.0682978, 0.904612],
        [0.632109, -0.73732, 0.238322]]
    expected_l = [17.176, -0.806559, 2.88746]
    if mpc.pid != 0:
        assert_approx('Optimized eigen decomposition 1', mpc.comms.print_fp(v_mat.share), expected_v_mat)
        assert_approx('Optimized eigen decomposition 2', mpc.comms.print_fp(l.share), expected_l)
    

    expected_q_mat = [
        [-0.715542, -0.536656, -0.447214],
        [0.595097, -0.803563, 0.0121201],
        [0.365868, 0.257463, -0.894345]]
    result_mat = orthonormal_basis(mpc, sv_mat)
    if mpc.pid != 0:
        assert_approx('Optimized orthonormal basis', mpc.comms.print_fp(result_mat.share), expected_q_mat)
    
    print(f'Optimized MPC tests passed at {mpc.pid}!\n')
