from utils import assert_values, assert_approx 

from ..utils.param import *
from ..utils.type_ops import TypeOps
from ..utils.custom_types import SecureValue
from ..mpc.env import MPCEnv
from ..stdlib.lin_alg import *

# TODO: Add tests for simple arithmetics also.

def test_optimized_mpc[TP](mpc: MPCEnv[TP]):
    a_vec = [
        TypeOps.double_to_fp(1.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(0.5, NBIT_K, NBIT_F),
        TypeOps.double_to_fp(2.5, NBIT_K, NBIT_F)]
    sv_vec = SecureValue[list[size_u]](a_vec)
    sv_vec.fp = True
    v = householder(mpc, sv_vec)
    if mpc.pid != 0:
        assert_approx(
            'Optimized householder',
            mpc.fp.print_fp(v.share),
            [0.86807, 0.0973601, 0.486801])

    # mat_float = [
    #     [4.0 for _ in range(3)],
    #     [4.5 for _ in range(3)],
    #     [5.5 for _ in range(3)]]
    # sv_mat = SecureValue[list[list[size_u]]](
    #     [[TypeOps.double_to_fp(e, NBIT_K, NBIT_F) for e in row]
    #      for row in mat_float])
    # sv_mat.fp = True
    # q_fact, r_fact = qr_fact_square(mpc, sv_mat)
    # result_mat = mpc.matmul(r_fact, q_fact)
    # if mpc.pid != 0:
    #     assert_approx('Optimized QR factorization', mpc.fp.print_fp(result_mat.share), mat_float * 2, 0.036)
    
    print(f'Optimized MPC tests passed at {mpc.pid}!')
