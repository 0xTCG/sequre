import utils.param as param

from mpc_prg import MPCPRG
from network_socket import CSocket
from network_connect import open_channel, connect
from utils.utils import rand_int, rand_vec, rand_mat


class MPCComms[TP]:
    pid: int
    sockets: dict[int, CSocket]
    bytes_sent: int
    requests_sent: int
    prg: MPCPRG

    def __init__(self: MPCComms[TP], pid: int, prg: MPCPRG):
        self.pid = pid
        self.prg = prg
        self.sockets = dict[int, CSocket]()
        self.bytes_sent = 0
        self.requests_sent = 0

        self.__setup_channels()

    def send_bool(self: MPCComms[TP], flag: bool, to_pid: int):
        self.sockets[to_pid].send([TP(int(flag))], param.SIZE_OF_U)

    def receive_bool(self: MPCComms[TP], from_pid: int) -> bool:
        return bool(next(self.sockets[from_pid].receive(msg_len=param.SIZE_OF_U)))

    def send[CT](self: MPCComms[TP], data: CT, to_pid: int) -> int:
        bytes_sent = self.sockets[to_pid].send(data.to_bytes(), data.msg_len())
        self.bytes_sent += bytes_sent
        self.requests_sent += 1
        return bytes_sent
    
    def receive(self, from_pid: int, shape = False):
        if isinstance(shape, bool):
            return self.__receive_elem(from_pid)
        if isinstance(shape, int):
            return self.__receive_vector(from_pid, shape)
        if isinstance(shape, list[int]):
            return self.__receive_matrix(from_pid, shape)
        
        raise TypeError(f"Invalid type for {shape}")

    def share(self, value):
        if isinstance(value, param.size_u):
            return self.__share_elem(value)
        if isinstance(value, list[param.size_u]):
            return self.__share_vector(value)
        if isinstance(value, list[list[param.size_u]]):
            return self.__share_matrix(value)
        
        raise TypeError(f"Invalid type for {value}")

    def reveal(self, value, field = param.BASE_P):
        if isinstance(value, param.size_u):
            return self.__reveal_elem(value, field)
        if isinstance(value, list[param.size_u]):
            return self.__reveal_vector(value, field)
        if isinstance(value, list[list[param.size_u]]):
            return self.__reveal_matrix(value, field)
        
        raise TypeError(f"Invalid type for {value}")
    
    def clean_up(self: MPCComms[TP]):
        for socket in self.sockets.values():
            socket.close()
    
    def print_stats(self: MPCComms[TP]):
        print f'Total bytes sent from {self.pid}: {self.bytes_sent}.'
        print f'Total send requests at {self.pid}: {self.requests_sent}.'
    
    def reset_stats(self: MPCComms[TP]):
        self.bytes_sent = 0
        self.requests_sent = 0
    
    def __receive_elem(self: MPCComms[TP], from_pid: int) -> TP:
        return TP(next(self.sockets[from_pid].receive(msg_len=param.SIZE_OF_U)))

    def __receive_vector(self: MPCComms[TP], from_pid: int, length: int) -> list[TP]:
        received_vec = list[TP](length)

        for elem in self.sockets[from_pid].receive(msg_len=length * param.SIZE_OF_U):
            received_vec.append(TP(elem))

        return received_vec
    
    def __receive_matrix(self: MPCComms[TP], from_pid: int, shape: list[int]) -> list[list[TP]]:
        rows, cols = shape
        matrix = list[list[TP]](rows)
        row = list[TP](cols)
        j = 0

        for elem in self.sockets[from_pid].receive(msg_len=rows * cols * param.SIZE_OF_U):
            if j != cols:
                row.append(TP(elem))
                j += 1
            if j == cols:
                matrix.append(row)
                j = 0
                row = list[TP](cols)

        return matrix
    
    def __share_elem(self: MPCComms[TP], elem: TP) -> TP:
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_int(param.BASE_P)
            self.prg.restore_seed(1)

            elem -= r
            elem %= param.BASE_P

            self.send(elem, 2, param.SIZE_OF_U)
            return elem
        elif self.pid == 2:
            return self.receive(0)
        else:
            self.prg.switch_seed(0)
            r = rand_int(param.BASE_P)
            self.prg.restore_seed(0)
            return r
    
    def __share_vector(self: MPCComms[TP], vec: list[TP]) -> list[TP]:
        n = len(vec)
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_vec(n, param.BASE_P)
            self.prg.restore_seed(1)

            vec -= r
            vec %= param.BASE_P

            self.send(vec, 2)
            return vec
        elif self.pid == 2:
            return self.receive(0, n)
        else:
            self.prg.switch_seed(0)
            r = rand_vec(n, param.BASE_P)
            self.prg.restore_seed(0)
            return r
    
    def __share_matrix(self: MPCComms[TP], mat: list[list[TP]]) -> list[list[TP]]:
        m, n = mat.shape()
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_mat([m, n], param.BASE_P)
            self.prg.restore_seed(1)

            mat -= r
            mat %= param.BASE_P

            self.send(mat, 2)
            return mat
        elif self.pid == 2:
            return self.receive(0, [m, n])
        else:
            self.prg.switch_seed(0)
            r = rand_mat([m, n], param.BASE_P)
            self.prg.restore_seed(0)
            return r
    
    def __reveal_elem(self: MPCComms[TP], elem: TP, field: TP = param.BASE_P) -> TP:
        if self.pid == 0:
            return elem
        
        received_elem = TP()
        if self.pid == 1:
            sent_data = self.send(elem, 3 - self.pid)
            received_elem = self.receive(3 - self.pid)
        else:
            received_elem = self.receive(3 - self.pid)
            sent_data = self.send(elem, 3 - self.pid)
        
        return (elem + received_elem) % field
    
    def __reveal_vector(self: MPCComms[TP], elem: list[TP], field: TP = param.BASE_P) -> list[TP]:
        if self.pid == 0:
            return elem
        
        received_elem = list[TP]()
        if self.pid == 1:
            sent_data = self.send(elem, 3 - self.pid)
            received_elem = self.receive(3 - self.pid, len(elem))
        else:
            received_elem = self.receive(3 - self.pid, len(elem))
            sent_data = self.send(elem, 3 - self.pid)
            
        return (elem + received_elem) % field
    
    def __reveal_matrix(self: MPCComms[TP], elem: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        if self.pid == 0:
            return elem
        
        received_elem = list[list[TP]]()
        if self.pid == 1:
            shape = elem.shape()
            sent_data = self.send(elem, 3 - self.pid)
            received_elem = self.receive(3 - self.pid, shape)
        else:
            shape = elem.shape()
            received_elem = self.receive(3 - self.pid, shape)
            sent_data = self.send(elem, 3 - self.pid)
            
        return (elem + received_elem) % field
    
    def __setup_channels(self):
        for p_1 in range(2):
            for p_2 in range(p_1 + 1, 3):
                if (p_1 != self.pid and p_2 != self.pid):
                    continue

                serveraddr = param.SERVERADDR_P0_P1
                serveraddr_len = param.ADDR_LEN_P0_P1
                if (p_1 == 0 and p_2 == 1):
                    serveraddr = param.SERVERADDR_P0_P1
                    serveraddr_len = param.ADDR_LEN_P0_P1
                elif (p_1 == 0 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P0_P2
                    serveraddr_len = param.ADDR_LEN_P0_P2
                elif (p_1 == 1 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P1_P2
                    serveraddr_len = param.ADDR_LEN_P1_P2
                else:
                    raise ValueError('Ivalid node pairs!')
                
                pother: int = p_1 + p_2 - self.pid
                self.sockets[pother] = CSocket()

                if (p_1 == self.pid):
                    open_channel(self.sockets[pother], serveraddr, serveraddr_len)
                elif (not connect(self.sockets[pother], serveraddr, serveraddr_len)):
                    raise ValueError(f"{self.pid} failed to connect with {pother}")
