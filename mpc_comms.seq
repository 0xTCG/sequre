import utils.param as param

from network_socket import CSocket
from network_connect import open_channel, connect
# from utils.type_ops import TypeOps
from utils.utils import get_address


class MPCComms[TP]:
    pid: int
    sockets: dict[int, CSocket]

    def __init__(self: MPCComms[TP], pid: int):
        self.pid = pid
        self.sockets = dict[int, CSocket]()

        for p_1 in range(2):
            for p_2 in range(p_1 + 1, 3):
                if (p_1 != self.pid and p_2 != self.pid):
                    continue

                serveraddr = param.SERVERADDR_P0_P1
                serveraddr_len = param.ADDR_LEN_P0_P1
                if (p_1 == 0 and p_2 == 1):
                    serveraddr = param.SERVERADDR_P0_P1
                    serveraddr_len = param.ADDR_LEN_P0_P1
                elif (p_1 == 0 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P0_P2
                    serveraddr_len = param.ADDR_LEN_P0_P2
                elif (p_1 == 1 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P1_P2
                    serveraddr_len = param.ADDR_LEN_P1_P2
                else:
                    raise ValueError('Ivalid node pairs!')
                
                pother: int = p_1 + p_2 - self.pid
                self.sockets[pother] = CSocket()

                if (p_1 == self.pid):
                    open_channel(self.sockets[pother], serveraddr, serveraddr_len)
                elif (not connect(self.sockets[pother], serveraddr, serveraddr_len)):
                    raise ValueError(f"{self.pid} failed to connect with {pother}")

    def receive_bool(self: MPCComms[TP], from_pid: int) -> bool:
        return bool(int(next(self.sockets[from_pid].receive(msg_len=1))))

    def send_bool(self: MPCComms[TP], flag: bool, to_pid: int):
        self.sockets[to_pid].send([str(int(flag))])

    def send_data[CT](self: MPCComms[TP], data: CT, to_pid: int) -> int:
        return self.sockets[to_pid].send(data.to_bytes())
    
    def receive_elem(self: MPCComms[TP], from_pid: int) -> TP:
        return TP(next(self.sockets[from_pid].receive(msg_len=param.BASE_LEN)))

    def receive_vector(self: MPCComms[TP], from_pid: int, length: int) -> list[TP]:
        received_vec = list[TP](length)

        for elem in self.sockets[from_pid].receive(msg_len=length * param.BASE_LEN):
            received_vec.append(TP(elem))

        return received_vec
    
    def receive_matrix(self: MPCComms[TP], from_pid: int, shape: list[int]) -> list[list[TP]]:
        rows, cols = shape
        matrix = list[list[TP]](rows)
        row = list[TP](cols)
        j = 0

        for elem in self.sockets[from_pid].receive(msg_len=rows * cols * param.BASE_LEN):
            if j != cols:
                row.append(TP(elem))
                j += 1
            if j == cols:
                matrix.append(row)
                j = 0
                row = list[TP](cols)

        return matrix
        
    
    def reveal_elem(self: MPCComms[TP], elem: TP, field: TP = param.BASE_P) -> TP:
        if self.pid == 0:
            return elem
        
        received_elem = TP()
        if self.pid == 1:
            sent_data = self.send_data[TP](elem, 3 - self.pid)
            received_elem = self.receive_elem(3 - self.pid)
        else:
            received_elem = self.receive_elem(3 - self.pid)
            sent_data = self.send_data[TP](elem, 3 - self.pid)
            
        return (elem + received_elem) % field
    
    def reveal_vector(self: MPCComms[TP], elem: list[TP], field: TP = param.BASE_P) -> list[TP]:
        if self.pid == 0:
            return elem
        
        received_elem = list[TP]()
        if self.pid == 1:
            sent_data = self.send_data[list[TP]](elem, 3 - self.pid)
            received_elem = self.receive_vector(3 - self.pid, len(elem))
        else:
            received_elem = self.receive_vector(3 - self.pid, len(elem))
            sent_data = self.send_data[list[TP]](elem, 3 - self.pid)
            
        return (elem + received_elem) % field
    
    def reveal_matrix(self: MPCComms[TP], elem: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        if self.pid == 0:
            return elem
        
        received_elem = list[list[TP]]()
        if self.pid == 1:
            sent_data = self.send_data[list[list[TP]]](elem, 3 - self.pid)
            received_elem = self.receive_matrix(3 - self.pid, elem.shape())
        else:
            received_elem = self.receive_matrix(3 - self.pid, elem.shape())
            sent_data = self.send_data[list[list[TP]]](elem, 3 - self.pid)
            
        return (elem + received_elem) % field
    
    def clean_up(self: MPCComms):
        for socket in self.sockets.values():
            socket.close()
