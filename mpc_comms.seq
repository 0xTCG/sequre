import utils.param as param

from mpc_prg import MPCPRG
from network_socket import CSocket
from network_connect import open_channel, connect
# from utils.type_ops import TypeOps
from utils.utils import get_address, rand_int, rand_vec, rand_mat


class MPCComms[TP]:
    pid: int
    sockets: dict[int, CSocket]
    bytes_sent: int
    requests_sent: int
    prg: MPCPRG

    def __init__(self: MPCComms[TP], pid: int, prg: MPCPRG):
        self.pid = pid
        self.prg = prg
        self.sockets = dict[int, CSocket]()
        self.bytes_sent = 0
        self.requests_sent = 0

        for p_1 in range(2):
            for p_2 in range(p_1 + 1, 3):
                if (p_1 != self.pid and p_2 != self.pid):
                    continue

                serveraddr = param.SERVERADDR_P0_P1
                serveraddr_len = param.ADDR_LEN_P0_P1
                if (p_1 == 0 and p_2 == 1):
                    serveraddr = param.SERVERADDR_P0_P1
                    serveraddr_len = param.ADDR_LEN_P0_P1
                elif (p_1 == 0 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P0_P2
                    serveraddr_len = param.ADDR_LEN_P0_P2
                elif (p_1 == 1 and p_2 == 2):
                    serveraddr = param.SERVERADDR_P1_P2
                    serveraddr_len = param.ADDR_LEN_P1_P2
                else:
                    raise ValueError('Ivalid node pairs!')
                
                pother: int = p_1 + p_2 - self.pid
                self.sockets[pother] = CSocket()

                if (p_1 == self.pid):
                    open_channel(self.sockets[pother], serveraddr, serveraddr_len)
                elif (not connect(self.sockets[pother], serveraddr, serveraddr_len)):
                    raise ValueError(f"{self.pid} failed to connect with {pother}")

    def receive_bool(self: MPCComms[TP], from_pid: int) -> bool:
        return bool(next(self.sockets[from_pid].receive(msg_len=param.SIZE_OF_U)))

    def send_bool(self: MPCComms[TP], flag: bool, to_pid: int):
        self.sockets[to_pid].send([TP(int(flag))], param.SIZE_OF_U)

    def send_data[CT](self: MPCComms[TP], data: CT, to_pid: int, msg_len: int) -> int:
        bytes_sent = self.sockets[to_pid].send(data.to_bytes(), msg_len)
        self.bytes_sent += bytes_sent
        self.requests_sent += 1
        return bytes_sent
    
    def receive_elem(self: MPCComms[TP], from_pid: int) -> TP:
        return TP(next(self.sockets[from_pid].receive(msg_len=param.SIZE_OF_U)))

    def receive_vector(self: MPCComms[TP], from_pid: int, length: int) -> list[TP]:
        received_vec = list[TP](length)

        for elem in self.sockets[from_pid].receive(msg_len=length * param.SIZE_OF_U):
            received_vec.append(TP(elem))

        return received_vec
    
    def receive_matrix(self: MPCComms[TP], from_pid: int, shape: list[int]) -> list[list[TP]]:
        rows, cols = shape
        matrix = list[list[TP]](rows)
        row = list[TP](cols)
        j = 0

        for elem in self.sockets[from_pid].receive(msg_len=rows * cols * param.SIZE_OF_U):
            if j != cols:
                row.append(TP(elem))
                j += 1
            if j == cols:
                matrix.append(row)
                j = 0
                row = list[TP](cols)

        return matrix
    
    def share_elem(self: MPCComms[TP], elem: TP) -> TP:
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_int(param.BASE_P)
            self.prg.restore_seed(1)

            elem -= r
            elem %= param.BASE_P

            self.send_data(elem, 2, param.SIZE_OF_U)
            return elem
        elif self.pid == 2:
            return self.receive_elem(0)
        else:
            self.prg.switch_seed(0)
            r = rand_int(param.BASE_P)
            self.prg.restore_seed(0)
            return r
    
    def share_vector(self: MPCComms[TP], vec: list[TP]) -> list[TP]:
        n = len(vec)
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_vec(n, param.BASE_P)
            self.prg.restore_seed(1)

            vec -= r
            vec %= param.BASE_P

            self.send_data(vec, 2, n * param.SIZE_OF_U)
            return vec
        elif self.pid == 2:
            return self.receive_vector(0, n)
        else:
            self.prg.switch_seed(0)
            r = rand_vec(n, param.BASE_P)
            self.prg.restore_seed(0)
            return r
    
    def share_matrix(self: MPCComms[TP], mat: list[list[TP]]) -> list[list[TP]]:
        m, n = mat.shape()
        if self.pid == 0:
            self.prg.switch_seed(1)
            r = rand_mat([m, n], param.BASE_P)
            self.prg.restore_seed(1)

            mat -= r
            mat %= param.BASE_P

            self.send_data(mat, 2, m * n * param.SIZE_OF_U)
            return mat
        elif self.pid == 2:
            return self.receive_matrix(0, [m, n])
        else:
            self.prg.switch_seed(0)
            r = rand_mat([m, n], param.BASE_P)
            self.prg.restore_seed(0)
            return r

    def reveal_elem(self: MPCComms[TP], elem: TP, field: TP = param.BASE_P) -> TP:
        if self.pid == 0:
            return elem
        
        received_elem = TP()
        if self.pid == 1:
            sent_data = self.send_data[TP](elem, 3 - self.pid, param.SIZE_OF_U)
            received_elem = self.receive_elem(3 - self.pid)
        else:
            received_elem = self.receive_elem(3 - self.pid)
            sent_data = self.send_data[TP](elem, 3 - self.pid, param.SIZE_OF_U)
        
        return (elem + received_elem) % field
    
    def reveal_vector(self: MPCComms[TP], elem: list[TP], field: TP = param.BASE_P) -> list[TP]:
        if self.pid == 0:
            return elem
        
        received_elem = list[TP]()
        if self.pid == 1:
            sent_data = self.send_data[list[TP]](elem, 3 - self.pid, len(elem) * param.SIZE_OF_U)
            received_elem = self.receive_vector(3 - self.pid, len(elem))
        else:
            received_elem = self.receive_vector(3 - self.pid, len(elem))
            sent_data = self.send_data[list[TP]](elem, 3 - self.pid, len(elem) * param.SIZE_OF_U)
            
        return (elem + received_elem) % field
    
    def reveal_matrix(self: MPCComms[TP], elem: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        if self.pid == 0:
            return elem
        
        received_elem = list[list[TP]]()
        if self.pid == 1:
            shape = elem.shape()
            sent_data = self.send_data[list[list[TP]]](elem, 3 - self.pid, param.SIZE_OF_U * shape[0] * shape[1])
            received_elem = self.receive_matrix(3 - self.pid, shape)
        else:
            shape = elem.shape()
            received_elem = self.receive_matrix(3 - self.pid, shape)
            sent_data = self.send_data[list[list[TP]]](elem, 3 - self.pid, param.SIZE_OF_U * shape[0] * shape[1])
            
        return (elem + received_elem) % field
    
    def clean_up(self: MPCComms[TP]):
        for socket in self.sockets.values():
            socket.close()
    
    def print_stats(self: MPCComms[TP]):
        print f'Total bytes sent from {self.pid}: {self.bytes_sent}.'
        print f'Total send requests at {self.pid}: {self.requests_sent}.'
    
    def reset_stats(self: MPCComms[TP]):
        self.bytes_sent = 0
        self.requests_sent = 0
