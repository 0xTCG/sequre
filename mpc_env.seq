import utils.param as param

from mpc_comms import MPCComms
from mpc_prg import MPCPRG
from mpc_arithmetic import MPCArithmetic
from mpc_polynomial import MPCPolynomial
from mpc_boolean import MPCBoolean
from mpc_fp import MPCFP
from mpc_lin_alg import MPCLinAlg
from mpc_optimizations import MPCOptimizations

from utils.utils import cartesian, rand_vec, evalp
from utils.type_ops import TypeOps
from utils.custom_types import SecureNumber


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: param.BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.comms = MPCComms[TP](self.pid)
        self.prg = MPCPRG(self.pid)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp)
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_) -> SecureNumber:
        field = self.primes[0]
        x = [x_[i].share for i in range(len(x_))]
        coefs = [param.size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        return SecureNumber(self.optimizations.secure_evalp(
            x, coefs, exps, field))

    def secure_mult(self, x, y) -> SecureNumber:
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.beaver_partition_elem(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.beaver_partition_elem(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.beaver_reconstruct_elem(c, field)
        
        return SecureNumber(c)
    
    def secure_mult_no_cache(self, x_, y_) -> SecureNumber:
        x = x_.share
        y = y_.share
        return SecureNumber(self.arithmetic.multiply_elem(x, y))

    def secure_pow(self, x_, p) -> SecureNumber:
        field = self.primes[0]

        if p >= len(x_.pows):
            if not x_.is_partitioned():
                x_.set_partitions(self.arithmetic.beaver_partition_elem(x_.share, field))

            pows = self.polynomial.powers(
                [x_.share], p, field, [x_.x_r], [x_.r])
            for i in range(len(x_.pows), len(pows)):
                x_.pows.append(pows[i][0])
        
        return SecureNumber(x_.pows[p])

    def secure_pow_no_cache(self, x_, p) -> SecureNumber:
        x = x_.share
        # return SecureNumber(self.polynomial.powers([x], p)[-1][0])

        for _ in range(p - 1):
            x = self.arithmetic.multiply_elem(x, x_.share)
        
        return SecureNumber(x)
    
    def secure_reveal(self, e) -> SecureNumber:
        revealed_e = self.comms.reveal_elem(e.share)
        return SecureNumber(
            revealed_e // 2 + ((revealed_e % TP(2)) if self.pid == 1 else TP(0)),
            e.x_r,
            e.r)
    