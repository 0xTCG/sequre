import utils.param as param

from mpc_comms import MPCComms
from mpc_prg import MPCPRG
from mpc_arithmetic import MPCArithmetic
from mpc_polynomial import MPCPolynomial
from mpc_boolean import MPCBoolean
from mpc_fp import MPCFP
from mpc_lin_alg import MPCLinAlg
from mpc_optimizations import MPCOptimizations

from utils.utils import cartesian, rand_vec, evalp
from utils.type_ops import TypeOps
from utils.custom_types import SecureNumber


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: param.BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.comms = MPCComms[TP](self.pid)
        self.prg = MPCPRG(self.pid)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp)
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_):
        field = self.primes[0]
        x = [x_[i] for i in range(len(x_))]
        coefs = [param.size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        masks = self.optimizations.__get_masks(exps)
        masks_no = len(masks)
        x_r, r = self.arithmetic.beaver_partition_vec(x)
        r_masks = list[TP](masks_no)

        if self.pid == 0:
            for mask in masks:
                r_masks.append(r.powers(mask.split(), field))

            self.prg.switch_seed(1)
            r_ = rand_vec(masks_no, field)
            self.prg.restore_seed(1)

            r_masks = (r_masks - r_) % field
            self.comms.send_data(r_masks, 2, masks_no * param.SIZE_OF_U)

            return TP(0)
        
        if self.pid == 1:
            self.prg.switch_seed(0)
            r_masks = rand_vec(masks_no, field)
            self.prg.restore_seed(0)
        else:
            r_masks = self.comms.receive_vector(0, masks_no)
        
        coef_masks: dict[str, param.size_u] = {k: size_u(0) for k in masks}

        pascal_matrix: list[list[int]] = self.polynomial.get_pascal_matrix(
            max([e for t in exps for e in t]))
        for coef, exp_term in zip(coefs, exps):
            power_expansions = list[list[TP]](len(exp_term))
            for i, power in enumerate(exp_term):
                x_r_pow: list[TP] = [TypeOps.mod_pow(x_r[i], p, field) for p in range(power, -1, -1)]
                x_r_pow *= pascal_matrix[power][:power + 1]
                power_expansions.append(x_r_pow % field)
            
            exp_term_ranges = [[str(e) for e in range(i + 1)] for i in exp_term]
            exp_masks: list[str] = sorted(self.optimizations.generate_masks(exp_term_ranges))[1:]

            for mask in exp_masks:
                mults = TP(1)
                for i, m in enumerate(mask.split()):
                    mults *= power_expansions[i][int(m)]
                    mults %= field
                coef_masks[mask] = (coef_masks[mask] + mults * coef) % field

        result = evalp(x_r, coefs, exps, field) if self.pid == 1 else TP(0)
        for i in range(masks_no): result += r_masks[i] * coef_masks[masks[i]]

        return result    

    def secure_mult(self, x, y):
        return self.arithmetic.multiply_elem(x, y)
        
        # field = self.primes[0]
        # if not x.is_partitioned():
        #     x.set_partitions(self.arithmetic.beaver_partition_elem(x.share, field))
        # if not y.is_partitioned():
        #     y.set_partitions(self.arithmetic.beaver_partition_elem(y.share, field))
        
        # x_1_r, r_1 = x.get_partitions()
        # x_2_r, r_2 = y.get_partitions()

        # c = self.arithmetic.beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        # c = self.arithmetic.beaver_reconstruct_elem(c, field)
        
        # return SecureNumber(c)
