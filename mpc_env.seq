import utils.param as param

from mpc_comms import MPCComms
from mpc_prg import MPCPRG
from mpc_arithmetic import MPCArithmetic
from mpc_polynomial import MPCPolynomial
from mpc_boolean import MPCBoolean
from mpc_fp import MPCFP
from mpc_lin_alg import MPCLinAlg
from mpc_optimizations import MPCOptimizations

from utils.utils import cartesian, rand_vec, evalp
from utils.type_ops import TypeOps
from utils.custom_types import SecureNumber


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: param.BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.comms = MPCComms[TP](self.pid)
        self.prg = MPCPRG(self.pid)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp)
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_):
        field = self.primes[0]
        x = [x_[i].share for i in range(len(x_))]
        coefs = [param.size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        return SecureNumber(self.optimizations.secure_evalp(
            x, coefs, exps, field))

    def secure_mult(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.beaver_partition_elem(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.beaver_partition_elem(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.beaver_reconstruct_elem(c, field)
        
        return SecureNumber(c)
    
    def secure_mult_no_cache(self, x_, y_):
        x = x_.share
        y = y_.share
        return SecureNumber(self.arithmetic.multiply_elem(x, y))
