import utils.param as param

from mpc_comms import MPCComms
from mpc_prg import MPCPRG
from mpc_arithmetic import MPCArithmetic
from mpc_polynomial import MPCPolynomial
from mpc_boolean import MPCBoolean
from mpc_fp import MPCFP
from mpc_lin_alg import MPCLinAlg
from mpc_optimizations import MPCOptimizations

from utils.utils import cartesian, rand_vec, evalp
from utils.type_ops import TypeOps
from utils.custom_types import SecureValue


class MPCEnv[TP]:
    pid: int
    primes: dict[int, TP]
    comms: MPCComms[TP]
    prg: MPCPRG
    arithmetic: MPCArithmetic[TP]
    polynomial: MPCPolynomial[TP]
    boolean: MPCBoolean[TP]
    fp: MPCFP[TP]
    lin_alg: MPCLinAlg[TP]
    optimizations: MPCOptimizations[TP]

    def __init__(self: MPCEnv[TP], pid: int):
        self.pid = pid
        self.primes = {0: param.BASE_P, 1: TP(31), 2: TP(17)}  # Temp hardcoded. Needs to be calcualted on init.

        self.prg = MPCPRG(self.pid)
        self.comms = MPCComms[TP](self.pid, self.prg)
        self.arithmetic = MPCArithmetic[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms)
        self.polynomial = MPCPolynomial[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic)
        self.boolean = MPCBoolean[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
        self.fp = MPCFP[TP](
            pid=self.pid,
            primes=self.primes,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial,
            boolean=self.boolean)
        self.lin_alg = MPCLinAlg[TP](
            pid=self.pid,
            arithmetic=self.arithmetic,
            boolean=self.boolean,
            fp=self.fp)
        
        self.optimizations = MPCOptimizations[TP](
            pid=self.pid,
            prg=self.prg,
            comms=self.comms,
            arithmetic=self.arithmetic,
            polynomial=self.polynomial)
    
    def secure_evalp(self, x_, coefs_, exps_):
        field = self.primes[0]
        x_r = list[TP](len(x_))
        r = list[TP](len(x_))

        for sn in x_:
            if not sn.is_partitioned():
                sn.set_partitions(
                    self.arithmetic.beaver_partition_elem(sn.share, field))
            
            x_r_, r_ = sn.get_partitions()
            x_r.append(x_r_)
            r.append(r_)

        coefs = [param.size_u(coefs_[i])
                 for i in range(len(coefs_))]
        exps = [[exps_[i + j] for j in range(len(x_))]
                for i in range(0, len(exps_), len(x_))]
        
        result = self.optimizations.secure_evalp(
            x_r, r, coefs, exps, field)
        
        return SecureValue[typeof(result)](result)

    def secure_mult(self, x, y):
        field = self.primes[0]
        if not x.is_partitioned():
            x.set_partitions(self.arithmetic.beaver_partition(x.share, field))
        if not y.is_partitioned():
            y.set_partitions(self.arithmetic.beaver_partition(y.share, field))
        
        x_1_r, r_1 = x.get_partitions()
        x_2_r, r_2 = y.get_partitions()

        c = self.arithmetic.__beaver_mult(x_1_r, r_1, x_2_r, r_2, field)
        c = self.arithmetic.beaver_reconstruct(c, field)
        
        return SecureValue[typeof(c)](c)
    
    def secure_mult_no_cache(self, x_, y_):
        x = x_.share
        y = y_.share

        c = self.arithmetic.multiply(x, y)

        return SecureValue[typeof(c)](c)

    def secure_pow(self, x_, p):
        field = self.primes[0]

        if p >= len(x_.pows):
            if not x_.is_partitioned():
                x_.set_partitions(self.arithmetic.beaver_partition(x_.share, field))

            if isinstance(x_.share, list[list[TP]]):
                pows = self.polynomial.powers(
                    x_.share.flatten(), p, field,
                    x_.x_r.flatten(), x_.r.flatten())
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append([pows[i]].reshape(x_.share.shape()))
            elif isinstance(x_.share, list[TP]): 
                pows = self.polynomial.powers(
                    x_.share, p, field,
                    x_.x_r, x_.r)
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append(pows[i])
            else:
                pows = self.polynomial.powers(
                    [x_.share], p, field,
                    [x_.x_r], [x_.r])
                for i in range(len(x_.pows), len(pows)):
                    x_.pows.append(pows[i][0])
        
        c = x_.pows[p]

        return SecureValue[typeof(c)](c)

    def secure_pow_no_cache(self, x_, p):
        x = x_.share
        # return SecureValue[TP](self.polynomial.powers([x], p)[-1][0])

        for _ in range(p - 1):
            x = self.arithmetic.multiply(x, x_.share)
        
        return SecureValue[typeof(x)](x)
    
    def secure_reveal(self, e):
        revealed_e = self.comms.reveal(e.share)
        
        c = revealed_e // 2
        if self.pid == 1: c += (revealed_e % TP(2))
            
        return SecureValue[typeof(c)](c, e.x_r, e.r)
    