import utils.param as param

from mpc_prg import MPCPRG
from mpc_comms import MPCComms
from utils.utils import rand_vec, rand_mat, rand_int

class MPCArithmetic[TP]:
    pid: int
    prg: MPCPRG
    comms: MPCComms[TP]
    
    def __init__(self: MPCArithmetic[TP], pid: int, prg: MPCPRG, comms: MPCComms[TP]):
        self.pid = pid
        self.prg = prg
        self.comms = comms
    
    def beaver_partition(self, value, field):
        if isinstance(value, TP):
            return self.beaver_partition_elem(value, field)
        elif isinstance(value, list[TP]):
            return self.beaver_partition_vec(value, field)
        elif isinstance(value, list[list[TP]]):
            return self.beaver_partition_mat(value, field)
        
        raise TypeError(f"Invalid type for {value}")

    def beaver_reconstruct(self, value, field):
        if isinstance(value, TP):
            return self.beaver_reconstruct_elem(value, field)
        elif isinstance(value, list[TP]):
            return self.beaver_reconstruct_vec(value, field)
        elif isinstance(value, list[list[TP]]):
            return self.beaver_reconstruct_mat(value, field)
        
        raise TypeError(f"Invalid type for {value}")
    
    def multiply(self, a, b, field = param.BASE_P):
        if isinstance(a, TP):
            return self.multiply_elem(a, b, field)
        elif isinstance(a, list[TP]):
            return self.multiply_vec(a, b, field)
        elif isinstance(a, list[list[TP]]):
            return self.multiply_mat(a, b, field)
        
        raise TypeError(f"Invalid type for {a}")

    def add_public[CT](self: MPCArithmetic[TP], x: CT, a: CT, field: TP = param.BASE_P) -> CT:
        if self.pid == 1:
            return (x + a) % field
        return x
    
    def add_public_scalar[CT](self: MPCArithmetic[TP], x: CT, a: TP, field: TP = param.BASE_P) -> CT:
        if self.pid == 1:
            return (x + a) % field
        return x
    
    def beaver_mult[CT](
            self: MPCArithmetic[TP], x_r: CT, r_1: CT,
            y_r: CT, r_2: CT, field: TP = param.BASE_P) -> CT:
        if self.pid == 0:
            return (r_1 * r_2) % field

        xy: CT = (x_r * r_2) % field
        xy += (r_1 * y_r) % field
        xy %= field
        
        if self.pid == 1:
            xy += (x_r * y_r) % field
            xy %= field

        return xy
    
    def beaver_mult_vec[CT](
            self: MPCArithmetic[TP], x_r: CT, r_1: CT,
            y_r: list[CT], r_2: list[CT], field: TP = param.BASE_P) -> list[TP]:
        # return self.beaver_mult_mat([x_r], [r_1], y_r, r_2)[0]
        return [TP(0) for _ in range(len(r_1))]
    
    def beaver_mult_scalar[CT](
            self: MPCArithmetic[TP], x_r: CT, r_1: CT,
            y_r: TP, r_2: TP, field: TP = param.BASE_P) -> CT:
        if self.pid == 0:
            return (r_1 * r_2) % field

        xy: CT = (x_r * r_2) % field
        xy += (r_1 * y_r) % field
        xy %= field
        
        if self.pid == 1:
            xy += (x_r * y_r) % field
            xy %= field

        return xy
    
    def beaver_mult_mat(
            self: MPCArithmetic[TP], x_r: list[list[TP]], r_1: list[list[TP]],
            y_r: list[list[TP]], r_2: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        if self.pid == 0:
            return r_1.mult(r_2, field)

        xy = x_r.mult(r_2, field)
        xy += r_1.mult(y_r, field)
        xy %= field
        if self.pid == 1:
            xy += x_r.mult(y_r, field)
            xy %= field

        return xy

    def beaver_reconstruct_elem(self: MPCArithmetic[TP], elem: TP, field: TP = param.BASE_P) -> TP:
            if self.pid == 0:
                self.prg.switch_seed(1)
                mask = TP(rand_int(field))
                self.prg.restore_seed(1)

                mm = (elem - mask) % field
                self.comms.send(mm, 2)
                
                return mm
            elif self.pid == 1:
                self.prg.switch_seed(0)
                rr = TP(rand_int(field))
                self.prg.restore_seed(0)
                
                return (elem + rr) % field
            else:
                rr = self.comms.receive(0)
                    
                return (elem + rr) % field

    def beaver_reconstruct_vec(self: MPCArithmetic[TP], vec: list[TP], field: TP = param.BASE_P) -> list[TP]:
            if self.pid == 0:
                self.prg.switch_seed(1)
                mask = rand_vec(len(vec), field)
                self.prg.restore_seed(1)

                mm = (vec - mask) % field
                self.comms.send(mm, 2)
                
                return mm
            elif self.pid == 1:
                self.prg.switch_seed(0)
                rr = rand_vec(len(vec), field)
                self.prg.restore_seed(0)
                
                return (vec + rr) % field
            else:
                rr = self.comms.receive(0, len(vec))
                    
                return (vec + rr) % field
    
    def beaver_reconstruct_mat(self: MPCArithmetic[TP], mat: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
            shape = mat.shape()
            
            if self.pid == 0:
                self.prg.switch_seed(1)
                mask = rand_mat(shape, field)
                self.prg.restore_seed(1)

                mm = (mat - mask) % field
                self.comms.send(mm, 2)
                
                return mm
            elif self.pid == 1:
                self.prg.switch_seed(0)
                rr = rand_mat(shape, field)
                self.prg.restore_seed(0)
                
                return (mat + rr) % field
            else:
                rr = self.comms.receive(0, shape)
                    
                return (mat + rr) % field
    
    def beaver_partition_elem(self: MPCArithmetic[TP], x: TP, field: TP = param.BASE_P) -> tuple[TP, TP]:
        x_ = x % field
        x_r = TP(0)

        if self.pid == 0:
            self.prg.switch_seed(1)
            r_1 = TP(rand_int(field))
            self.prg.restore_seed(1)

            self.prg.switch_seed(2)
            r_2 = TP(rand_int(field))
            self.prg.restore_seed(2)

            r = (r_1 + r_2) % field
            return x_r, r
        else:
            self.prg.switch_seed(0)
            r = TP(rand_int(field))
            self.prg.restore_seed(0)
            
            x_r = (x_ - r) % field
            x_r = self.comms.reveal(x_r, field=field)

            return x_r, r
    
    def beaver_partition_vec(self: MPCArithmetic[TP], x: list[TP], field: TP = param.BASE_P) -> tuple[list[TP], list[TP]]:
        x_ = x % field
        x_len = len(x_)

        if self.pid == 0:
            self.prg.switch_seed(1)
            r_1 = rand_vec(x_len, field)
            self.prg.restore_seed(1)

            self.prg.switch_seed(2)
            r_2 = rand_vec(x_len, field)
            self.prg.restore_seed(2)

            r = (r_1 + r_2) % field
            return [TP(0) for _ in range(x_len)], r
        else:
            self.prg.switch_seed(0)
            r = rand_vec(x_len, field)
            self.prg.restore_seed(0)
            
            x_r = (x_ - r) % field
            x_r = self.comms.reveal(x_r, field=field)
        
            return x_r, r

    def beaver_partition_mat(self: MPCArithmetic[TP], x: list[list[TP]], field: TP = param.BASE_P) -> tuple[list[list[TP]], list[list[TP]]]:
        x_ = x % field
        shape = x_.shape()

        if self.pid == 0:
            self.prg.switch_seed(1)
            r_1 = rand_mat(shape, field)
            self.prg.restore_seed(1)

            self.prg.switch_seed(2)
            r_2 = rand_mat(shape, field)
            self.prg.restore_seed(2)

            r = (r_1 + r_2) % field
            return [[TP(0) for _ in range(shape[1])] for _ in range(shape[0])], r
        else:
            self.prg.switch_seed(0)
            r = rand_mat(shape, field)
            self.prg.restore_seed(0)
            
            x_r = (x_ - r) % field
            x_r = self.comms.reveal(x_r, field=field)
        
            return x_r, r
    
    def multiply_elem(self: MPCArithmetic[TP], a: TP, b: TP, field: TP = param.BASE_P) -> TP:
        x_1_r, r_1 = self.beaver_partition_elem(a, field)
        x_2_r, r_2 = self.beaver_partition_elem(b, field)
        
        c = self.beaver_mult[TP](x_1_r, r_1, x_2_r, r_2, field)
        c = self.beaver_reconstruct_elem(c, field)
        
        return c

    def multiply_vec(self: MPCArithmetic[TP], a: list[TP], b: list[TP], field: TP = param.BASE_P) -> list[TP]:
        x_1_r, r_1 = self.beaver_partition_vec(a, field)
        x_2_r, r_2 = self.beaver_partition_vec(b, field)
        
        c = self.beaver_mult[list[TP]](x_1_r, r_1, x_2_r, r_2, field)
        c = self.beaver_reconstruct_vec(c, field)
        
        return c
    
    def multiply_vec_scalar(self: MPCArithmetic[TP], a: list[TP], b: TP, field: TP = param.BASE_P) -> list[TP]:
        x_1_r, r_1 = self.beaver_partition_vec(a, field)
        x_2_r, r_2 = self.beaver_partition_elem(b, field)
        
        c = self.beaver_mult_scalar[list[TP]](x_1_r, r_1, x_2_r, r_2, field)
        c = self.beaver_reconstruct_vec(c, field)
        
        return c

    def multiply_mat(self: MPCArithmetic[TP], a: list[list[TP]], b: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        x_1_r, r_1 = self.beaver_partition_mat(a, field)
        x_2_r, r_2 = self.beaver_partition_mat(b, field)

        c = self.beaver_mult[list[list[TP]]](x_1_r, r_1, x_2_r, r_2, field)
        c = self.beaver_reconstruct_mat(c, field)

        return c
    
    def multiply_matmul(self: MPCArithmetic[TP], a: list[list[TP]], b: list[list[TP]], field: TP = param.BASE_P) -> list[list[TP]]:
        x_1_r, r_1 = self.beaver_partition_mat(a, field)
        x_2_r, r_2 = self.beaver_partition_mat(b, field)
        
        c = self.beaver_mult_mat(x_1_r, r_1, x_2_r, r_2, field)
        c = self.beaver_reconstruct_mat(c, field)
        
        return c
    
    def beaver_partition_mat_bulk(self: MPCArithmetic[TP], x: list[list[list[TP]]], field: TP = param.BASE_P) -> tuple[list[list[list[TP]]], list[list[list[TP]]]]:
        # TODO: Do this in parallel
        partitions = [self.beaver_partition_mat(e, field) for e in x]
        x_r = [p[0] for p in partitions]
        r = [p[1] for p in partitions]
        return x_r, r
    
    def beaver_reconstruct_mat_bulk(self: MPCArithmetic[TP], x: list[list[list[TP]]], field: TP = param.BASE_P) -> list[list[list[TP]]]:
        # TODO: Do this in parallel
        return [self.beaver_reconstruct_mat(e, field) for e in x]

    def multiply_bulk(self: MPCArithmetic[TP], a: list[list[list[TP]]], b: list[list[list[TP]]], field: TP = param.BASE_P) -> list[list[list[TP]]]:
        # TODO: Vectorize this method. Make it parallel by having a and b as ndarrays.
        nmat = len(a)

        # TODO: Remove this check
        # for k in range(nmat):
        #     assert a[k].shape() == b[k].shape()

        ar, am = self.beaver_partition_mat_bulk(a, field)
        br, bm = self.beaver_partition_mat_bulk(b, field)

        c = [self.beaver_mult(ar[k], am[k], br[k], bm[k], field)
             for k in range(nmat)]
        
        return self.beaver_reconstruct_mat_bulk(c, field)
    
    def multiply_mat_bulk(self: MPCArithmetic[TP], a: list[list[list[TP]]], b: list[list[list[TP]]], field: TP = param.BASE_P) -> list[list[list[TP]]]:
        # TODO: Vectorize/parallelize this method. Make it parallel by having a and b as ndarrays.
        nmat = len(a)

        # TODO: Remove this check
        # for k in range(nmat):
        #     assert a[k].shape()[1] == b[k].shape()[0]

        ar, am = self.beaver_partition_mat_bulk(a, field)
        br, bm = self.beaver_partition_mat_bulk(b, field)

        c = [self.beaver_mult_mat(ar[k], am[k], br[k], bm[k], field)
             for k in range(nmat)]
            
        return self.beaver_reconstruct_mat_bulk(c, field)

    def beaver_inner_prod(self: MPCArithmetic[TP], ar: list[TP], am: list[TP], field: TP = param.BASE_P) -> TP:
        ab = ((am * am) % field) if self.pid == 0 else (((ar * am) % field) * 2) % field
        if self.pid == 1:
            ab = (ab + (ar * ar) % field) % field

        cum_sum = TP(0)
        for e in ab: cum_sum = (cum_sum + e) % field

        return cum_sum
    
    def beaver_inner_prod_pair(
            self: MPCArithmetic[TP], ar: list[TP], am: list[TP], br: list[TP], bm: list[TP], field: TP = param.BASE_P) -> TP:
        ab = TP(0)
        
        for i in range(len(ar)):
            if self.pid == 0:
                ab += am[i] * bm[i]
            else:
                ab += ar[i] * bm[i]
                ab %= field
                ab += br[i] * am[i]
                ab %= field
                if self.pid == 1:
                    ab += ar[i] * br[i]

        return ab % field
    
    def inner_prod(self: MPCArithmetic[TP], a: list[list[TP]], field: TP = param.BASE_P) -> list[TP]:
        ar, am = self.beaver_partition_mat(a, field)
        n = len(a)

        c = list[TP](n)
        for i in range(n): c.append(self.beaver_inner_prod(ar[i], am[i], field))

        return self.beaver_reconstruct_vec(c, field)
